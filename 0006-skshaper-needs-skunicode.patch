From 7e3b4197f913119814391c5a2fcbdcb6ecc443b3 Mon Sep 17 00:00:00 2001
From: Hin-Tak Leung <htl10@users.sourceforge.net>
Date: Thu, 21 Nov 2024 01:25:50 +0000
Subject: [PATCH 6/7] skshaper needs skunicode...

Signed-off-by: Hin-Tak Leung <htl10@users.sourceforge.net>
---
 .../skia/modules/skunicode/BUILD.bazel        |  68 ++
 .../skia/modules/skunicode/BUILD.gn           | 220 ++++++
 .../modules/skunicode/include/BUILD.bazel     |  35 +
 .../modules/skunicode/include/SkUnicode.h     | 307 ++++++++
 .../skunicode/include/SkUnicode_client.h      |  25 +
 .../modules/skunicode/include/SkUnicode_icu.h |  18 +
 .../skunicode/include/SkUnicode_icu4x.h       |  19 +
 .../skunicode/include/SkUnicode_libgrapheme.h |  19 +
 .../skia/modules/skunicode/skunicode.gni      |  73 ++
 .../skia/modules/skunicode/src/BUILD.bazel    | 103 +++
 .../skunicode/src/SkBidiFactory_icu_full.cpp  |  54 ++
 .../skunicode/src/SkBidiFactory_icu_full.h    |  40 +
 .../src/SkBidiFactory_icu_subset.cpp          |  50 ++
 .../skunicode/src/SkBidiFactory_icu_subset.h  |  40 +
 .../skia/modules/skunicode/src/SkUnicode.cpp  |  73 ++
 .../skunicode/src/SkUnicode_client.cpp        | 263 +++++++
 .../skunicode/src/SkUnicode_hardcoded.cpp     | 130 ++++
 .../skunicode/src/SkUnicode_hardcoded.h       |  29 +
 .../modules/skunicode/src/SkUnicode_icu.cpp   | 700 ++++++++++++++++++
 .../modules/skunicode/src/SkUnicode_icu4x.cpp | 409 ++++++++++
 .../skunicode/src/SkUnicode_icu_bidi.cpp      | 153 ++++
 .../skunicode/src/SkUnicode_icu_bidi.h        |  56 ++
 .../skunicode/src/SkUnicode_icu_builtin.cpp   |  67 ++
 .../skunicode/src/SkUnicode_icu_runtime.cpp   |  86 +++
 .../modules/skunicode/src/SkUnicode_icupriv.h |  73 ++
 .../skunicode/src/SkUnicode_libgrapheme.cpp   | 303 ++++++++
 .../skia/modules/skunicode/tests/BUILD.bazel  |  12 +
 .../modules/skunicode/tests/SkUnicodeTest.cpp | 368 +++++++++
 28 files changed, 3793 insertions(+)
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/skunicode.gni
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp

diff --git a/Source/ThirdParty/skia/modules/skunicode/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/BUILD.bazel
new file mode 100644
index 00000000..c9dbf371
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/BUILD.bazel
@@ -0,0 +1,68 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "skunicode_core",
+    srcs = [
+        "//modules/skunicode/src:srcs",
+    ],
+    hdrs = ["//modules/skunicode/include:core_hdrs"],
+    defines = [
+        "SK_UNICODE_AVAILABLE",
+    ],
+    visibility = [
+        "//:__pkg__",
+        "//modules:__subpackages__",
+    ],
+    deps = [
+        "//:core",
+        "//src/base",
+        "//src/core:core_priv",
+    ],
+)
+
+skia_cc_library(
+    name = "skunicode_icu",
+    srcs = [
+        "//modules/skunicode/src:bidi_full_srcs",
+        "//modules/skunicode/src:icu_bidi_srcs",
+        "//modules/skunicode/src:icu_core_srcs",
+    ] + select({
+        "@platforms//os:android": [
+            "//modules/skunicode/src:runtime_srcs",
+        ],
+        "//conditions:default": [
+            "//modules/skunicode/src:builtin_srcs",
+        ],
+    }),
+    hdrs = [
+        "//modules/skunicode/include:core_hdrs",
+        "//modules/skunicode/include:icu_hdrs",
+    ],
+    defines = [
+        "SK_UNICODE_AVAILABLE",
+        "SK_UNICODE_ICU_IMPLEMENTATION",
+    ] + select({
+        "@platforms//os:android": ["SK_UNICODE_RUNTIME_ICU_AVAILABLE"],
+        "//conditions:default": [],
+    }),
+    features = ["layering_check"],
+    visibility = [
+        "//:__pkg__",
+        "//modules:__subpackages__",
+    ],
+    deps = [
+        ":skunicode_core",
+        "//:core",
+        "//src/base",
+        "//src/core:core_priv",
+    ] + select({
+        "@platforms//os:android": ["@icu//:icu_headers"],
+        "//conditions:default": ["@icu"],
+    }),
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/BUILD.gn b/Source/ThirdParty/skia/modules/skunicode/BUILD.gn
new file mode 100644
index 00000000..7a4dcb76
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/BUILD.gn
@@ -0,0 +1,220 @@
+# Copyright 2021 Google Inc.
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+import("../../third_party/icu/icu.gni")
+import("skunicode.gni")
+
+declare_args() {
+  skia_use_runtime_icu = false
+  skunicode_tests_enabled = true
+}
+
+if (skia_use_icu || skia_use_client_icu || skia_use_libgrapheme ||
+    skia_use_icu4x) {
+  config("public_config") {
+    defines = [ "SK_UNICODE_AVAILABLE" ]
+    if (skia_use_icu) {
+      defines += [ "SK_UNICODE_ICU_IMPLEMENTATION" ]
+    }
+    if (skia_use_client_icu) {
+      defines += [ "SK_UNICODE_CLIENT_IMPLEMENTATION" ]
+    }
+    if (skia_use_libgrapheme) {
+      defines += [ "SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION" ]
+    }
+    if (skia_use_icu4x) {
+      defines += [ "SK_UNICODE_ICU4X_IMPLEMENTATION" ]
+    }
+  }
+
+  config("cpp20") {
+    if (is_win) {
+      cflags_cc = [ "/std:c++20" ]
+    } else {
+      cflags_cc = [ "-std=c++20" ]
+    }
+  }
+
+  config("module") {
+    defines = [ "SKUNICODE_IMPLEMENTATION=1" ]
+    if (is_component_build) {
+      defines += [ "SKUNICODE_DLL" ]
+    }
+  }
+
+  component("skunicode_core") {
+    check_includes = false
+    deps = [ "../..:skia" ]
+    configs += [
+      ":module",
+      "../../:skia_private",
+      "../../third_party/icu/config:no_cxx",
+    ]
+    sources = skia_unicode_sources
+  }
+
+  if (skia_use_icu) {
+    component("skunicode_icu") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+
+      # These are explicitly *not* public defines because we don't want them
+      # to leak to dependents.
+      defines = [ "U_USING_ICU_NAMESPACE=0" ]
+      if (!skia_use_system_icu) {
+        defines += [ "U_DISABLE_RENAMING=1" ]
+      }
+
+      sources = skia_unicode_icu_bidi_sources
+      sources += skia_unicode_bidi_full_sources
+      sources += skia_unicode_icu_sources
+
+      # only available for Android at the moment
+      if (skia_use_runtime_icu && (is_android || is_linux)) {
+        sources += skia_unicode_runtime_icu_sources
+        defines += [ "SK_UNICODE_RUNTIME_ICU_AVAILABLE" ]
+        deps += [ "//third_party/icu:headers" ]
+      } else {
+        sources += skia_unicode_builtin_icu_sources
+        deps += [ "//third_party/icu" ]
+      }
+    }
+  }
+
+  if (skia_use_client_icu) {
+    component("skunicode_client_icu") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+      defines = [
+        # In order to use the bidi_subset at the same time as "full ICU", we must have
+        # compiled icu with the given defines also being set. This is to make sure the functions
+        # we call are given a suffix of "_skia" to prevent ODR violations if this "subset of ICU"
+        # is compiled alongside a full ICU build also.
+        # See https://chromium.googlesource.com/chromium/deps/icu.git/+/d94ab131bc8fef3bc17f356a628d8e4cd44d65d9/source/common/unicode/uversion.h
+        # for how these are used.
+        "U_DISABLE_RENAMING=0",
+        "U_USING_ICU_NAMESPACE=0",
+        "U_LIB_SUFFIX_C_NAME=_skia",
+        "U_HAVE_LIB_SUFFIX=1",
+        "U_DISABLE_VERSION_SUFFIX=1",
+      ]
+
+      sources = skia_unicode_icu_bidi_sources
+      sources += skia_unicode_bidi_subset_sources
+      sources += skia_unicode_client_icu_sources
+      deps += [ skia_icu_bidi_third_party_dir ]
+    }
+  }
+
+  if (skia_use_libgrapheme) {
+    component("skunicode_libgrapheme") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+      defines = [
+        "U_DISABLE_RENAMING=0",
+        "U_USING_ICU_NAMESPACE=0",
+        "U_LIB_SUFFIX_C_NAME=_skia",
+        "U_HAVE_LIB_SUFFIX=1",
+        "U_DISABLE_VERSION_SUFFIX=1",
+      ]
+
+      sources = skia_unicode_icu_bidi_sources
+      sources += skia_unicode_bidi_subset_sources
+
+      sources += skia_unicode_libgrapheme_sources
+      deps += [
+        skia_icu_bidi_third_party_dir,
+        skia_libgrapheme_third_party_dir,
+      ]
+    }
+  }
+
+  if (skia_use_icu4x) {
+    component("skunicode_icu4x") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+
+      sources = skia_unicode_icu4x_sources
+
+      deps += [ "//third_party/icu4x" ]
+    }
+  }
+
+  group("skunicode") {
+    public_configs = [ ":public_config" ]
+    public_deps = [ ":skunicode_core" ]
+
+    # We have these different flavors of skunicode as independent components because
+    # we have to set different defines for different builds of ICU.
+    if (skia_use_icu) {
+      public_deps += [ ":skunicode_icu" ]
+    }
+    if (skia_use_client_icu) {
+      public_deps += [ ":skunicode_client_icu" ]
+    }
+    if (skia_use_libgrapheme) {
+      public_deps += [ ":skunicode_libgrapheme" ]
+    }
+    if (skia_use_icu4x) {
+      public_deps += [ ":skunicode_icu4x" ]
+    }
+  }
+
+  if (defined(is_skia_standalone) && skia_enable_tools) {
+    skia_source_set("tests") {
+      if (skunicode_tests_enabled &&
+          (skia_use_icu || skia_use_libgrapheme || skia_use_icu4x)) {
+        testonly = true
+        deps = [
+          ":skunicode",
+          "../..:skia",
+          "../..:test",
+        ]
+        sources = skia_unicode_tests
+        deps += [ skia_icu_bidi_third_party_dir ]
+      } else {
+        sources = []
+      }
+    }
+  }
+} else {
+  group("skunicode") {
+  }
+  group("tests") {
+  }
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel
new file mode 100644
index 00000000..84117885
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel
@@ -0,0 +1,35 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "hdrs",
+    srcs = [
+        "SkUnicode.h",
+        "SkUnicode_client.h",
+        "SkUnicode_icu.h",
+        "SkUnicode_icu4x.h",
+        "SkUnicode_libgrapheme.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "core_hdrs",
+    srcs = [
+        "SkUnicode.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_hdrs",
+    srcs = [
+        "SkUnicode_icu.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h
new file mode 100644
index 00000000..6b91a10c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2020 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_DEFINED
+#define SkUnicode_DEFINED
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTo.h"
+#include "src/base/SkUTF.h"
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+namespace sknonstd { template <typename T> struct is_bitmask_enum; }
+
+#if !defined(SKUNICODE_IMPLEMENTATION)
+    #define SKUNICODE_IMPLEMENTATION 0
+#endif
+
+#if !defined(SKUNICODE_API)
+    #if defined(SKUNICODE_DLL)
+        #if defined(_MSC_VER)
+            #if SKUNICODE_IMPLEMENTATION
+                #define SKUNICODE_API __declspec(dllexport)
+            #else
+                #define SKUNICODE_API __declspec(dllimport)
+            #endif
+        #else
+            #define SKUNICODE_API __attribute__((visibility("default")))
+        #endif
+    #else
+        #define SKUNICODE_API
+    #endif
+#endif
+
+class SKUNICODE_API SkBidiIterator {
+public:
+    typedef int32_t Position;
+    typedef uint8_t Level;
+    struct Region {
+        Region(Position start, Position end, Level level)
+            : start(start), end(end), level(level) { }
+        Position start;
+        Position end;
+        Level level;
+    };
+    enum Direction {
+        kLTR,
+        kRTL,
+    };
+    virtual ~SkBidiIterator() = default;
+    virtual Position getLength() = 0;
+    virtual Level getLevelAt(Position) = 0;
+};
+
+class SKUNICODE_API SkBreakIterator {
+public:
+    typedef int32_t Position;
+    typedef int32_t Status;
+    virtual ~SkBreakIterator() = default;
+    virtual Position first() = 0;
+    virtual Position current() = 0;
+    virtual Position next() = 0;
+    virtual Status status() = 0;
+    virtual bool isDone() = 0;
+    virtual bool setText(const char utftext8[], int utf8Units) = 0;
+    virtual bool setText(const char16_t utftext16[], int utf16Units) = 0;
+};
+
+class SKUNICODE_API SkUnicode : public SkRefCnt {
+    public:
+        enum CodeUnitFlags {
+            kNoCodeUnitFlag = 0x00,
+            kPartOfWhiteSpaceBreak = 0x01,
+            kGraphemeStart = 0x02,
+            kSoftLineBreakBefore = 0x04,
+            kHardLineBreakBefore = 0x08,
+            kPartOfIntraWordBreak = 0x10,
+            kControl = 0x20,
+            kTabulation = 0x40,
+            kGlyphClusterStart = 0x80,
+            kIdeographic = 0x100,
+            kEmoji = 0x200,
+            kWordBreak = 0x400,
+            kSentenceBreak = 0x800,
+        };
+        enum class TextDirection {
+            kLTR,
+            kRTL,
+        };
+        typedef size_t Position;
+        typedef uint8_t BidiLevel;
+        struct BidiRegion {
+            BidiRegion(Position start, Position end, BidiLevel level)
+              : start(start), end(end), level(level) { }
+            Position start;
+            Position end;
+            BidiLevel level;
+        };
+        enum class LineBreakType {
+            kSoftLineBreak = 0,
+            kHardLineBreak = 100,
+        };
+
+        enum class BreakType { kWords, kGraphemes, kLines, kSentences };
+        struct LineBreakBefore {
+            LineBreakBefore(Position pos, LineBreakType breakType)
+              : pos(pos), breakType(breakType) { }
+            Position pos;
+            LineBreakType breakType;
+        };
+
+        ~SkUnicode() override = default;
+
+        // deprecated
+        virtual SkString toUpper(const SkString&) = 0;
+        virtual SkString toUpper(const SkString&, const char* locale) = 0;
+
+        virtual bool isControl(SkUnichar utf8) = 0;
+        virtual bool isWhitespace(SkUnichar utf8) = 0;
+        virtual bool isSpace(SkUnichar utf8) = 0;
+        virtual bool isTabulation(SkUnichar utf8) = 0;
+        virtual bool isHardBreak(SkUnichar utf8) = 0;
+        /**
+         * Returns if a code point may start an emoji sequence.
+         * Returns true for '#', '*', and '0'-'9' since they may start an emoji sequence.
+         * To determine if a list of code points begins with an emoji sequence, use
+         * getEmojiSequence.
+         **/
+        virtual bool isEmoji(SkUnichar utf8) = 0;
+        virtual bool isEmojiComponent(SkUnichar utf8) = 0;
+        virtual bool isEmojiModifierBase(SkUnichar utf8) = 0;
+        virtual bool isEmojiModifier(SkUnichar utf8) = 0;
+        virtual bool isRegionalIndicator(SkUnichar utf8) = 0;
+        virtual bool isIdeographic(SkUnichar utf8) = 0;
+
+        // Methods used in SkShaper and SkText
+        virtual std::unique_ptr<SkBidiIterator> makeBidiIterator
+            (const uint16_t text[], int count, SkBidiIterator::Direction) = 0;
+        virtual std::unique_ptr<SkBidiIterator> makeBidiIterator
+            (const char text[], int count, SkBidiIterator::Direction) = 0;
+        virtual std::unique_ptr<SkBreakIterator> makeBreakIterator
+            (const char locale[], BreakType breakType) = 0;
+        virtual std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType type) = 0;
+
+        // Methods used in SkParagraph
+        static bool hasTabulationFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasHardLineBreakFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasSoftLineBreakFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasGraphemeStartFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasControlFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasPartOfWhiteSpaceBreakFlag(SkUnicode::CodeUnitFlags flags);
+
+        static bool extractBidi(const char utf8[],
+                                int utf8Units,
+                                TextDirection dir,
+                                std::vector<BidiRegion>* bidiRegions);
+        virtual bool getBidiRegions(const char utf8[],
+                                    int utf8Units,
+                                    TextDirection dir,
+                                    std::vector<BidiRegion>* results) = 0;
+        // Returns results in utf16
+        virtual bool getWords(const char utf8[], int utf8Units, const char* locale,
+                              std::vector<Position>* results) = 0;
+        virtual bool getUtf8Words(const char utf8[],
+                                  int utf8Units,
+                                  const char* locale,
+                                  std::vector<Position>* results) = 0;
+        virtual bool getSentences(const char utf8[],
+                                  int utf8Units,
+                                  const char* locale,
+                                  std::vector<Position>* results) = 0;
+        virtual bool computeCodeUnitFlags(
+                char utf8[], int utf8Units, bool replaceTabs,
+                skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) = 0;
+        virtual bool computeCodeUnitFlags(
+                char16_t utf16[], int utf16Units, bool replaceTabs,
+                skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) = 0;
+
+        static SkString convertUtf16ToUtf8(const char16_t * utf16, int utf16Units);
+        static SkString convertUtf16ToUtf8(const std::u16string& utf16);
+        static std::u16string convertUtf8ToUtf16(const char* utf8, int utf8Units);
+        static std::u16string convertUtf8ToUtf16(const SkString& utf8);
+
+        template <typename Appender8, typename Appender16>
+        static bool extractUtfConversionMapping(SkSpan<const char> utf8, Appender8&& appender8, Appender16&& appender16) {
+            size_t size8 = 0;
+            size_t size16 = 0;
+            auto ptr = utf8.begin();
+            auto end = utf8.end();
+            while (ptr < end) {
+
+                size_t index = SkToSizeT(ptr - utf8.begin());
+                SkUnichar u = SkUTF::NextUTF8(&ptr, end);
+
+                // All UTF8 code units refer to the same codepoint
+                size_t next = SkToSizeT(ptr - utf8.begin());
+                for (auto i = index; i < next; ++i) {
+                    //fUTF16IndexForUTF8Index.emplace_back(fUTF8IndexForUTF16Index.size());
+                    appender16(size8);
+                    ++size16;
+                }
+                //SkASSERT(fUTF16IndexForUTF8Index.size() == next);
+                SkASSERT(size16 == next);
+                if (size16 != next) {
+                    return false;
+                }
+
+                // One or two UTF16 code units refer to the same codepoint
+                uint16_t buffer[2];
+                size_t count = SkUTF::ToUTF16(u, buffer);
+                //fUTF8IndexForUTF16Index.emplace_back(index);
+                appender8(index);
+                ++size8;
+                if (count > 1) {
+                    //fUTF8IndexForUTF16Index.emplace_back(index);
+                    appender8(index);
+                    ++size8;
+                }
+            }
+            //fUTF16IndexForUTF8Index.emplace_back(fUTF8IndexForUTF16Index.size());
+            appender16(size8);
+            ++size16;
+            //fUTF8IndexForUTF16Index.emplace_back(fText.size());
+            appender8(utf8.size());
+            ++size8;
+
+            return true;
+        }
+
+        template <typename Callback>
+        void forEachCodepoint(const char* utf8, int32_t utf8Units, Callback&& callback) {
+            const char* current = utf8;
+            const char* end = utf8 + utf8Units;
+            while (current < end) {
+                auto before = current - utf8;
+                SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+                if (unichar < 0) unichar = 0xFFFD;
+                auto after = current - utf8;
+                uint16_t buffer[2];
+                size_t count = SkUTF::ToUTF16(unichar, buffer);
+                callback(unichar, before, after, count);
+            }
+        }
+
+        template <typename Callback>
+        void forEachCodepoint(const char16_t* utf16, int32_t utf16Units, Callback&& callback) {
+            const char16_t* current = utf16;
+            const char16_t* end = utf16 + utf16Units;
+            while (current < end) {
+                auto before = current - utf16;
+                SkUnichar unichar = SkUTF::NextUTF16((const uint16_t**)&current, (const uint16_t*)end);
+                auto after = current - utf16;
+                callback(unichar, before, after);
+            }
+        }
+
+        template <typename Callback>
+        void forEachBidiRegion(const uint16_t utf16[], int utf16Units, SkBidiIterator::Direction dir, Callback&& callback) {
+            auto iter = makeBidiIterator(utf16, utf16Units, dir);
+            const uint16_t* start16 = utf16;
+            const uint16_t* end16 = utf16 + utf16Units;
+            SkBidiIterator::Level currentLevel = 0;
+
+            SkBidiIterator::Position pos16 = 0;
+            while (pos16 <= iter->getLength()) {
+                auto level = iter->getLevelAt(pos16);
+                if (pos16 == 0) {
+                    currentLevel = level;
+                } else if (level != currentLevel) {
+                    callback(pos16, start16 - utf16, currentLevel);
+                    currentLevel = level;
+                }
+                if (start16 == end16) {
+                    break;
+                }
+                SkUnichar u = SkUTF::NextUTF16(&start16, end16);
+                pos16 += SkUTF::ToUTF16(u);
+            }
+        }
+
+        template <typename Callback>
+        void forEachBreak(const char16_t utf16[], int utf16Units, SkUnicode::BreakType type, Callback&& callback) {
+            auto iter = makeBreakIterator(type);
+            iter->setText(utf16, utf16Units);
+            auto pos = iter->first();
+            do {
+                callback(pos, iter->status());
+                pos = iter->next();
+            } while (!iter->isDone());
+        }
+
+        virtual void reorderVisual(const BidiLevel runLevels[], int levelsCount, int32_t logicalFromVisual[]) = 0;
+};
+
+namespace sknonstd {
+template <> struct is_bitmask_enum<SkUnicode::CodeUnitFlags> : std::true_type {};
+}  // namespace sknonstd
+
+#endif // SkUnicode_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h
new file mode 100644
index 00000000..6e5781dd
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_client_DEFINED
+#define SkUnicode_client_DEFINED
+
+#include "include/core/SkSpan.h"
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <memory>
+#include <vector>
+
+namespace SkUnicodes::Client {
+SKUNICODE_API sk_sp<SkUnicode> Make(
+                SkSpan<char> text,
+                std::vector<SkUnicode::Position> words,
+                std::vector<SkUnicode::Position> graphemeBreaks,
+                std::vector<SkUnicode::LineBreakBefore> lineBreaks);
+}
+
+#endif // SkUnicode_client_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h
new file mode 100644
index 00000000..d389c8d6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_icu_DEFINED
+#define SkUnicode_icu_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/skunicode/include/SkUnicode.h"
+
+namespace SkUnicodes::ICU {
+SKUNICODE_API sk_sp<SkUnicode> Make();
+}
+
+#endif //SkUnicode_icu_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h
new file mode 100644
index 00000000..222a448e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_icu4x_DEFINED
+#define SkUnicode_icu4x_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <memory>
+
+namespace SkUnicodes::ICU4X {
+SKUNICODE_API sk_sp<SkUnicode> Make();
+}
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h
new file mode 100644
index 00000000..9bb4c72a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_libgrapheme_DEFINED
+#define SkUnicode_libgrapheme_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <memory>
+
+namespace SkUnicodes::Libgrapheme {
+SKUNICODE_API sk_sp<SkUnicode> Make();
+}
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/skunicode.gni b/Source/ThirdParty/skia/modules/skunicode/skunicode.gni
new file mode 100644
index 00000000..8e854fd4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/skunicode.gni
@@ -0,0 +1,73 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/skunicode/include/BUILD.bazel
+#   //modules/skunicode/src/BUILD.bazel
+#   //modules/skunicode/tests/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# Generated by Bazel rule //modules/skunicode/include:hdrs
+skia_unicode_public = [
+  "$_modules/skunicode/include/SkUnicode.h",
+  "$_modules/skunicode/include/SkUnicode_client.h",
+  "$_modules/skunicode/include/SkUnicode_icu.h",
+  "$_modules/skunicode/include/SkUnicode_icu4x.h",
+  "$_modules/skunicode/include/SkUnicode_libgrapheme.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:srcs
+skia_unicode_sources = [
+  "$_modules/skunicode/src/SkUnicode.cpp",
+  "$_modules/skunicode/src/SkUnicode_hardcoded.cpp",
+  "$_modules/skunicode/src/SkUnicode_hardcoded.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:icu_srcs
+skia_unicode_icu_sources = [
+  "$_modules/skunicode/src/SkUnicode_icu.cpp",
+  "$_modules/skunicode/src/SkUnicode_icupriv.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:icu_bidi_srcs
+skia_unicode_icu_bidi_sources = [
+  "$_modules/skunicode/src/SkUnicode_icu_bidi.cpp",
+  "$_modules/skunicode/src/SkUnicode_icu_bidi.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:bidi_full_srcs
+skia_unicode_bidi_full_sources = [
+  "$_modules/skunicode/src/SkBidiFactory_icu_full.cpp",
+  "$_modules/skunicode/src/SkBidiFactory_icu_full.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:bidi_subset_srcs
+skia_unicode_bidi_subset_sources = [
+  "$_modules/skunicode/src/SkBidiFactory_icu_subset.cpp",
+  "$_modules/skunicode/src/SkBidiFactory_icu_subset.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:icu4x_srcs
+skia_unicode_icu4x_sources = [ "$_modules/skunicode/src/SkUnicode_icu4x.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:client_srcs
+skia_unicode_client_icu_sources =
+    [ "$_modules/skunicode/src/SkUnicode_client.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:builtin_srcs
+skia_unicode_builtin_icu_sources =
+    [ "$_modules/skunicode/src/SkUnicode_icu_builtin.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:runtime_srcs
+skia_unicode_runtime_icu_sources =
+    [ "$_modules/skunicode/src/SkUnicode_icu_runtime.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:libgrapheme_srcs
+skia_unicode_libgrapheme_sources =
+    [ "$_modules/skunicode/src/SkUnicode_libgrapheme.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/tests:tests
+skia_unicode_tests = [ "$_modules/skunicode/tests/SkUnicodeTest.cpp" ]
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel
new file mode 100644
index 00000000..dd3144a1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel
@@ -0,0 +1,103 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+# In own group for export to //modules/skunicode/skunicode.gni:skia_unicode_builtin_icu_sources.
+skia_filegroup(
+    name = "builtin_srcs",
+    srcs = ["SkUnicode_icu_builtin.cpp"],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+# In own group for export to //modules/skunicode/skunicode.gni:skia_unicode_runtime_icu_sources.
+skia_filegroup(
+    name = "runtime_srcs",
+    srcs = ["SkUnicode_icu_runtime.cpp"],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+# In own group for export to //modules/skunicode/skunicode.gni:skia_unicode_common_icu_sources.
+skia_filegroup(
+    name = "srcs",
+    srcs = [
+        "SkUnicode.cpp",
+        "SkUnicode_hardcoded.cpp",
+        "SkUnicode_hardcoded.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_bidi_srcs",
+    srcs = [
+        "SkUnicode_icu_bidi.cpp",
+        "SkUnicode_icu_bidi.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "bidi_full_srcs",
+    srcs = [
+        "SkBidiFactory_icu_full.cpp",
+        "SkBidiFactory_icu_full.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "bidi_subset_srcs",
+    srcs = [
+        "SkBidiFactory_icu_subset.cpp",
+        "SkBidiFactory_icu_subset.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_srcs",
+    srcs = [
+        "SkUnicode_icu.cpp",
+        "SkUnicode_icupriv.h",
+        ":builtin_srcs",
+        # TODO(kjlubick, bungeman): add support for SkUnicode_icu_runtime.cpp
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_core_srcs",
+    srcs = [
+        "SkUnicode_icu.cpp",
+        "SkUnicode_icupriv.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "client_srcs",
+    srcs = [
+        "SkUnicode_client.cpp",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "libgrapheme_srcs",
+    srcs = [
+        "SkUnicode_libgrapheme.cpp",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu4x_srcs",
+    srcs = [
+        "SkUnicode_icu4x.cpp",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp
new file mode 100644
index 00000000..cc0abeb4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skunicode/src/SkBidiFactory_icu_full.h"
+
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+const char* SkBidiICUFactory::errorName(UErrorCode status) const {
+    return SkGetICULib()->f_u_errorName(status);
+}
+
+SkBidiFactory::BidiCloseCallback SkBidiICUFactory::bidi_close_callback() const {
+    return SkGetICULib()->f_ubidi_close;
+}
+
+UBiDiDirection SkBidiICUFactory::bidi_getDirection(const UBiDi* bidi) const {
+    return SkGetICULib()->f_ubidi_getDirection(bidi);
+}
+
+SkBidiIterator::Position SkBidiICUFactory::bidi_getLength(const UBiDi* bidi) const {
+    return SkGetICULib()->f_ubidi_getLength(bidi);
+}
+
+SkBidiIterator::Level SkBidiICUFactory::bidi_getLevelAt(const UBiDi* bidi, int pos) const {
+    return SkGetICULib()->f_ubidi_getLevelAt(bidi, pos);
+}
+
+UBiDi* SkBidiICUFactory::bidi_openSized(int32_t maxLength,
+                                        int32_t maxRunCount,
+                                        UErrorCode* pErrorCode) const {
+    return SkGetICULib()->f_ubidi_openSized(maxLength, maxRunCount, pErrorCode);
+}
+
+void SkBidiICUFactory::bidi_setPara(UBiDi* bidi,
+                                    const UChar* text,
+                                    int32_t length,
+                                    UBiDiLevel paraLevel,
+                                    UBiDiLevel* embeddingLevels,
+                                    UErrorCode* status) const {
+    return SkGetICULib()->f_ubidi_setPara(bidi, text, length, paraLevel, embeddingLevels, status);
+}
+
+void SkBidiICUFactory::bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                                          int levelsCount,
+                                          int32_t logicalFromVisual[]) const {
+    SkGetICULib()->f_ubidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h
new file mode 100644
index 00000000..74eeeb06
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkBidiICUFactory_DEFINED
+#define SkBidiICUFactory_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+
+class SkBidiICUFactory : public SkBidiFactory {
+public:
+    const char* errorName(UErrorCode status) const override;
+    SkBidiFactory::BidiCloseCallback bidi_close_callback() const override;
+    UBiDiDirection bidi_getDirection(const UBiDi* bidi) const override;
+    SkBidiIterator::Position bidi_getLength(const UBiDi* bidi) const override;
+    SkBidiIterator::Level bidi_getLevelAt(const UBiDi* bidi, int pos) const override;
+    UBiDi* bidi_openSized(int32_t maxLength,
+                          int32_t maxRunCount,
+                          UErrorCode* pErrorCode) const override;
+    void bidi_setPara(UBiDi* bidi,
+                      const UChar* text,
+                      int32_t length,
+                      UBiDiLevel paraLevel,
+                      UBiDiLevel* embeddingLevels,
+                      UErrorCode* status) const override;
+    void bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                            int levelsCount,
+                            int32_t logicalFromVisual[]) const override;
+};
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp
new file mode 100644
index 00000000..71399ba9
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skunicode/src/SkBidiFactory_icu_subset.h"
+
+#include <unicode/umachine.h>
+
+const char* SkBidiSubsetFactory::errorName(UErrorCode status) const {
+    return u_errorName_skia(status);
+}
+
+SkBidiFactory::BidiCloseCallback SkBidiSubsetFactory::bidi_close_callback() const {
+    return ubidi_close_skia;
+}
+
+UBiDiDirection SkBidiSubsetFactory::bidi_getDirection(const UBiDi* bidi) const {
+    return ubidi_getDirection_skia(bidi);
+}
+
+SkBidiIterator::Position SkBidiSubsetFactory::bidi_getLength(const UBiDi* bidi) const {
+    return ubidi_getLength_skia(bidi);
+}
+
+SkBidiIterator::Level SkBidiSubsetFactory::bidi_getLevelAt(const UBiDi* bidi, int pos) const {
+    return ubidi_getLevelAt_skia(bidi, pos);
+}
+
+UBiDi* SkBidiSubsetFactory::bidi_openSized(int32_t maxLength,
+                                           int32_t maxRunCount,
+                                           UErrorCode* pErrorCode) const {
+    return ubidi_openSized_skia(maxLength, maxRunCount, pErrorCode);
+}
+
+void SkBidiSubsetFactory::bidi_setPara(UBiDi* bidi,
+                                       const UChar* text,
+                                       int32_t length,
+                                       UBiDiLevel paraLevel,
+                                       UBiDiLevel* embeddingLevels,
+                                       UErrorCode* status) const {
+    return ubidi_setPara_skia(bidi, text, length, paraLevel, embeddingLevels, status);
+}
+
+void SkBidiSubsetFactory::bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                                             int levelsCount,
+                                             int32_t logicalFromVisual[]) const {
+    ubidi_reorderVisual_skia(runLevels, levelsCount, logicalFromVisual);
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h
new file mode 100644
index 00000000..583b90ef
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkBidiSubsetFactory_DEFINED
+#define SkBidiSubsetFactory_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+
+class SkBidiSubsetFactory : public SkBidiFactory {
+public:
+    const char* errorName(UErrorCode status) const override;
+    SkBidiFactory::BidiCloseCallback bidi_close_callback() const override;
+    UBiDiDirection bidi_getDirection(const UBiDi* bidi) const override;
+    SkBidiIterator::Position bidi_getLength(const UBiDi* bidi) const override;
+    SkBidiIterator::Level bidi_getLevelAt(const UBiDi* bidi, int pos) const override;
+    UBiDi* bidi_openSized(int32_t maxLength,
+                          int32_t maxRunCount,
+                          UErrorCode* pErrorCode) const override;
+    void bidi_setPara(UBiDi* bidi,
+                      const UChar* text,
+                      int32_t length,
+                      UBiDiLevel paraLevel,
+                      UBiDiLevel* embeddingLevels,
+                      UErrorCode* status) const override;
+    void bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                            int levelsCount,
+                            int32_t logicalFromVisual[]) const override;
+};
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp
new file mode 100644
index 00000000..e027e319
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkTemplates.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkBitmaskEnum.h"
+
+using namespace skia_private;
+
+SkString SkUnicode::convertUtf16ToUtf8(const char16_t* utf16, int utf16Units) {
+
+    int utf8Units = SkUTF::UTF16ToUTF8(nullptr, 0, (uint16_t*)utf16, utf16Units);
+    if (utf8Units < 0) {
+        SkDEBUGF("Convert error: Invalid utf16 input");
+        return SkString();
+    }
+    AutoTArray<char> utf8(utf8Units);
+    SkDEBUGCODE(int dstLen =) SkUTF::UTF16ToUTF8(utf8.data(), utf8Units, (uint16_t*)utf16, utf16Units);
+    SkASSERT(dstLen == utf8Units);
+
+    return SkString(utf8.data(), utf8Units);
+}
+
+SkString SkUnicode::convertUtf16ToUtf8(const std::u16string& utf16) {
+    return convertUtf16ToUtf8(utf16.c_str(), utf16.size());
+}
+
+std::u16string SkUnicode::convertUtf8ToUtf16(const char* utf8, int utf8Units) {
+
+    int utf16Units = SkUTF::UTF8ToUTF16(nullptr, 0, utf8, utf8Units);
+    if (utf16Units < 0) {
+        SkDEBUGF("Convert error: Invalid utf8 input");
+        return std::u16string();
+    }
+
+    AutoTArray<uint16_t> utf16(utf16Units);
+    SkDEBUGCODE(int dstLen =) SkUTF::UTF8ToUTF16(utf16.data(), utf16Units, utf8, utf8Units);
+    SkASSERT(dstLen == utf16Units);
+
+    return std::u16string((char16_t *)utf16.data(), utf16Units);
+}
+
+std::u16string SkUnicode::convertUtf8ToUtf16(const SkString& utf8) {
+    return convertUtf8ToUtf16(utf8.c_str(), utf8.size());
+}
+
+bool SkUnicode::hasTabulationFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kTabulation) == SkUnicode::kTabulation;
+}
+
+bool SkUnicode::hasHardLineBreakFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kHardLineBreakBefore) == SkUnicode::kHardLineBreakBefore;
+}
+
+bool SkUnicode::hasSoftLineBreakFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kSoftLineBreakBefore) == SkUnicode::kSoftLineBreakBefore;
+}
+
+bool SkUnicode::hasGraphemeStartFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kGraphemeStart) == SkUnicode::kGraphemeStart;
+}
+
+bool SkUnicode::hasControlFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kControl) == SkUnicode::kControl;
+}
+
+bool SkUnicode::hasPartOfWhiteSpaceBreakFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kPartOfWhiteSpaceBreak) == SkUnicode::kPartOfWhiteSpaceBreak;
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp
new file mode 100644
index 00000000..5b33d7ae
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp
@@ -0,0 +1,263 @@
+/*
+* Copyright 2022 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+#include "modules/skunicode/include/SkUnicode_client.h"
+
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkBidiFactory_icu_subset.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "src/base/SkUTF.h"
+
+#include <algorithm>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+#include <array>
+#include <unicode/ubidi.h>
+#include <unicode/ubrk.h>
+#include <unicode/uchar.h>
+#include <unicode/uloc.h>
+#include <unicode/uscript.h>
+#include <unicode/ustring.h>
+#include <unicode/utext.h>
+#include <unicode/utypes.h>
+
+using namespace skia_private;
+
+class SkUnicode_client : public SkUnicodeHardCodedCharProperties {
+public:
+    struct Data {
+        SkSpan<const char> fText8;
+        SkSpan<const char16_t> fText16;
+        std::vector<Position> fWords;
+        std::vector<SkUnicode::Position> fGraphemeBreaks;
+        std::vector<SkUnicode::LineBreakBefore> fLineBreaks;
+        Data(SkSpan<char> text,
+             std::vector<SkUnicode::Position> words,
+             std::vector<SkUnicode::Position> graphemeBreaks,
+             std::vector<SkUnicode::LineBreakBefore> lineBreaks)
+            : fText8(text)
+            , fText16(SkSpan<const char16_t>(nullptr, 0))
+            , fWords(std::move(words))
+            , fGraphemeBreaks(std::move(graphemeBreaks))
+            , fLineBreaks(std::move(lineBreaks)) {
+        }
+
+        void reset() {
+            fText8 = SkSpan<const char>(nullptr, 0);
+            fText16 = SkSpan<const char16_t>(nullptr, 0);
+            fGraphemeBreaks.clear();
+            fLineBreaks.clear();
+        }
+    };
+    SkUnicode_client() = delete;
+    SkUnicode_client(SkSpan<char> text,
+                     std::vector<SkUnicode::Position> words,
+                     std::vector<SkUnicode::Position> graphemeBreaks,
+                     std::vector<SkUnicode::LineBreakBefore> lineBreaks)
+            : fData(std::make_shared<Data>(text,
+                                           std::move(words),
+                                           std::move(graphemeBreaks),
+                                           std::move(lineBreaks))) { }
+
+    ~SkUnicode_client() override = default;
+
+    void reset() { fData->reset(); }
+    // For SkShaper
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType breakType) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType breakType) override;
+    // For SkParagraph
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+        return fBidiFact->ExtractBidi(utf8, utf8Units, dir, results);
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        SkDEBUGF("Method 'getUtf8Words' is not implemented\n");
+        return false;
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkDEBUGF("Method 'getSentences' is not implemented\n");
+        return false;
+    }
+
+    bool computeCodeUnitFlags(char utf8[],
+                              int utf8Units,
+                              bool replaceTabs,
+                              TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+        for (auto& lineBreak : fData->fLineBreaks) {
+            (*results)[lineBreak.pos] |=
+                lineBreak.breakType == LineBreakType::kHardLineBreak
+                    ? CodeUnitFlags::kHardLineBreakBefore
+                    : CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        for (auto& grapheme : fData->fGraphemeBreaks) {
+            (*results)[grapheme] |= CodeUnitFlags::kGraphemeStart;
+        }
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && this->isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                if (this->isSpace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (this->isWhitespace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf16Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+        for (auto& lineBreak : fData->fLineBreaks) {
+            (*results)[lineBreak.pos] |=
+                lineBreak.breakType == LineBreakType::kHardLineBreak
+                    ? CodeUnitFlags::kHardLineBreakBefore
+                    : CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        for (auto& grapheme : fData->fGraphemeBreaks) {
+            (*results)[grapheme] |= CodeUnitFlags::kGraphemeStart;
+        }
+        return true;
+    }
+
+    bool getWords(const char utf8[], int utf8Units, const char* locale, std::vector<Position>* results) override {
+        *results = fData->fWords;
+        return true;
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return this->toUpper(str, nullptr);
+    }
+
+    SkString toUpper(const SkString& str, const char* locale) override {
+        return SkString(fData->fText8.data(), fData->fText8.size());
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+        fBidiFact->bidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+    }
+private:
+    friend class SkBreakIterator_client;
+
+    std::shared_ptr<Data> fData;
+    sk_sp<SkBidiFactory> fBidiFact = sk_make_sp<SkBidiSubsetFactory>();
+};
+
+class SkBreakIterator_client: public SkBreakIterator {
+    std::shared_ptr<SkUnicode_client::Data> fData;
+    Position fLastResult;
+    Position fStart;
+    Position fEnd;
+public:
+    explicit SkBreakIterator_client(std::shared_ptr<SkUnicode_client::Data> data) : fData(data) { }
+    Position first() override
+      { return fData->fLineBreaks[fStart + (fLastResult = 0)].pos; }
+    Position current() override
+      { return fData->fLineBreaks[fStart + fLastResult].pos; }
+    Position next() override
+      { return fData->fLineBreaks[fStart + fLastResult + 1].pos; }
+    Status status() override {
+        return fData->fLineBreaks[fStart + fLastResult].breakType ==
+                       SkUnicode::LineBreakType::kHardLineBreak
+                       ? SkUnicode::CodeUnitFlags::kHardLineBreakBefore
+                       : SkUnicode::CodeUnitFlags::kSoftLineBreakBefore;
+    }
+    bool isDone() override { return fStart + fLastResult == fEnd; }
+    bool setText(const char utftext8[], int utf8Units) override {
+        SkASSERT(utftext8 >= fData->fText8.data() &&
+                 utf8Units <= SkToS16(fData->fText8.size()));
+        fStart = utftext8 - fData->fText8.data();
+        fEnd = fStart + utf8Units;
+        fLastResult = 0;
+        return true;
+    }
+    bool setText(const char16_t utftext16[], int utf16Units) override {
+        SkASSERT(utftext16 >= fData->fText16.data() &&
+                 utf16Units <= SkToS16(fData->fText16.size()));
+        fStart = utftext16 - fData->fText16.data();
+        fEnd = fStart + utf16Units;
+        fLastResult = 0;
+        return true;
+    }
+};
+std::unique_ptr<SkBidiIterator> SkUnicode_client::makeBidiIterator(const uint16_t text[], int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBidiIterator> SkUnicode_client::makeBidiIterator(const char text[],
+                                                 int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_client::makeBreakIterator(const char locale[],
+                                                   BreakType breakType) {
+    return std::make_unique<SkBreakIterator_client>(fData);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_client::makeBreakIterator(BreakType breakType) {
+    return std::make_unique<SkBreakIterator_client>(fData);
+}
+
+namespace SkUnicodes::Client {
+sk_sp<SkUnicode> Make(
+        SkSpan<char> text,
+        std::vector<SkUnicode::Position> words,
+        std::vector<SkUnicode::Position> graphemeBreaks,
+        std::vector<SkUnicode::LineBreakBefore> lineBreaks) {
+    return sk_make_sp<SkUnicode_client>(text,
+                                        std::move(words),
+                                        std::move(graphemeBreaks),
+                                        std::move(lineBreaks));
+}
+}
+
+
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp
new file mode 100644
index 00000000..6cabd3f9
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2023 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/private/base/SkDebug.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include <algorithm>
+#include <array>
+#include <utility>
+
+bool SkUnicodeHardCodedCharProperties::isControl(SkUnichar utf8) {
+    return (utf8 < ' ') || (utf8 >= 0x7f && utf8 <= 0x9f) ||
+           (utf8 >= 0x200D && utf8 <= 0x200F) ||
+           (utf8 >= 0x202A && utf8 <= 0x202E);
+}
+
+bool SkUnicodeHardCodedCharProperties::isWhitespace(SkUnichar unichar) {
+    static constexpr std::array<SkUnichar, 21> whitespaces {
+            0x0009, // character tabulation
+            0x000A, // line feed
+            0x000B, // line tabulation
+            0x000C, // form feed
+            0x000D, // carriage return
+            0x0020, // space
+          //0x0085, // next line
+          //0x00A0, // no-break space
+            0x1680, // ogham space mark
+            0x2000, // en quad
+            0x2001, // em quad
+            0x2002, // en space
+            0x2003, // em space
+            0x2004, // three-per-em space
+            0x2005, // four-per-em space
+            0x2006, // six-per-em space
+          //0x2007, // figure space
+            0x2008, // punctuation space
+            0x2009, // thin space
+            0x200A, // hair space
+            0x2028, // line separator
+            0x2029, // paragraph separator
+          //0x202F, // narrow no-break space
+            0x205F, // medium mathematical space
+            0x3000};// ideographic space
+    return std::find(whitespaces.begin(), whitespaces.end(), unichar) != whitespaces.end();
+}
+
+bool SkUnicodeHardCodedCharProperties::isSpace(SkUnichar unichar) {
+    static constexpr std::array<SkUnichar, 25> spaces {
+            0x0009, // character tabulation
+            0x000A, // line feed
+            0x000B, // line tabulation
+            0x000C, // form feed
+            0x000D, // carriage return
+            0x0020, // space
+            0x0085, // next line
+            0x00A0, // no-break space
+            0x1680, // ogham space mark
+            0x2000, // en quad
+            0x2001, // em quad
+            0x2002, // en space
+            0x2003, // em space
+            0x2004, // three-per-em space
+            0x2005, // four-per-em space
+            0x2006, // six-per-em space
+            0x2007, // figure space
+            0x2008, // punctuation space
+            0x2009, // thin space
+            0x200A, // hair space
+            0x2028, // line separator
+            0x2029, // paragraph separator
+            0x202F, // narrow no-break space
+            0x205F, // medium mathematical space
+            0x3000}; // ideographic space
+    return std::find(spaces.begin(), spaces.end(), unichar) != spaces.end();
+}
+
+bool SkUnicodeHardCodedCharProperties::isTabulation(SkUnichar utf8) {
+    return utf8 == '\t';
+}
+
+bool SkUnicodeHardCodedCharProperties::isHardBreak(SkUnichar utf8) {
+    return utf8 == '\n' || utf8 == u'\u2028';
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmoji(SkUnichar unichar) {
+    SkDEBUGFAIL("isEmoji Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmojiComponent(SkUnichar utf8)  {
+    SkDEBUGFAIL("isEmojiComponent Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmojiModifier(SkUnichar utf8)  {
+    SkDEBUGFAIL("isEmojiModifier Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmojiModifierBase(SkUnichar utf8) {
+    SkDEBUGFAIL("isEmojiModifierBase Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isRegionalIndicator(SkUnichar unichar) {
+    SkDEBUGFAIL("isRegionalIndicator Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isIdeographic(SkUnichar unichar) {
+    static constexpr std::array<std::pair<SkUnichar, SkUnichar>, 8> ranges {{
+          {4352,   4607}, // Hangul Jamo
+          {11904, 42191}, // CJK_Radicals
+          {43072, 43135}, // Phags_Pa
+          {44032, 55215}, // Hangul_Syllables
+          {63744, 64255}, // CJK_Compatibility_Ideographs
+          {65072, 65103}, // CJK_Compatibility_Forms
+          {65381, 65500}, // Katakana_Hangul_Halfwidth
+          {131072, 196607}// Supplementary_Ideographic_Plane
+    }};
+    for (auto range : ranges) {
+        if (range.first <= unichar && range.second > unichar) {
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h
new file mode 100644
index 00000000..39e4cd3d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2023 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_hardcoded_DEFINED
+#define SkUnicode_hardcoded_DEFINED
+
+#include "include/core/SkTypes.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkUTF.h"
+
+class SKUNICODE_API SkUnicodeHardCodedCharProperties : public SkUnicode {
+public:
+    bool isControl(SkUnichar utf8) override;
+    bool isWhitespace(SkUnichar utf8) override;
+    bool isSpace(SkUnichar utf8) override;
+    bool isTabulation(SkUnichar utf8) override;
+    bool isHardBreak(SkUnichar utf8) override;
+    bool isEmoji(SkUnichar utf8) override;
+    bool isEmojiComponent(SkUnichar utf8) override;
+    bool isEmojiModifierBase(SkUnichar utf8) override;
+    bool isEmojiModifier(SkUnichar utf8) override;
+    bool isRegionalIndicator(SkUnichar utf8) override;
+    bool isIdeographic(SkUnichar utf8) override;
+};
+
+#endif // SkUnicode_hardcoded_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp
new file mode 100644
index 00000000..b8ff31d2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp
@@ -0,0 +1,700 @@
+/*
+* Copyright 2020 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+#include "modules/skunicode/include/SkUnicode_icu.h"
+
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkMutex.h"
+#include "include/private/base/SkSpan_impl.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTemplates.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkBidiFactory_icu_full.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "src/base/SkUTF.h"
+#include "src/core/SkChecksum.h"
+#include "src/core/SkTHash.h"
+
+#include <unicode/ubrk.h>
+#include <unicode/uchar.h>
+#include <unicode/uloc.h>
+#include <unicode/umachine.h>
+#include <unicode/utext.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+#include <cstring>
+#include <functional>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#if defined(SK_USING_THIRD_PARTY_ICU) && defined(SK_BUILD_FOR_WIN)
+#include "SkLoadICU.h"
+#include "include/private/base/SkOnce.h"
+#endif
+
+using namespace skia_private;
+
+const SkICULib* SkGetICULib() {
+    static const auto gICU = SkLoadICULib();
+    return gICU.get();
+}
+
+// sk_* wrappers for ICU funcs
+#define SKICU_FUNC(funcname)                                                                \
+    template <typename... Args>                                                             \
+    auto sk_##funcname(Args&&... args) -> decltype(funcname(std::forward<Args>(args)...)) { \
+        return SkGetICULib()->f_##funcname(std::forward<Args>(args)...);                    \
+    }                                                                                       \
+
+SKICU_EMIT_FUNCS
+#undef SKICU_FUNC
+
+static inline UBreakIterator* sk_ubrk_clone(const UBreakIterator* bi, UErrorCode* status) {
+    const auto* icu = SkGetICULib();
+    SkASSERT(icu->f_ubrk_clone_ || icu->f_ubrk_safeClone_);
+    return icu->f_ubrk_clone_
+        ? icu->f_ubrk_clone_(bi, status)
+        : icu->f_ubrk_safeClone_(bi, nullptr, nullptr, status);
+}
+
+static UText* utext_close_wrapper(UText* ut) {
+    return sk_utext_close(ut);
+}
+static void ubrk_close_wrapper(UBreakIterator* bi) {
+    sk_ubrk_close(bi);
+}
+
+using ICUUText = std::unique_ptr<UText, SkFunctionObject<utext_close_wrapper>>;
+using ICUBreakIterator = std::unique_ptr<UBreakIterator, SkFunctionObject<ubrk_close_wrapper>>;
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+static UBreakIteratorType convertType(SkUnicode::BreakType type) {
+    switch (type) {
+        case SkUnicode::BreakType::kLines: return UBRK_LINE;
+        case SkUnicode::BreakType::kGraphemes: return UBRK_CHARACTER;
+        case SkUnicode::BreakType::kWords: return UBRK_WORD;
+        case SkUnicode::BreakType::kSentences:
+            return UBRK_SENTENCE;
+        default:
+            return UBRK_CHARACTER;
+    }
+}
+
+class SkBreakIterator_icu : public SkBreakIterator {
+    ICUBreakIterator fBreakIterator;
+    Position fLastResult;
+ public:
+    explicit SkBreakIterator_icu(ICUBreakIterator iter)
+            : fBreakIterator(std::move(iter))
+            , fLastResult(0) {}
+    Position first() override { return fLastResult = sk_ubrk_first(fBreakIterator.get()); }
+    Position current() override { return fLastResult = sk_ubrk_current(fBreakIterator.get()); }
+    Position next() override { return fLastResult = sk_ubrk_next(fBreakIterator.get()); }
+    Status status() override { return sk_ubrk_getRuleStatus(fBreakIterator.get()); }
+    bool isDone() override { return fLastResult == UBRK_DONE; }
+
+    bool setText(const char utftext8[], int utf8Units) override {
+        UErrorCode status = U_ZERO_ERROR;
+        ICUUText text(sk_utext_openUTF8(nullptr, &utftext8[0], utf8Units, &status));
+
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(text);
+        sk_ubrk_setUText(fBreakIterator.get(), text.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        fLastResult = 0;
+        return true;
+    }
+    bool setText(const char16_t utftext16[], int utf16Units) override {
+        UErrorCode status = U_ZERO_ERROR;
+        ICUUText text(sk_utext_openUChars(nullptr, reinterpret_cast<const UChar*>(&utftext16[0]),
+                                          utf16Units, &status));
+
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(text);
+        sk_ubrk_setUText(fBreakIterator.get(), text.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        fLastResult = 0;
+        return true;
+    }
+};
+
+class SkIcuBreakIteratorCache final {
+    struct Request final {
+        Request(SkUnicode::BreakType type, const char* icuLocale)
+            : fType(type)
+            , fIcuLocale(icuLocale)
+            , hash(SkGoodHash()(type) ^ SkGoodHash()(fIcuLocale))
+        {}
+        const SkUnicode::BreakType fType;
+        const SkString fIcuLocale;
+        const uint32_t hash;
+        struct Hash {
+            uint32_t operator()(const Request& key) const {
+                return key.hash;
+            }
+        };
+        bool operator==(const Request& that) const {
+            return this->fType == that.fType && this->fIcuLocale == that.fIcuLocale;
+        }
+    };
+    /* Every holder of this class is referencing the same (logical) break iterator.
+     * Due to caching, the actual break iterator may come and go.
+     */
+    class BreakIteratorRef final {
+    public:
+        BreakIteratorRef(ICUBreakIterator iter) : breakIterator(iter.release()), fRefCnt(1) {
+            ++Instances;
+        }
+        BreakIteratorRef(SkRefCntBase&&) = delete;
+        BreakIteratorRef(const SkRefCntBase&) = delete;
+        BreakIteratorRef& operator=(SkRefCntBase&&) = delete;
+        BreakIteratorRef& operator=(const SkRefCntBase&) = delete;
+        ~BreakIteratorRef() {
+            if (breakIterator) {
+                ubrk_close_wrapper(breakIterator);
+            }
+        }
+
+        void ref() const {
+            SkASSERT(fRefCnt > 0);
+            ++fRefCnt;
+        }
+        void unref() const {
+            SkASSERT(fRefCnt > 0);
+            if (1 == fRefCnt--) {
+                delete this;
+                --Instances;
+            }
+        }
+
+        UBreakIterator* breakIterator;
+        static int32_t GetInstanceCount() { return Instances; }
+    private:
+        mutable int32_t fRefCnt;
+        static int32_t Instances;
+    };
+    THashMap<Request, sk_sp<BreakIteratorRef>, Request::Hash> fRequestCache;
+    SkMutex fCacheMutex;
+
+    void purgeIfNeeded() {
+        // If there are too many requests remove some (oldest first?)
+        // This may free some break iterators
+        if (fRequestCache.count() > 100) {
+            // remove the oldest requests
+            fRequestCache.reset();
+        }
+        // If there are still too many break iterators remove some (oldest first?)
+        if (BreakIteratorRef::GetInstanceCount() > 4) {
+            // delete the oldest break iterators and set the references to nullptr
+            for (auto&& [key, value] : fRequestCache) {
+                if (value->breakIterator) {
+                    sk_ubrk_close(value->breakIterator);
+                    value->breakIterator = nullptr;
+                }
+            }
+        }
+    }
+
+ public:
+    static SkIcuBreakIteratorCache& get() {
+        static SkIcuBreakIteratorCache instance;
+        return instance;
+    }
+
+    ICUBreakIterator makeBreakIterator(SkUnicode::BreakType type, const char* bcp47) {
+        SkAutoMutexExclusive lock(fCacheMutex);
+        UErrorCode status = U_ZERO_ERROR;
+
+        // Get ICU locale for BCP47 langtag
+        char localeIDStorage[ULOC_FULLNAME_CAPACITY];
+        const char* localeID = nullptr;
+        if (bcp47) {
+            sk_uloc_forLanguageTag(bcp47, localeIDStorage, ULOC_FULLNAME_CAPACITY, nullptr, &status);
+            if (U_FAILURE(status)) {
+                SkDEBUGF("Break error could not get language tag: %s", sk_u_errorName(status));
+            } else if (localeIDStorage[0]) {
+                localeID = localeIDStorage;
+            }
+        }
+        if (!localeID) {
+            localeID = sk_uloc_getDefault();
+        }
+
+        auto make = [](const Request& request) -> UBreakIterator* {
+            UErrorCode status = U_ZERO_ERROR;
+            UBreakIterator* bi = sk_ubrk_open(convertType(request.fType),
+                                              request.fIcuLocale.c_str(),
+                                              nullptr, 0, &status);
+            if (U_FAILURE(status)) {
+                SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            }
+            return bi;
+        };
+
+        auto clone = [](const UBreakIterator* existing) -> ICUBreakIterator {
+            if (!existing) {
+                return nullptr;
+            }
+
+            UErrorCode status = U_ZERO_ERROR;
+            ICUBreakIterator clone(sk_ubrk_clone(existing, &status));
+            if (U_FAILURE(status)) {
+                SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            }
+            return clone;
+        };
+
+        Request request(type, localeID);
+
+        // See if this request is already in the cache
+        const sk_sp<BreakIteratorRef>* ref = fRequestCache.find(request);
+        if (ref) {
+            // See if the breakIterator needs to be re-created
+            if (!(*ref)->breakIterator) {
+                (*ref)->breakIterator = make(request);
+            }
+            return clone((*ref)->breakIterator);
+        }
+
+        // This request was not in the cache, create an iterator.
+        ICUBreakIterator newIter(make(request));
+        if (!newIter) {
+            return nullptr;
+        }
+
+        sk_sp<BreakIteratorRef> newRef;
+
+        // Check if the new iterator is a duplicate
+        // Android doesn't expose ubrk_getLocaleByType so there is no means of de-duplicating.
+        // ubrk_getAvailable seems like it should work, but the implementation is just every locale.
+        if (SkGetICULib()->f_ubrk_getLocaleByType) {
+            const char* actualLocale = SkGetICULib()->f_ubrk_getLocaleByType(
+                                           newIter.get(), ULOC_ACTUAL_LOCALE, &status);
+            // Android doesn't expose ubrk_getLocaleByType so a wrapper may return an error.
+            if (!U_FAILURE(status)) {
+                if (!actualLocale) {
+                    actualLocale = "";
+                }
+                // If the actual locale is the same as the requested locale we know there is no entry.
+                if (strcmp(actualLocale, localeID) != 0) {
+                    Request actualRequest(type, actualLocale);
+                    const sk_sp<BreakIteratorRef>* actualRef = fRequestCache.find(actualRequest);
+                    if (actualRef) {
+                        if (!(*actualRef)->breakIterator) {
+                            (*actualRef)->breakIterator = newIter.release();
+                        }
+                        actualRef = fRequestCache.set(request, *actualRef);
+                        return clone((*actualRef)->breakIterator);
+                    } else {
+                        this->purgeIfNeeded();
+                        newRef = sk_make_sp<BreakIteratorRef>(std::move(newIter));
+                        fRequestCache.set(actualRequest, newRef);
+                    }
+                }
+            }
+        }
+
+        if (!newRef) {
+            this->purgeIfNeeded();
+            newRef = sk_make_sp<BreakIteratorRef>(std::move(newIter));
+        }
+        fRequestCache.set(request, newRef);
+
+        return clone(newRef->breakIterator);
+    }
+};
+/*static*/ int32_t SkIcuBreakIteratorCache::BreakIteratorRef::Instances{0};
+
+class SkUnicode_icu : public SkUnicode {
+
+    static bool extractWords(uint16_t utf16[], int utf16Units, const char* locale,
+                             std::vector<Position>* words) {
+
+        UErrorCode status = U_ZERO_ERROR;
+
+        const BreakType type = BreakType::kWords;
+        ICUBreakIterator iterator = SkIcuBreakIteratorCache::get().makeBreakIterator(type, locale);
+        if (!iterator) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(iterator);
+
+        ICUUText utf16UText(sk_utext_openUChars(nullptr, (UChar*)utf16, utf16Units, &status));
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+
+        sk_ubrk_setUText(iterator.get(), utf16UText.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+
+        // Get the words
+        int32_t pos = sk_ubrk_first(iterator.get());
+        while (pos != UBRK_DONE) {
+            words->emplace_back(pos);
+            pos = sk_ubrk_next(iterator.get());
+        }
+
+        return true;
+    }
+
+    static bool extractPositions(const char utf8[], int utf8Units,
+                                 BreakType type, const char* locale,
+                                 const std::function<void(int, int)>& setBreak) {
+
+        UErrorCode status = U_ZERO_ERROR;
+        ICUUText text(sk_utext_openUTF8(nullptr, &utf8[0], utf8Units, &status));
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(text);
+
+        ICUBreakIterator iterator = SkIcuBreakIteratorCache::get().makeBreakIterator(type, locale);
+        if (!iterator) {
+            return false;
+        }
+
+        sk_ubrk_setUText(iterator.get(), text.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+
+        auto iter = iterator.get();
+        int32_t pos = sk_ubrk_first(iter);
+        while (pos != UBRK_DONE) {
+            int s = type == SkUnicode::BreakType::kLines
+                        ? UBRK_LINE_SOFT
+                        : sk_ubrk_getRuleStatus(iter);
+            setBreak(pos, s);
+            pos = sk_ubrk_next(iter);
+        }
+
+        if (type == SkUnicode::BreakType::kLines) {
+            // This is a workaround for https://bugs.chromium.org/p/skia/issues/detail?id=10715
+            // (ICU line break iterator does not work correctly on Thai text with new lines)
+            // So, we only use the iterator to collect soft line breaks and
+            // scan the text for all hard line breaks ourselves
+            const char* end = utf8 + utf8Units;
+            const char* ch = utf8;
+            while (ch < end) {
+                auto unichar = utf8_next(&ch, end);
+                if (SkUnicode_icu::isHardLineBreak(unichar)) {
+                    setBreak(ch - utf8, UBRK_LINE_HARD);
+                }
+            }
+        }
+        return true;
+    }
+
+    bool isControl(SkUnichar utf8) override {
+        return sk_u_iscntrl(utf8);
+    }
+
+    bool isWhitespace(SkUnichar utf8) override {
+        return sk_u_isWhitespace(utf8);
+    }
+
+    bool isSpace(SkUnichar utf8) override {
+        return sk_u_isspace(utf8);
+    }
+
+    bool isHardBreak(SkUnichar utf8) override {
+        return SkUnicode_icu::isHardLineBreak(utf8);
+    }
+
+    bool isEmoji(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI);
+    }
+
+    bool isEmojiComponent(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI_COMPONENT);
+    }
+
+    bool isEmojiModifierBase(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI_MODIFIER_BASE);
+    }
+
+    bool isEmojiModifier(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI_MODIFIER);
+    }
+
+    bool isRegionalIndicator(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_REGIONAL_INDICATOR);
+    }
+
+    bool isIdeographic(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_IDEOGRAPHIC);
+    }
+
+    bool isTabulation(SkUnichar utf8) override {
+        return utf8 == '\t';
+    }
+
+    static bool isHardLineBreak(SkUnichar utf8) {
+        auto property = sk_u_getIntPropertyValue(utf8, UCHAR_LINE_BREAK);
+        return property == U_LB_LINE_FEED || property == U_LB_MANDATORY_BREAK;
+    }
+
+public:
+    ~SkUnicode_icu() override { }
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override {
+        return fBidiFact->MakeIterator(text, count, dir);
+    }
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override {
+        return fBidiFact->MakeIterator(text, count, dir);
+    }
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType type) override {
+        ICUBreakIterator iterator = SkIcuBreakIteratorCache::get().makeBreakIterator(type, locale);
+        if (!iterator) {
+            return nullptr;
+        }
+        return std::unique_ptr<SkBreakIterator>(new SkBreakIterator_icu(std::move(iterator)));
+    }
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType type) override {
+        return makeBreakIterator(sk_uloc_getDefault(), type);
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return this->toUpper(str, nullptr);
+    }
+
+    SkString toUpper(const SkString& str, const char* locale) override {
+        // Convert to UTF16 since that's what ICU wants.
+        auto str16 = SkUnicode::convertUtf8ToUtf16(str.c_str(), str.size());
+
+        UErrorCode icu_err = U_ZERO_ERROR;
+        const auto upper16len = sk_u_strToUpper(nullptr, 0, (UChar*)(str16.c_str()), str16.size(),
+                                                locale, &icu_err);
+        if (icu_err != U_BUFFER_OVERFLOW_ERROR || upper16len <= 0) {
+            return SkString();
+        }
+
+        AutoSTArray<128, uint16_t> upper16(upper16len);
+        icu_err = U_ZERO_ERROR;
+        sk_u_strToUpper((UChar*)(upper16.get()), SkToS32(upper16.size()),
+                        (UChar*)(str16.c_str()), str16.size(),
+                        locale, &icu_err);
+        SkASSERT(!U_FAILURE(icu_err));
+
+        // ... and back to utf8 'cause that's what we want.
+        return convertUtf16ToUtf8((char16_t*)upper16.get(), upper16.size());
+    }
+
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+        return fBidiFact->ExtractBidi(utf8, utf8Units, dir, results);
+    }
+
+    bool getWords(const char utf8[], int utf8Units, const char* locale,
+                  std::vector<Position>* results) override {
+
+        // Convert to UTF16 since we want the results in utf16
+        auto utf16 = convertUtf8ToUtf16(utf8, utf8Units);
+        return SkUnicode_icu::extractWords((uint16_t*)utf16.c_str(), utf16.size(), locale, results);
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        // Convert to UTF16 since we want the results in utf16
+        auto utf16 = convertUtf8ToUtf16(utf8, utf8Units);
+        std::vector<Position> utf16Results;
+        if (!SkUnicode_icu::extractWords(
+                    (uint16_t*)utf16.c_str(), utf16.size(), locale, &utf16Results)) {
+            return false;
+        }
+
+        std::vector<Position> mapping;
+        SkSpan<const char> text(utf8, utf8Units);
+        SkUnicode::extractUtfConversionMapping(
+                text, [&](size_t index) { mapping.emplace_back(index); }, [&](size_t index) {});
+
+        for (auto i16 : utf16Results) {
+            results->emplace_back(mapping[i16]);
+        }
+        return true;
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkUnicode_icu::extractPositions(
+                utf8, utf8Units, BreakType::kSentences, nullptr,
+                [&](int pos, int status) {
+                    results->emplace_back(pos);
+                });
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char utf8[], int utf8Units, bool replaceTabs,
+                              TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        SkUnicode_icu::extractPositions(utf8, utf8Units, BreakType::kLines, nullptr, // TODO: locale
+                                        [&](int pos, int status) {
+            (*results)[pos] |= status == UBRK_LINE_HARD
+                                       ? CodeUnitFlags::kHardLineBreakBefore
+                                       : CodeUnitFlags::kSoftLineBreakBefore;
+        });
+
+        SkUnicode_icu::extractPositions(utf8, utf8Units, BreakType::kGraphemes, nullptr, //TODO
+                                        [&](int pos, int status) {
+            (*results)[pos] |= CodeUnitFlags::kGraphemeStart;
+        });
+
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && this->isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                if (this->isSpace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (this->isWhitespace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+                if (this->isIdeographic(unichar)) {
+                    results->at(i) |= SkUnicode::kIdeographic;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf16Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        // Get white spaces
+        this->forEachCodepoint((char16_t*)&utf16[0], utf16Units,
+           [this, results, replaceTabs, &utf16](SkUnichar unichar, int32_t start, int32_t end) {
+                for (auto i = start; i < end; ++i) {
+                    if (replaceTabs && this->isTabulation(unichar)) {
+                        results->at(i) |= SkUnicode::kTabulation;
+                    if (replaceTabs) {
+                            unichar = ' ';
+                            utf16[start] = ' ';
+                        }
+                    }
+                    if (this->isSpace(unichar)) {
+                        results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                    }
+                    if (this->isWhitespace(unichar)) {
+                        results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                    }
+                    if (this->isControl(unichar)) {
+                        results->at(i) |= SkUnicode::kControl;
+                    }
+                }
+           });
+        // Get graphemes
+        this->forEachBreak((char16_t*)&utf16[0],
+                           utf16Units,
+                           SkUnicode::BreakType::kGraphemes,
+                           [results](SkBreakIterator::Position pos, SkBreakIterator::Status) {
+                               (*results)[pos] |= CodeUnitFlags::kGraphemeStart;
+                           });
+        // Get line breaks
+        this->forEachBreak(
+                (char16_t*)&utf16[0],
+                utf16Units,
+                SkUnicode::BreakType::kLines,
+                [results](SkBreakIterator::Position pos, SkBreakIterator::Status status) {
+                    if (status ==
+                        (SkBreakIterator::Status)SkUnicode::LineBreakType::kHardLineBreak) {
+                        // Hard line breaks clears off all the other flags
+                        // TODO: Treat \n as a formatting mark and do not pass it to SkShaper
+                        (*results)[pos-1] = CodeUnitFlags::kHardLineBreakBefore;
+                    } else {
+                        (*results)[pos] |= CodeUnitFlags::kSoftLineBreakBefore;
+                    }
+                });
+
+        return true;
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+        fBidiFact->bidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+    }
+
+private:
+    sk_sp<SkBidiFactory> fBidiFact = sk_make_sp<SkBidiICUFactory>();
+};
+
+namespace SkUnicodes::ICU {
+sk_sp<SkUnicode> Make() {
+    // We haven't yet created a way to encode the ICU data for assembly on Windows,
+    // so we use a helper library to load icudtl.dat from the harddrive.
+#if defined(SK_USING_THIRD_PARTY_ICU) && defined(SK_BUILD_FOR_WIN)
+    if (!SkLoadICU()) {
+        static SkOnce once;
+        once([] { SkDEBUGF("SkLoadICU() failed!\n"); });
+        return nullptr;
+    }
+#endif
+    if (SkGetICULib()) {
+        return sk_make_sp<SkUnicode_icu>();
+    }
+    return nullptr;
+}
+}  // namespace SkUnicodes::ICU
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp
new file mode 100644
index 00000000..2fa6079a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp
@@ -0,0 +1,409 @@
+/*
+* Copyright 2023 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "src/base/SkUTF.h"
+
+#include <ICU4XBidi.hpp>
+#include <ICU4XCaseMapper.hpp>
+#include <ICU4XCodePointMapData8.hpp>
+#include <ICU4XCodePointSetData.hpp>
+#include <ICU4XDataProvider.hpp>
+#include <ICU4XGraphemeClusterSegmenter.hpp>
+#include <ICU4XLineSegmenter.hpp>
+#include <ICU4XWordSegmenter.hpp>
+
+#include <algorithm>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+class SkUnicode_icu4x :  public SkUnicode {
+public:
+    SkUnicode_icu4x() {
+        fLocale = ICU4XLocale::create_from_string("tr").ok().value();
+        fDataProvider = ICU4XDataProvider::create_compiled();
+        fCaseMapper = ICU4XCaseMapper::create(fDataProvider).ok().value();
+        const auto general = ICU4XCodePointMapData8::load_general_category(fDataProvider).ok().value();
+        fControls = general.get_set_for_value(/*Control*/15);
+        fWhitespaces = general.get_set_for_value(/*SpaceSeparator*/12);
+        fSpaces = general.get_set_for_value(/*SpaceSeparator*/12);
+        // TODO: u_isSpace
+        fBlanks = ICU4XCodePointSetData::load_blank(fDataProvider).ok().value();
+        fEmoji = ICU4XCodePointSetData::load_emoji(fDataProvider).ok().value();
+        fEmojiComponent = ICU4XCodePointSetData::load_emoji_component(fDataProvider).ok().value();
+        fEmojiModifier = ICU4XCodePointSetData::load_emoji_modifier(fDataProvider).ok().value();
+        fEmojiModifierBase = ICU4XCodePointSetData::load_emoji_modifier_base(fDataProvider).ok().value();
+        fEmoji = ICU4XCodePointSetData::load_emoji(fDataProvider).ok().value();
+        fRegionalIndicator = ICU4XCodePointSetData::load_regional_indicator(fDataProvider).ok().value();
+        fIdeographic = ICU4XCodePointSetData::load_ideographic(fDataProvider).ok().value();
+        fLineBreaks = ICU4XCodePointMapData8::load_line_break(fDataProvider).ok().value();
+    }
+
+    ~SkUnicode_icu4x() override = default;
+
+    void reset();
+
+    // SkUnicode properties
+    bool isControl(SkUnichar utf8) override { return fControls.contains(utf8); }
+    bool isWhitespace(SkUnichar utf8) override { return fWhitespaces.contains(utf8); }
+    bool isSpace(SkUnichar utf8) override { return fBlanks.contains(utf8); }
+    bool isHardBreak(SkUnichar utf8) override {
+        auto value = fLineBreaks.get(utf8);
+        return (value == /*MandatoryBreak*/6) ||
+               (value == /*CarriageReturn*/10) ||
+               (value == /*LineFeed*/17) ||
+               (value == /*NextLine*/29);
+    }
+    bool isEmoji(SkUnichar utf8) override { return fEmoji.contains(utf8); }
+    bool isEmojiComponent(SkUnichar utf8) override { return fEmojiComponent.contains(utf8); }
+    bool isEmojiModifierBase(SkUnichar utf8) override { return fEmojiModifierBase.contains(utf8); }
+    bool isEmojiModifier(SkUnichar utf8) override { return fEmojiModifier.contains(utf8); }
+    bool isRegionalIndicator(SkUnichar utf8) override { return fRegionalIndicator.contains(utf8); }
+    bool isIdeographic(SkUnichar utf8) override { return fIdeographic.contains(utf8); }
+
+    // TODO: is there a check for tabulation
+    bool isTabulation(SkUnichar utf8) override {
+        return utf8 == '\t';
+    }
+
+    // For SkShaper
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType breakType) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType breakType) override;
+    // For SkParagraph
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+
+        const auto bidi = ICU4XBidi::create(fDataProvider).ok().value();
+        std::string_view string_view(utf8, utf8Units);
+        auto info = bidi.for_text(string_view, dir == TextDirection::kLTR ? 0 : 1);
+        auto currentLevel = info.level_at(0);
+        size_t start = 0;
+
+        for (size_t i = 1; i < info.size(); i++) {
+            const auto level =  info.level_at(i);
+            if (level != currentLevel) {
+                (*results).emplace_back(start, i, currentLevel);
+                currentLevel = level;
+                start = i;
+            }
+        }
+        (*results).emplace_back(start, info.size(), currentLevel);
+        return true;
+    }
+
+    bool getBidiRegions(const uint16_t utf16[],
+                        int utf16Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) {
+        auto utf8 = SkUnicode::convertUtf16ToUtf8((char16_t*)utf16, utf16Units);
+        return this->getBidiRegions(utf8.data(), utf8.size(), dir, results);
+    }
+
+    bool computeCodeUnitFlags(char utf8[],
+                              int utf8Units,
+                              bool replaceTabs,
+                              skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+        this->markLineBreaks(utf8, utf8Units, /*hardLineBreaks=*/false, results);
+        this->markHardLineBreaksHack(utf8, utf8Units, results);
+        this->markGraphemes(utf8, utf8Units, results);
+        this->markCharacters(utf8, utf8Units, replaceTabs, results);
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        SkASSERT(false);
+        return true;
+    }
+
+    bool getWords(const char utf8[],
+                  int utf8Units,
+                  const char* locale,
+                  std::vector<Position>* results) override {
+        auto utf16 = SkUnicode::convertUtf8ToUtf16(utf8, utf8Units);
+        const diplomat::span<const uint16_t> span((uint16_t*)utf16.data(), utf16.size());
+        const auto segmenter = ICU4XWordSegmenter::create_dictionary(fDataProvider).ok().value();
+        auto iterator = segmenter.segment_utf16(span);
+        while (true) {
+            int32_t breakpoint = iterator.next();
+            if (breakpoint == -1) {
+                break;
+            }
+            results->emplace_back(breakpoint);
+        }
+        return true;
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return toUpper(str, "und");
+    }
+
+    SkString toUpper(const SkString& str, const char* localeStr) override {
+        auto locale = ICU4XLocale::create_from_string(localeStr).ok().value();
+        std::string std_string(str.data(), str.size());
+        // TODO: upper case
+        auto result = fCaseMapper.uppercase(std_string, locale).ok().value();
+        return SkString(result.data(), result.size());
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+
+        const auto bidi = ICU4XBidi::create(fDataProvider).ok().value();
+        const diplomat::span<const uint8_t> levels(&runLevels[0], levelsCount);
+        auto map = bidi.reorder_visual(levels);
+        SkASSERT(levelsCount == map.len());
+        std::vector<int32_t> results;
+        for (size_t i = 0; i < map.len(); i++) {
+            auto level = map.get(i);
+            logicalFromVisual[i] = SkToS32(level);
+        }
+    }
+
+private:
+    friend class SkBreakIterator_icu4x;
+    friend class SkBidiIterator_icu4x;
+
+    bool markHardLineBreaksHack(char utf8[],
+                                int utf8Units,
+                                skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        const char* end = utf8 + utf8Units;
+        const char* ch = utf8;
+        while (ch < end) {
+            auto unichar = SkUTF::NextUTF8(&ch, end);
+            if (this->isHardBreak(unichar)) {
+                (*results)[ch - utf8] |= CodeUnitFlags::kHardLineBreakBefore;
+            }
+        }
+        return true;
+    }
+
+    SkUnichar getChar32(const char* pointer, const char* end) {
+        if (pointer < end) {
+            return SkUTF::NextUTF8(&pointer, end);
+        }
+        return -1;
+    }
+
+    bool markLineBreaks(char utf8[],
+                        int utf8Units,
+                        bool hardLineBreaks,
+                        skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        if (utf8Units == 0) {
+            return true;
+        }
+        // TODO: Remove hard line break hack and detect it here
+        SkASSERT(!hardLineBreaks);
+        const auto lineBreakingOptions = hardLineBreaks
+                                              ? ICU4XLineBreakOptionsV1{ICU4XLineBreakStrictness::Strict, ICU4XLineBreakWordOption::Normal}
+                                              : ICU4XLineBreakOptionsV1{ICU4XLineBreakStrictness::Loose, ICU4XLineBreakWordOption::Normal};
+        const auto segmenter = ICU4XLineSegmenter::create_auto_with_options_v1(fDataProvider, lineBreakingOptions).ok().value();
+        std::string_view string_view(utf8, utf8Units);
+        auto iterator = segmenter.segment_utf8(string_view);
+
+        while (true) {
+            int32_t lineBreak = iterator.next();
+            if (lineBreak == -1) {
+                break;
+            }
+            if (hardLineBreaks) {
+                (*results)[lineBreak] |= CodeUnitFlags::kHardLineBreakBefore;
+            } else {
+                (*results)[lineBreak] |= CodeUnitFlags::kSoftLineBreakBefore;
+            }
+        }
+        if (!hardLineBreaks) {
+            (*results)[0] |= CodeUnitFlags::kSoftLineBreakBefore;
+            (*results)[utf8Units] |= CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        return true;
+    }
+
+    bool markGraphemes(const char utf8[],
+                       int utf8Units,
+                       skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        const auto segmenter = ICU4XGraphemeClusterSegmenter::create(fDataProvider).ok().value();
+        std::string_view string_view(utf8, utf8Units);
+        auto iterator = segmenter.segment_utf8(string_view);
+        while (true) {
+            int32_t graphemeStart = iterator.next();
+            if (graphemeStart == -1) {
+                break;
+            }
+            (*results)[graphemeStart] |= CodeUnitFlags::kGraphemeStart;
+        }
+        return true;
+    }
+
+    bool markCharacters(char utf8[],
+                        int utf8Units,
+                        bool replaceTabs,
+                        skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && SkUnicode_icu4x::isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                bool isHardBreak = this->isHardBreak(unichar);
+                bool isSpace = this->isSpace(unichar) || isHardBreak;
+                bool isWhitespace = this->isWhitespace(unichar) || isHardBreak;
+                if (isSpace) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (isWhitespace) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        SkDEBUGF("Method 'getUtf8Words' is not implemented\n");
+        return false;
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkDEBUGF("Method 'getSentences' is not implemented\n");
+        return false;
+    }
+
+    std::shared_ptr<std::vector<SkUnicode::BidiRegion>> fRegions;
+    ICU4XLocale fLocale;
+    ICU4XDataProvider fDataProvider;
+    ICU4XCaseMapper fCaseMapper;
+    ICU4XCodePointSetData fWhitespaces;
+    ICU4XCodePointSetData fSpaces;
+    ICU4XCodePointSetData fBlanks;
+    ICU4XCodePointSetData fEmoji;
+    ICU4XCodePointSetData fEmojiComponent;
+    ICU4XCodePointSetData fEmojiModifier;
+    ICU4XCodePointSetData fEmojiModifierBase;
+    ICU4XCodePointSetData fRegionalIndicator;
+    ICU4XCodePointSetData fIdeographic;
+    ICU4XCodePointSetData fControls;
+    ICU4XCodePointMapData8 fLineBreaks;
+};
+
+class SkBreakIterator_icu4x: public SkBreakIterator {
+    Position fLastResult;
+    Position fStart;
+    Position fEnd;
+public:
+    SkBreakIterator_icu4x() { }
+    Position first() override { SkASSERT(false); return -1; }
+    Position current() override { SkASSERT(false); return -1; }
+    Position next() override { SkASSERT(false); return -1; }
+    Status status() override { SkASSERT(false); return -1; }
+    bool isDone() override { SkASSERT(false); return false; }
+    bool setText(const char utftext8[], int utf8Units) override { SkASSERT(false); return false; }
+    bool setText(const char16_t utftext16[], int utf16Units) override { SkASSERT(false); return false; }
+};
+
+class SkBidiIterator_icu4x : public SkBidiIterator {
+    std::shared_ptr<std::vector<SkUnicode::BidiRegion>> fRegions;
+public:
+    explicit SkBidiIterator_icu4x(std::shared_ptr<std::vector<SkUnicode::BidiRegion>> regions)
+            : fRegions(regions) { }
+    Position getLength() override { return fRegions->size(); }
+    Level getLevelAt(Position pos) override {
+        auto found = std::lower_bound(
+                fRegions->begin(),
+                fRegions->end(),
+                SkUnicode::BidiRegion(pos, pos, 0),
+                [](const SkUnicode::BidiRegion& a, const SkUnicode::BidiRegion& b) {
+                    return a.start <= b.start && a.end <= b.end;
+                });
+        return found->level;
+    }
+};
+
+std::unique_ptr<SkBidiIterator> SkUnicode_icu4x::makeBidiIterator(const uint16_t text[], int count,
+                                                 SkBidiIterator::Direction dir) {
+    if (fRegions) {
+        fRegions->clear();
+    } else {
+        fRegions = std::make_shared<std::vector<SkUnicode::BidiRegion>>();
+    }
+
+    if (this->getBidiRegions(text, count, dir == SkBidiIterator::Direction::kLTR ? TextDirection::kLTR : TextDirection::kRTL, fRegions.get())) {
+        return std::make_unique<SkBidiIterator_icu4x>(fRegions);
+    } else {
+        return nullptr;
+    }
+}
+
+std::unique_ptr<SkBidiIterator> SkUnicode_icu4x::makeBidiIterator(const char text[],
+                                                 int count,
+                                                 SkBidiIterator::Direction dir) {
+    if (fRegions) {
+        fRegions->clear();
+    } else {
+        fRegions = std::make_shared<std::vector<SkUnicode::BidiRegion>>();
+    }
+    if (this->getBidiRegions(text, count, dir == SkBidiIterator::Direction::kLTR ? TextDirection::kLTR : TextDirection::kRTL, fRegions.get())) {
+        return std::make_unique<SkBidiIterator_icu4x>(fRegions);
+    } else {
+        return nullptr;
+    }
+}
+
+std::unique_ptr<SkBreakIterator> SkUnicode_icu4x::makeBreakIterator(const char locale[],
+                                                   BreakType breakType) {
+    SkASSERT(false); return nullptr;
+}
+
+std::unique_ptr<SkBreakIterator> SkUnicode_icu4x::makeBreakIterator(BreakType breakType) {
+    SkASSERT(false); return nullptr;
+}
+
+namespace SkUnicodes::ICU4X {
+sk_sp<SkUnicode> Make() {
+    return sk_make_sp<SkUnicode_icu4x>();
+}
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp
new file mode 100644
index 00000000..f38c0811
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2022 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkTFitsIn.h"
+#include "src/base/SkUTF.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace {
+using SkUnicodeBidi = std::unique_ptr<UBiDi, SkBidiFactory::BidiCloseCallback>;
+
+class SkBidiIterator_icu : public SkBidiIterator {
+public:
+    SkBidiIterator_icu(SkUnicodeBidi bidi, sk_sp<SkBidiFactory> fact)
+            : fBidi(std::move(bidi)), fBidiFact(std::move(fact)) {}
+
+    Position getLength() override { return fBidiFact->bidi_getLength(fBidi.get()); }
+
+    Level getLevelAt(Position pos) override { return fBidiFact->bidi_getLevelAt(fBidi.get(), pos); }
+
+private:
+    SkUnicodeBidi fBidi;
+    sk_sp<SkBidiFactory> fBidiFact;
+};
+}  // namespace
+
+std::unique_ptr<SkBidiIterator> SkBidiFactory::MakeIterator(const uint16_t utf16[],
+                                                            int utf16Units,
+                                                            SkBidiIterator::Direction dir) const {
+    UErrorCode status = U_ZERO_ERROR;
+    SkUnicodeBidi bidi(this->bidi_openSized(utf16Units, 0, &status), this->bidi_close_callback());
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return nullptr;
+    }
+    SkASSERT(bidi);
+    uint8_t bidiLevel = (dir == SkBidiIterator::kLTR) ? UBIDI_LTR : UBIDI_RTL;
+    // The required lifetime of utf16 isn't well documented.
+    // It appears it isn't used after ubidi_setPara except through ubidi_getText.
+    this->bidi_setPara(bidi.get(), (const UChar*)utf16, utf16Units, bidiLevel, nullptr, &status);
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return nullptr;
+    }
+    return std::unique_ptr<SkBidiIterator>(
+            new SkBidiIterator_icu(std::move(bidi), sk_ref_sp(this)));
+}
+
+std::unique_ptr<SkBidiIterator> SkBidiFactory::MakeIterator(const char utf8[],
+                                                            int utf8Units,
+                                                            SkBidiIterator::Direction dir) const {
+    // Convert utf8 into utf16 since ubidi only accepts utf16
+    if (!SkTFitsIn<int32_t>(utf8Units)) {
+        SkDEBUGF("Bidi error: text too long");
+        return nullptr;
+    }
+
+    // Getting the length like this seems to always set U_BUFFER_OVERFLOW_ERROR
+    int utf16Units = SkUTF::UTF8ToUTF16(nullptr, 0, utf8, utf8Units);
+    if (utf16Units < 0) {
+        SkDEBUGF("Bidi error: Invalid utf8 input");
+        return nullptr;
+    }
+    std::unique_ptr<uint16_t[]> utf16(new uint16_t[utf16Units]);
+    SkDEBUGCODE(int dstLen =) SkUTF::UTF8ToUTF16(utf16.get(), utf16Units, utf8, utf8Units);
+    SkASSERT(dstLen == utf16Units);
+
+    return MakeIterator(utf16.get(), utf16Units, dir);
+}
+
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+bool SkBidiFactory::ExtractBidi(const char utf8[],
+                                int utf8Units,
+                                SkUnicode::TextDirection dir,
+                                std::vector<SkUnicode::BidiRegion>* bidiRegions) const {
+    // Convert to UTF16 since for now bidi iterator only operates on utf16
+    auto utf16 = SkUnicode::convertUtf8ToUtf16(utf8, utf8Units);
+
+    // Create bidi iterator
+    UErrorCode status = U_ZERO_ERROR;
+    SkUnicodeBidi bidi(this->bidi_openSized(utf16.size(), 0, &status), this->bidi_close_callback());
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return false;
+    }
+    SkASSERT(bidi);
+    uint8_t bidiLevel = (dir == SkUnicode::TextDirection::kLTR) ? UBIDI_LTR : UBIDI_RTL;
+    // The required lifetime of utf16 isn't well documented.
+    // It appears it isn't used after ubidi_setPara except through ubidi_getText.
+    this->bidi_setPara(
+            bidi.get(), (const UChar*)utf16.c_str(), utf16.size(), bidiLevel, nullptr, &status);
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return false;
+    }
+
+    // Iterate through bidi regions and the result positions into utf8
+    const char* start8 = utf8;
+    const char* end8 = utf8 + utf8Units;
+    SkUnicode::BidiLevel currentLevel = 0;
+
+    SkUnicode::Position pos8 = 0;
+    SkUnicode::Position pos16 = 0;
+    SkUnicode::Position end16 = this->bidi_getLength(bidi.get());
+
+    if (end16 == 0) {
+        return true;
+    }
+    if (this->bidi_getDirection(bidi.get()) != UBIDI_MIXED) {
+        // The entire paragraph is unidirectional.
+        bidiRegions->emplace_back(0, utf8Units, this->bidi_getLevelAt(bidi.get(), 0));
+        return true;
+    }
+
+    while (pos16 < end16) {
+        auto level = this->bidi_getLevelAt(bidi.get(), pos16);
+        if (pos16 == 0) {
+            currentLevel = level;
+        } else if (level != currentLevel) {
+            SkUnicode::Position end = start8 - utf8;
+            bidiRegions->emplace_back(pos8, end, currentLevel);
+            currentLevel = level;
+            pos8 = end;
+        }
+        SkUnichar u = utf8_next(&start8, end8);
+        pos16 += SkUTF::ToUTF16(u);
+    }
+    SkUnicode::Position end = start8 - utf8;
+    if (end != pos8) {
+        bidiRegions->emplace_back(pos8, end, currentLevel);
+    }
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h
new file mode 100644
index 00000000..a9e1f4be
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2023 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_icu_bidi_DEFINED
+#define SkUnicode_icu_bidi_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+// Some versions of SkUnicode need a small subset of ICU to do bidi things. This
+// allows us to have the same API for the subset as well as the full ICU.
+class SkBidiFactory : public SkRefCnt {
+public:
+    std::unique_ptr<SkBidiIterator> MakeIterator(const uint16_t utf16[],
+                                                 int utf16Units,
+                                                 SkBidiIterator::Direction dir) const;
+    std::unique_ptr<SkBidiIterator> MakeIterator(const char utf8[],
+                                                 int utf8Units,
+                                                 SkBidiIterator::Direction dir) const;
+    bool ExtractBidi(const char utf8[],
+                     int utf8Units,
+                     SkUnicode::TextDirection dir,
+                     std::vector<SkUnicode::BidiRegion>* bidiRegions) const;
+
+    virtual const char* errorName(UErrorCode status) const = 0;
+
+using BidiCloseCallback = void(*)(UBiDi* bidi);
+    virtual BidiCloseCallback bidi_close_callback() const = 0;
+    virtual UBiDiDirection bidi_getDirection(const UBiDi* bidi) const = 0;
+    virtual SkBidiIterator::Position bidi_getLength(const UBiDi* bidi) const = 0;
+    virtual SkBidiIterator::Level bidi_getLevelAt(const UBiDi* bidi, int pos) const = 0;
+    virtual UBiDi* bidi_openSized(int32_t maxLength,
+                                  int32_t maxRunCount,
+                                  UErrorCode* pErrorCode) const = 0;
+    virtual void bidi_setPara(UBiDi* bidi,
+                              const UChar* text,
+                              int32_t length,
+                              UBiDiLevel paraLevel,
+                              UBiDiLevel* embeddingLevels,
+                              UErrorCode* status) const = 0;
+    virtual void bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                                    int levelsCount,
+                                    int32_t logicalFromVisual[]) const = 0;
+};
+
+#endif // SkUnicode_icu_bidi_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp
new file mode 100644
index 00000000..e861243d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/private/base/SkFeatures.h"  // IWYU pragma: keep
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+
+#include <memory>
+#include <type_traits>
+#include <utility>
+
+#include <unicode/ubrk.h>
+#include <unicode/uloc.h>
+#include <unicode/utypes.h>
+
+namespace {
+
+// ubrk_clone added as draft in ICU69 and Android API 31 (first ICU NDK).
+// ubrk_safeClone deprecated in ICU69 and not exposed by Android.
+template<typename T, typename = void>
+struct SkUbrkClone {
+    static UBreakIterator* clone(T bi, UErrorCode* status) {
+        return ubrk_safeClone(bi, nullptr, nullptr, status);
+    }
+};
+template<typename T>
+struct SkUbrkClone<T, std::void_t<decltype(ubrk_clone(std::declval<T>(), nullptr))>> {
+    static UBreakIterator* clone(T bi, UErrorCode* status) {
+        return ubrk_clone(bi, status);
+    }
+};
+
+// ubrk_getLocaleByType has been in ICU since version 2.8
+// However, it was not included in the Android NDK
+template<typename T, typename = void>
+struct SkUbrkGetLocaleByType {
+    static const char* getLocaleByType(T bi, ULocDataLocaleType type, UErrorCode* status) {
+        *status = U_UNSUPPORTED_ERROR;
+        return nullptr;
+    }
+};
+template<typename T>
+struct SkUbrkGetLocaleByType<
+    T,
+    std::void_t<decltype(ubrk_getLocaleByType(std::declval<T>(),
+                                              std::declval<ULocDataLocaleType>(),
+                                              nullptr))>>
+{
+    static const char* getLocaleByType(T bi, ULocDataLocaleType type, UErrorCode* status) {
+        return ubrk_getLocaleByType(bi, type, status);
+    }
+};
+
+}  // namespace
+
+#define SKICU_FUNC(funcname) funcname,
+std::unique_ptr<SkICULib> SkLoadICULib() {
+    return std::make_unique<SkICULib>(SkICULib{
+        SKICU_EMIT_FUNCS
+        &SkUbrkClone<const UBreakIterator*>::clone,
+        nullptr,
+        &SkUbrkGetLocaleByType<const UBreakIterator*>::getLocaleByType,
+    });
+}
+
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp
new file mode 100644
index 00000000..90eacec1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+
+#include <dlfcn.h>
+
+#define SK_RUNTIME_ICU_PATHS "libicuuc.so"
+
+std::unique_ptr<SkICULib> SkLoadICULib() {
+    static constexpr char const* gLibPaths[] = { SK_RUNTIME_ICU_PATHS };
+
+    void* dlhnd = nullptr;
+    for (const auto path : gLibPaths) {
+        dlhnd = dlopen(path, RTLD_LAZY);
+        if (dlhnd) {
+            break;
+        }
+    }
+
+    if (!dlhnd) {
+        SkDEBUGF("ICU loader: failed to open libicuuc.\n");
+        return nullptr;
+    }
+
+    int icu_ver = -1;
+
+    bool resolved_required_syms = true;
+
+    auto resolve_sym = [&](void* hnd, const char name[], bool required = false) -> void* {
+        static constexpr int kMinVer =  44,
+                             kMaxVer = 100;
+
+        // First call performs a search to determine the actual lib version.
+        // Subsequent calls are pinned to the version found.
+        const auto search_to = icu_ver > 0 ? icu_ver : kMaxVer;
+        icu_ver              = icu_ver > 0 ? icu_ver : kMinVer;
+
+        for (;;) {
+            const auto sym = SkStringPrintf("%s_%d", name, icu_ver);
+            if (auto* addr = dlsym(dlhnd, sym.c_str())) {
+                return addr;
+            }
+
+            if (icu_ver == search_to) {
+                break;
+            }
+
+            icu_ver++;
+        }
+
+        if (required) {
+            resolved_required_syms = false;
+        }
+        return nullptr;
+    };
+
+    SkICULib lib {};
+
+    // When using dlsym
+    // *(void**)(&procPtr) = dlsym(self, "proc");
+    // is non-standard, but safe for POSIX. Cannot write
+    // *reinterpret_cast<void**>(&procPtr) = dlsym(self, "proc");
+    // because clang has not implemented DR573. See http://clang.llvm.org/cxx_dr_status.html .
+    #define SKICU_FUNC(fname) *(void**)(&lib.f_##fname) = resolve_sym(dlhnd, #fname, true);
+    SKICU_EMIT_FUNCS
+
+    *(void**)(&lib.f_ubrk_clone_)     = resolve_sym(dlhnd, "ubrk_clone");
+    *(void**)(&lib.f_ubrk_safeClone_) = resolve_sym(dlhnd, "ubrk_safeClone");
+    *(void**)(&lib.f_ubrk_getLocaleByType) = resolve_sym(dlhnd, "ubrk_getLocaleByType");
+
+    if (!resolved_required_syms || (!lib.f_ubrk_clone_ && !lib.f_ubrk_safeClone_)) {
+        SkDEBUGF("ICU loader: failed to resolve required symbols.");
+        dlclose(dlhnd);
+        return nullptr;
+    }
+
+    return std::make_unique<SkICULib>(lib);
+}
+
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h
new file mode 100644
index 00000000..4f663817
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_icupriv_DEFINED
+#define SkUnicode_icupriv_DEFINED
+
+#include <unicode/ubidi.h>
+#include <unicode/ubrk.h>
+#include <unicode/uchar.h>
+#include <unicode/uloc.h>
+#include <unicode/uscript.h>
+#include <unicode/ustring.h>
+#include <unicode/utext.h>
+#include <unicode/utypes.h>
+#include <cstdint>
+#include <memory>
+
+#define SKICU_EMIT_FUNCS              \
+    SKICU_FUNC(u_errorName)           \
+    SKICU_FUNC(u_hasBinaryProperty)   \
+    SKICU_FUNC(u_getIntPropertyValue) \
+    SKICU_FUNC(u_iscntrl)             \
+    SKICU_FUNC(u_isspace)             \
+    SKICU_FUNC(u_isWhitespace)        \
+    SKICU_FUNC(u_strToUpper)          \
+    SKICU_FUNC(ubidi_close)           \
+    SKICU_FUNC(ubidi_getDirection)    \
+    SKICU_FUNC(ubidi_getLength)       \
+    SKICU_FUNC(ubidi_getLevelAt)      \
+    SKICU_FUNC(ubidi_openSized)       \
+    SKICU_FUNC(ubidi_reorderVisual)   \
+    SKICU_FUNC(ubidi_setPara)         \
+    SKICU_FUNC(ubrk_close)            \
+    SKICU_FUNC(ubrk_current)          \
+    SKICU_FUNC(ubrk_first)            \
+    SKICU_FUNC(ubrk_following)        \
+    SKICU_FUNC(ubrk_getRuleStatus)    \
+    SKICU_FUNC(ubrk_next)             \
+    SKICU_FUNC(ubrk_open)             \
+    SKICU_FUNC(ubrk_preceding)        \
+    SKICU_FUNC(ubrk_setText)          \
+    SKICU_FUNC(ubrk_setUText)         \
+    SKICU_FUNC(uloc_forLanguageTag)   \
+    SKICU_FUNC(uloc_getDefault)       \
+    SKICU_FUNC(uscript_getScript)     \
+    SKICU_FUNC(utext_close)           \
+    SKICU_FUNC(utext_openUChars)      \
+    SKICU_FUNC(utext_openUTF8)        \
+
+#define SKICU_FUNC(funcname) decltype(funcname)* f_##funcname;
+struct SkICULib {
+    SKICU_EMIT_FUNCS
+
+    // ubrk_clone added as draft in ICU69 and Android API 31 (first ICU NDK).
+    // ubrk_safeClone deprecated in ICU69 and not exposed by Android.
+    UBreakIterator* (*f_ubrk_clone_)(const UBreakIterator*, UErrorCode*);
+    UBreakIterator* (*f_ubrk_safeClone_)(const UBreakIterator*, void*, int32_t*, UErrorCode*);
+
+    // ubrk_getLocaleByType not exposed by Android.
+    const char* (*f_ubrk_getLocaleByType)(const UBreakIterator*, ULocDataLocaleType, UErrorCode*);
+};
+#undef SKICU_FUNC
+
+// Platform/config specific ICU factory.
+std::unique_ptr<SkICULib> SkLoadICULib();
+
+// Get cached already loaded ICU library.
+const SkICULib* SkGetICULib();
+
+#endif // SkUnicode_icupriv_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp
new file mode 100644
index 00000000..5c9f168e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp
@@ -0,0 +1,303 @@
+/*
+* Copyright 2022 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkBidiFactory_icu_subset.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+#include "src/base/SkBitmaskEnum.h"
+
+extern "C" {
+#include <grapheme.h>
+}
+#include <array>
+#include <memory>
+#include <vector>
+#include <unordered_map>
+
+using namespace skia_private;
+
+class SkUnicode_libgrapheme : public SkUnicodeHardCodedCharProperties {
+public:
+    SkUnicode_libgrapheme() { }
+
+    ~SkUnicode_libgrapheme() override = default;
+
+    // For SkShaper
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType breakType) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType breakType) override;
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+        return fBidiFact->ExtractBidi(utf8, utf8Units, dir, results);
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkDEBUGF("Method 'getSentences' is not implemented\n");
+        return false;
+    }
+
+    bool computeCodeUnitFlags(char utf8[],
+                              int utf8Units,
+                              bool replaceTabs,
+                              skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        size_t lineBreak = 0;
+        (*results)[lineBreak] |= CodeUnitFlags::kSoftLineBreakBefore;
+        while (lineBreak < utf8Units) {
+            lineBreak += grapheme_next_line_break_utf8(utf8 + lineBreak, utf8Units - lineBreak);
+            // Check if the previous code unit is a hard break.
+            auto codePoint = utf8[lineBreak - 1];
+            (*results)[lineBreak] |= this->isHardBreak(codePoint)
+                                    ? CodeUnitFlags::kHardLineBreakBefore
+                                    : CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        (*results)[utf8Units] |= CodeUnitFlags::kSoftLineBreakBefore;
+
+        size_t graphemeBreak = 0;
+        (*results)[graphemeBreak] |= CodeUnitFlags::kGraphemeStart;
+        while (graphemeBreak < utf8Units) {
+            graphemeBreak += grapheme_next_character_break_utf8(utf8 + graphemeBreak, utf8Units - graphemeBreak);
+            (*results)[graphemeBreak] |= CodeUnitFlags::kGraphemeStart;
+        }
+
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && this->isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                if (this->isSpace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (this->isWhitespace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        SkASSERT(false);
+        return false;
+    }
+
+    bool getUtf8To16Mapping(const char utf8[], int utf8Units, std::unordered_map<Position, Position>* results) {
+        int utf16Units = 0;
+        const char* ptr8 = utf8;
+        const char* end8 = utf8 + utf8Units;
+        while (ptr8 < end8) {
+            results->emplace(ptr8 - utf8, utf16Units);
+            SkUnichar uni = SkUTF::NextUTF8(&ptr8, end8);
+            if (uni < 0) {
+                return false;
+            }
+
+            uint16_t utf16[2];
+            size_t count = SkUTF::ToUTF16(uni, utf16);
+            if (count == 0) {
+                return false;
+            }
+            utf16Units += count;
+        }
+        results->emplace(utf8Units, utf16Units);
+        return true;
+    }
+
+    bool getWords(const char utf8[], int utf8Units, const char* locale, std::vector<Position>* results) override {
+        std::unordered_map<Position, Position> mapping;
+        if (!getUtf8To16Mapping(utf8, utf8Units, &mapping)) {
+            return false;
+        }
+        size_t wordBreak = 0;
+        while (wordBreak < utf8Units) {
+            wordBreak += grapheme_next_word_break_utf8(utf8 + wordBreak, utf8Units - wordBreak);
+            if (mapping.find(wordBreak) == mapping.end()) {
+                return false;
+            }
+            results->emplace_back(mapping[wordBreak]);
+        }
+        return true;
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        // Let's consider sort line breaks, whitespaces and CJK codepoints instead
+        std::vector<CodeUnitFlags> breaks(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        size_t lineBreak = 0;
+        breaks[lineBreak] = CodeUnitFlags::kSoftLineBreakBefore;
+        while (lineBreak < utf8Units) {
+            lineBreak += grapheme_next_line_break_utf8(utf8 + lineBreak, utf8Units - lineBreak);
+            breaks[lineBreak] = CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        breaks[lineBreak] = CodeUnitFlags::kSoftLineBreakBefore;
+
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto index = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (this->isWhitespace(unichar)) {
+                breaks[index] = CodeUnitFlags::kPartOfWhiteSpaceBreak;
+            } else if (this->isIdeographic(unichar)) {
+                breaks[index] = CodeUnitFlags::kIdeographic;
+            }
+        }
+
+        bool whitespaces = false;
+        for (size_t i = 0; i < breaks.size(); ++i) {
+            auto b = breaks[i];
+            if (b == CodeUnitFlags::kSoftLineBreakBefore) {
+                results->emplace_back(i);
+                whitespaces = false;
+            } else if (b == CodeUnitFlags::kIdeographic) {
+                results->emplace_back(i);
+                whitespaces = false;
+            } else if (b == CodeUnitFlags::kPartOfWhiteSpaceBreak) {
+                if (!whitespaces) {
+                    results->emplace_back(i);
+                }
+                whitespaces = true;
+            } else {
+                whitespaces = false;
+            }
+        }
+
+        return true;
+
+        /*
+        size_t wordBreak = 0;
+        while (wordBreak < utf8Units) {
+            wordBreak += grapheme_next_word_break_utf8(utf8 + wordBreak, utf8Units - wordBreak);
+            results->emplace_back(wordBreak);
+        }
+        return true;
+        */
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return this->toUpper(str, nullptr);
+    }
+
+    SkString toUpper(const SkString& str, const char* locale) override {
+        SkString res(" ", str.size());
+        grapheme_to_uppercase_utf8(str.data(), str.size(), res.data(), res.size());
+        return res;
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+        fBidiFact->bidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+    }
+private:
+    friend class SkBreakIterator_libgrapheme;
+
+    sk_sp<SkBidiFactory> fBidiFact = sk_make_sp<SkBidiSubsetFactory>();
+};
+
+class SkBreakIterator_libgrapheme: public SkBreakIterator {
+    SkUnicode_libgrapheme* fUnicode;
+    std::vector<SkUnicode::LineBreakBefore> fLineBreaks;
+    Position fLineBreakIndex;
+    static constexpr const int kDone = -1;
+public:
+    explicit SkBreakIterator_libgrapheme(SkUnicode_libgrapheme* unicode) : fUnicode(unicode) { }
+    Position first() override
+      { return fLineBreaks[(fLineBreakIndex = 0)].pos; }
+    Position current() override
+      { return fLineBreaks[fLineBreakIndex].pos; }
+    Position next() override
+      { return fLineBreaks[++fLineBreakIndex].pos; }
+    Status status() override {
+        return fLineBreaks[fLineBreakIndex].breakType ==
+                       SkUnicode::LineBreakType::kHardLineBreak
+                       ? SkUnicode::CodeUnitFlags::kHardLineBreakBefore
+                       : SkUnicode::CodeUnitFlags::kSoftLineBreakBefore;
+    }
+    bool isDone() override { return fLineBreaks[fLineBreakIndex].pos == kDone; }
+    bool setText(const char utftext8[], int utf8Units) override {
+        fLineBreaks.clear();
+        size_t lineBreak = 0;
+        // first() must always go to the beginning of the string.
+        fLineBreaks.emplace_back(0, SkUnicode::LineBreakType::kHardLineBreak);
+        for (size_t pos = 0; pos < utf8Units;) {
+            pos += grapheme_next_line_break_utf8(utftext8 + pos, utf8Units - pos);
+            auto codePoint = utftext8[pos];
+            fLineBreaks.emplace_back(pos,
+                                     fUnicode->isHardBreak(codePoint)
+                                    ? SkUnicode::LineBreakType::kHardLineBreak
+                                    : SkUnicode::LineBreakType::kSoftLineBreak);
+        }
+        // There is always an "end" which signals "done".
+        fLineBreaks.emplace_back(kDone, SkUnicode::LineBreakType::kHardLineBreak);
+        fLineBreakIndex = 0;
+        return true;
+    }
+    bool setText(const char16_t utftext16[], int utf16Units) override {
+        SkASSERT(false);
+        return false;
+    }
+};
+
+std::unique_ptr<SkBidiIterator> SkUnicode_libgrapheme::makeBidiIterator(const uint16_t text[], int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBidiIterator> SkUnicode_libgrapheme::makeBidiIterator(const char text[],
+                                                 int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_libgrapheme::makeBreakIterator(const char locale[],
+                                                   BreakType breakType) {
+    return std::make_unique<SkBreakIterator_libgrapheme>(this);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_libgrapheme::makeBreakIterator(BreakType breakType) {
+    return std::make_unique<SkBreakIterator_libgrapheme>(this);
+}
+
+namespace SkUnicodes::Libgrapheme {
+sk_sp<SkUnicode> Make() {
+    return sk_make_sp<SkUnicode_libgrapheme>();
+}
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel
new file mode 100644
index 00000000..8cb44871
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel
@@ -0,0 +1,12 @@
+load("//bazel:macros.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "tests",
+    srcs = ["SkUnicodeTest.cpp"],
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp b/Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp
new file mode 100644
index 00000000..500ebee6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp
@@ -0,0 +1,368 @@
+
+/*
+ * Copyright 2023 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/core/SkSpan.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypeface.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "tests/Test.h"
+
+#include "modules/skunicode/include/SkUnicode.h"
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu.h"
+#endif
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+#endif
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+#endif
+#if defined(SK_UNICODE_CLIENT_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_client.h"
+#endif
+
+#include <vector>
+
+#ifdef SK_UNICODE_ICU_IMPLEMENTATION
+#define DEF_TEST_ICU(name, reporter) \
+    DEF_TEST(name##ICU, reporter) { name(reporter, SkUnicodes::ICU::Make()); }
+#else
+#define DEF_TEST_ICU(name, reporter)
+#endif
+
+#ifdef SK_UNICODE_ICU4X_IMPLEMENTATION
+#define DEF_TEST_ICU4X(name, reporter) \
+    DEF_TEST(name##ICU4X, reporter) { name(reporter, SkUnicodes::ICU4X::Make()); }
+#else
+#define DEF_TEST_ICU4X(name, reporter)
+#endif
+
+#ifdef SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION
+#define DEF_TEST_LIBGRAPHEME(name, reporter) \
+    DEF_TEST(name##LIBGRAPHEME, reporter) { name(reporter, SkUnicodes::Libgrapheme::Make()); }
+#else
+#define DEF_TEST_LIBGRAPHEME(name, reporter)
+#endif
+
+#define DEF_TEST_NOIMPL(name, reporter)
+
+#define DEF_TEST_UNICODES(name, reporter) \
+    static void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode); \
+    DEF_TEST_ICU(name, reporter) \
+    DEF_TEST_ICU4X(name, reporter) \
+    DEF_TEST_LIBGRAPHEME(name, reporter) \
+    DEF_TEST_NOIMPL(name, reporter) \
+    void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode)
+
+#define DEF_TEST_ICU_UNICODES(name, reporter) \
+    static void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode); \
+    DEF_TEST_ICU(name, reporter) \
+    DEF_TEST_ICU4X(name, reporter) \
+    DEF_TEST_NOIMPL(name, reporter) \
+    void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode)
+
+using namespace skia_private;
+
+#ifdef SK_UNICODE_CLIENT_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_Client, reporter) {
+    std::u16string text = u"\U000f2008";
+    auto utf8 = SkUnicode::convertUtf16ToUtf8(text.data(), text.size());
+    auto client = SkUnicodes::Client::Make
+                  (SkSpan<char>(&utf8[0], utf8.size()), {}, {}, {});
+    skia_private::TArray<SkUnicode::CodeUnitFlags, true> results;
+    client->computeCodeUnitFlags(utf8.data(), utf8.size(), false, &results);
+
+    for (auto flag : results) {
+        REPORTER_ASSERT(reporter, !SkUnicode::hasPartOfWhiteSpaceBreakFlag(flag));
+    }
+}
+#endif
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+UNIX_ONLY_TEST(SkUnicode_Compiled_Native, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    std::u16string text = u"\U000f2008";
+    auto utf8 = SkUnicode::convertUtf16ToUtf8(text.data(), text.size());
+    skia_private::TArray<SkUnicode::CodeUnitFlags, true> results;
+    icu->computeCodeUnitFlags(utf8.data(), utf8.size(), false, &results);
+    for (auto flag : results) {
+        REPORTER_ASSERT(reporter, !SkUnicode::hasPartOfWhiteSpaceBreakFlag(flag));
+    }
+}
+#endif
+
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+UNIX_ONLY_TEST(SkUnicode_GetUtf8Words, reporter) {
+    SkString text("1 22 333 4444 55555 666666 7777777");
+    std::vector<SkUnicode::Position> expected = { 0, 1, 2, 4, 5, 8, 9, 13, 14, 19, 20, 26, 27, 34 };
+    auto libgrapheme = SkUnicodes::Libgrapheme::Make();
+    std::vector<SkUnicode::Position> results;
+    auto result = libgrapheme->getUtf8Words(text.data(), text.size(), "en", &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+        REPORTER_ASSERT(reporter, results[i] == expected[i]);
+    }
+}
+#endif
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+UNIX_ONLY_TEST(SkUnicode_Compiled_GetSentences, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkString text("Hello world! Hello world? Hello world... Not a sentence end: 3.1415926");
+    std::vector<SkUnicode::Position> expected = {0, 13, 26, 41, 70};
+    std::vector<SkUnicode::Position> results;
+    auto result = icu->getSentences(text.data(), text.size(), nullptr, &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+        REPORTER_ASSERT(reporter, results[i] == expected[i]);
+    }
+}
+#endif
+
+bool hasWordFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kWordBreak) == SkUnicode::kWordBreak;
+}
+
+// On Windows libgrapheme produces different results
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsLTR, reporter) {
+    if (!unicode) {
+        return;
+    }
+    SkString text("1 22 333 4444 55555 666666 7777777");
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kLTR,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == 1);
+    REPORTER_ASSERT(reporter, results[0].start == 0 &&
+                              results[0].end == text.size() &&
+                              results[0].level == 0);
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsRTL, reporter) {
+    if (!unicode) {
+        return;
+    }
+    SkString text("          .");
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kRTL,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == 1);
+    REPORTER_ASSERT(reporter, results[0].start == 0 &&
+                              results[0].end == text.size() &&
+                              results[0].level == 1);
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsMix1, reporter) {
+    if (!unicode) {
+        return;
+    }
+    // Spaces become Arabic (RTL) but numbers remain English (LTR)
+    SkString text("1 22 333 4444 55555 666666 7777777");
+    std::vector<SkUnicode::BidiRegion> expected = {
+        {0, 1, 2},
+        {1, 2, 1},
+        {2, 4, 2},
+        {4, 5, 1},
+        {5, 8, 2},
+        {8, 9, 1},
+        {9, 13, 2},
+        {13, 14, 1},
+        {14, 19, 2},
+        {19, 20, 1},
+        {20, 26, 2},
+        {26, 27, 1},
+        {27, 34, 2},
+    };
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kRTL,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+      REPORTER_ASSERT(reporter, results[i].start == expected[i].start &&
+                                results[i].end == expected[i].end &&
+                                results[i].level == expected[i].level);
+    }
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsMix2, reporter) {
+    if (!unicode) {
+      return;
+    }
+    // Few Russian/English words () in the mix
+    SkString text("World  Domination        World  Optimization.");
+    std::vector<SkUnicode::BidiRegion> expected = {
+        { 0, 24, 0},
+        { 24, 80, 1},
+        { 80, 107, 0},
+    };
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kLTR,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+        REPORTER_ASSERT(reporter, results[i].start == expected[i].start &&
+                                  results[i].end == expected[i].end &&
+                                  results[i].level == expected[i].level);
+    }
+}
+
+// Currently, libgrapheme uses different default rules and produces slightly
+// different results; it does not matter for text shaping
+DEF_TEST_ICU_UNICODES(SkUnicode_ToUpper, reporter) {
+    if (!unicode) {
+        return;
+    }
+    SkString lower("abcdefghijklmnopqrstuvwxyz");
+    SkString upper("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    auto icu_result1 = unicode->toUpper(lower);
+    REPORTER_ASSERT(reporter, icu_result1.equals(upper));
+    auto icu_result2 = unicode->toUpper(upper);
+    REPORTER_ASSERT(reporter, icu_result2.equals(upper));
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_ComputeCodeUnitFlags, reporter) {
+    if (!unicode) {
+        return;
+    }
+    //SkString text("World domination is such an ugly phrase - I prefer to call it world optimisation");
+    SkString text("1\n22 333 4444 55555 666666 7777777");
+    // 4 8 13 19 24
+    TArray<SkUnicode::CodeUnitFlags> results;
+    auto result = unicode->computeCodeUnitFlags(text.data(),
+                                                text.size(),
+                                                /*replaceTabs=*/true,
+                                                &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == SkToS16(text.size() + 1));
+    for (auto i = 0; i < results.size(); ++i) {
+        auto flags = results[i];
+        auto expected = SkUnicode::CodeUnitFlags::kGraphemeStart;
+        if (i == 1) {
+            expected |= SkUnicode::CodeUnitFlags::kControl;
+        }
+        if (i == 2) {
+            expected |= SkUnicode::CodeUnitFlags::kHardLineBreakBefore;
+        }
+        if (i == 1 || i == 4 || i == 8 || i == 13 || i == 19 || i == 26) {
+            expected |= SkUnicode::CodeUnitFlags::kPartOfWhiteSpaceBreak;
+            expected |= SkUnicode::CodeUnitFlags::kPartOfIntraWordBreak;
+        }
+        if (i == 0 || i == 2 || i == 5 || i == 9 || i == 14 || i == 20
+                                                 || i == 27 || i == 34) {
+            expected |= SkUnicode::CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        REPORTER_ASSERT(reporter, flags == expected);
+    }
+}
+
+DEF_TEST_UNICODES(SkUnicode_ReorderVisual, reporter) {
+    if (!unicode) {
+        return;
+    }
+    auto reorder = [&](std::vector<SkUnicode::BidiLevel> levels,
+                       std::vector<int32_t> expected) {
+            std::vector<int32_t> logicalOrder(levels.size());
+            unicode->reorderVisual(levels.data(), levels.size(), logicalOrder.data());
+            for (auto i = 0ul; i < levels.size(); ++i) {
+                REPORTER_ASSERT(reporter, expected[i] == logicalOrder[i]);
+            }
+        };
+    reorder({}, {});
+    reorder({0}, {0});
+    reorder({1}, {0});
+    reorder({0, 1, 0, 1}, {0, 1, 2, 3});
+}
+
+[[maybe_unused]] static void SkUnicode_Emoji(SkUnicode* icu, skiatest::Reporter* reporter) {
+    std::u32string emojis(U"");
+    std::u32string not_emojis(U"");
+    for (auto e : emojis) {
+        REPORTER_ASSERT(reporter, icu->isEmoji(e));
+    }
+    for (auto n: not_emojis) {
+        REPORTER_ASSERT(reporter, !icu->isEmoji(n));
+    }
+}
+
+#ifdef SK_UNICODE_ICU_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_Compiled_Emoji, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Emoji(icu.get(), reporter);
+}
+#endif
+
+#ifdef SK_UNICODE_ICU4X_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_ICU4X_Emoji, reporter) {
+    auto icu = SkUnicodes::ICU4X::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Emoji(icu.get(), reporter);
+}
+#endif
+
+[[maybe_unused]] static void SkUnicode_Ideographic(SkUnicode* icu, skiatest::Reporter* reporter) {
+    std::u32string ideographic(U"");
+    std::u32string not_ideographic(U"");
+    for (auto i : ideographic) {
+        REPORTER_ASSERT(reporter, icu->isIdeographic(i));
+    }
+    for (auto n: not_ideographic) {
+        REPORTER_ASSERT(reporter, !icu->isIdeographic(n));
+    }
+}
+
+#ifdef SK_UNICODE_ICU_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_Compiled_Ideographic, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Ideographic(icu.get(), reporter);
+}
+#endif
+
+#ifdef SK_UNICODE_ICU4X_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_ICU4X_Ideographic, reporter) {
+    auto icu = SkUnicodes::ICU4X::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Ideographic(icu.get(), reporter);
+}
+#endif
-- 
2.47.0

