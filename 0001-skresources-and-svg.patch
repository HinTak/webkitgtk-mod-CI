From a7cafc259e474e15614f738707b414747b863aa4 Mon Sep 17 00:00:00 2001
From: Hin-Tak Leung <htl10@users.sourceforge.net>
Date: Wed, 20 Nov 2024 22:16:29 +0000
Subject: [PATCH 1/3] skresources and svg

Signed-off-by: Hin-Tak Leung <htl10@users.sourceforge.net>
---
 .../skia/modules/skresources/BUILD.bazel      |   31 +
 .../skia/modules/skresources/BUILD.gn         |   25 +
 .../modules/skresources/include/BUILD.bazel   |   13 +
 .../modules/skresources/include/SkResources.h |  289 ++++
 .../skia/modules/skresources/skresources.gni  |   20 +
 .../skia/modules/skresources/src/BUILD.bazel  |   17 +
 .../skresources/src/SkAnimCodecPlayer.cpp     |  155 +++
 .../skresources/src/SkAnimCodecPlayer.h       |   67 +
 .../modules/skresources/src/SkResources.cpp   |  337 +++++
 .../ThirdParty/skia/modules/svg/BUILD.bazel   |   29 +
 Source/ThirdParty/skia/modules/svg/BUILD.gn   |   70 +
 .../skia/modules/svg/include/BUILD.bazel      |   64 +
 .../skia/modules/svg/include/SkSVGAttribute.h |  113 ++
 .../svg/include/SkSVGAttributeParser.h        |  164 +++
 .../skia/modules/svg/include/SkSVGCircle.h    |   43 +
 .../skia/modules/svg/include/SkSVGClipPath.h  |   35 +
 .../skia/modules/svg/include/SkSVGContainer.h |   45 +
 .../skia/modules/svg/include/SkSVGDOM.h       |  114 ++
 .../skia/modules/svg/include/SkSVGDefs.h      |   23 +
 .../skia/modules/svg/include/SkSVGEllipse.h   |   42 +
 .../skia/modules/svg/include/SkSVGFe.h        |   87 ++
 .../skia/modules/svg/include/SkSVGFeBlend.h   |   45 +
 .../modules/svg/include/SkSVGFeColorMatrix.h  |   46 +
 .../svg/include/SkSVGFeComponentTransfer.h    |   75 ++
 .../modules/svg/include/SkSVGFeComposite.h    |   46 +
 .../svg/include/SkSVGFeDisplacementMap.h      |   46 +
 .../skia/modules/svg/include/SkSVGFeFlood.h   |   32 +
 .../modules/svg/include/SkSVGFeGaussianBlur.h |   41 +
 .../skia/modules/svg/include/SkSVGFeImage.h   |   35 +
 .../modules/svg/include/SkSVGFeLightSource.h  |   89 ++
 .../modules/svg/include/SkSVGFeLighting.h     |  121 ++
 .../skia/modules/svg/include/SkSVGFeMerge.h   |   55 +
 .../modules/svg/include/SkSVGFeMorphology.h   |   47 +
 .../skia/modules/svg/include/SkSVGFeOffset.h  |   35 +
 .../modules/svg/include/SkSVGFeTurbulence.h   |   40 +
 .../skia/modules/svg/include/SkSVGFilter.h    |   42 +
 .../modules/svg/include/SkSVGFilterContext.h  |   69 +
 .../skia/modules/svg/include/SkSVGG.h         |   23 +
 .../skia/modules/svg/include/SkSVGGradient.h  |   48 +
 .../svg/include/SkSVGHiddenContainer.h        |   23 +
 .../skia/modules/svg/include/SkSVGIDMapper.h  |   19 +
 .../skia/modules/svg/include/SkSVGImage.h     |   58 +
 .../skia/modules/svg/include/SkSVGLine.h      |   42 +
 .../modules/svg/include/SkSVGLinearGradient.h |   37 +
 .../skia/modules/svg/include/SkSVGMask.h      |   43 +
 .../skia/modules/svg/include/SkSVGNode.h      |  230 ++++
 .../svg/include/SkSVGOpenTypeSVGDecoder.h     |   32 +
 .../skia/modules/svg/include/SkSVGPath.h      |   36 +
 .../skia/modules/svg/include/SkSVGPattern.h   |   55 +
 .../skia/modules/svg/include/SkSVGPoly.h      |   45 +
 .../modules/svg/include/SkSVGRadialGradient.h |   38 +
 .../skia/modules/svg/include/SkSVGRect.h      |   46 +
 .../modules/svg/include/SkSVGRenderContext.h  |  217 +++
 .../skia/modules/svg/include/SkSVGSVG.h       |   54 +
 .../skia/modules/svg/include/SkSVGShape.h     |   33 +
 .../skia/modules/svg/include/SkSVGStop.h      |   35 +
 .../skia/modules/svg/include/SkSVGText.h      |  122 ++
 .../svg/include/SkSVGTransformableNode.h      |   36 +
 .../skia/modules/svg/include/SkSVGTypes.h     |  740 +++++++++++
 .../skia/modules/svg/include/SkSVGUse.h       |   42 +
 .../skia/modules/svg/include/SkSVGValue.h     |   85 ++
 .../skia/modules/svg/src/BUILD.bazel          |   69 +
 .../skia/modules/svg/src/SkSVGAttribute.cpp   |   48 +
 .../modules/svg/src/SkSVGAttributeParser.cpp  | 1175 +++++++++++++++++
 .../skia/modules/svg/src/SkSVGCircle.cpp      |   54 +
 .../skia/modules/svg/src/SkSVGClipPath.cpp    |   29 +
 .../skia/modules/svg/src/SkSVGContainer.cpp   |   52 +
 .../skia/modules/svg/src/SkSVGDOM.cpp         |  510 +++++++
 .../skia/modules/svg/src/SkSVGEllipse.cpp     |   51 +
 .../skia/modules/svg/src/SkSVGFe.cpp          |  125 ++
 .../skia/modules/svg/src/SkSVGFeBlend.cpp     |   61 +
 .../modules/svg/src/SkSVGFeColorMatrix.cpp    |  109 ++
 .../svg/src/SkSVGFeComponentTransfer.cpp      |  172 +++
 .../skia/modules/svg/src/SkSVGFeComposite.cpp |   74 ++
 .../svg/src/SkSVGFeDisplacementMap.cpp        |   68 +
 .../skia/modules/svg/src/SkSVGFeFlood.cpp     |   31 +
 .../modules/svg/src/SkSVGFeGaussianBlur.cpp   |   43 +
 .../skia/modules/svg/src/SkSVGFeImage.cpp     |   44 +
 .../modules/svg/src/SkSVGFeLightSource.cpp    |   49 +
 .../skia/modules/svg/src/SkSVGFeLighting.cpp  |  190 +++
 .../skia/modules/svg/src/SkSVGFeMerge.cpp     |   46 +
 .../modules/svg/src/SkSVGFeMorphology.cpp     |   61 +
 .../skia/modules/svg/src/SkSVGFeOffset.cpp    |   29 +
 .../modules/svg/src/SkSVGFeTurbulence.cpp     |   78 ++
 .../skia/modules/svg/src/SkSVGFilter.cpp      |   70 +
 .../modules/svg/src/SkSVGFilterContext.cpp    |  155 +++
 .../skia/modules/svg/src/SkSVGGradient.cpp    |  118 ++
 .../skia/modules/svg/src/SkSVGImage.cpp       |  100 ++
 .../skia/modules/svg/src/SkSVGLine.cpp        |   47 +
 .../modules/svg/src/SkSVGLinearGradient.cpp   |   41 +
 .../skia/modules/svg/src/SkSVGMask.cpp        |   66 +
 .../skia/modules/svg/src/SkSVGNode.cpp        |  184 +++
 .../svg/src/SkSVGOpenTypeSVGDecoder.cpp       |  154 +++
 .../skia/modules/svg/src/SkSVGPath.cpp        |   45 +
 .../skia/modules/svg/src/SkSVGPattern.cpp     |  123 ++
 .../skia/modules/svg/src/SkSVGPoly.cpp        |   51 +
 .../modules/svg/src/SkSVGRadialGradient.cpp   |   53 +
 .../skia/modules/svg/src/SkSVGRect.cpp        |   95 ++
 .../skia/modules/svg/src/SkSVGRectPriv.h      |   22 +
 .../modules/svg/src/SkSVGRenderContext.cpp    |  519 ++++++++
 .../skia/modules/svg/src/SkSVGSVG.cpp         |  111 ++
 .../skia/modules/svg/src/SkSVGShape.cpp       |   31 +
 .../skia/modules/svg/src/SkSVGStop.cpp        |   18 +
 .../skia/modules/svg/src/SkSVGText.cpp        |  715 ++++++++++
 .../skia/modules/svg/src/SkSVGTextPriv.h      |  212 +++
 .../svg/src/SkSVGTransformableNode.cpp        |   47 +
 .../skia/modules/svg/src/SkSVGUse.cpp         |   75 ++
 .../skia/modules/svg/src/SkSVGValue.cpp       |    7 +
 Source/ThirdParty/skia/modules/svg/svg.gni    |  115 ++
 .../skia/modules/svg/tests/BUILD.bazel        |    5 +
 .../skia/modules/svg/tests/Filters.cpp        |   34 +
 .../skia/modules/svg/tests/Text.cpp           |  194 +++
 .../skia/modules/svg/utils/BUILD.bazel        |    5 +
 .../skia/modules/svg/utils/SvgTool.cpp        |  102 ++
 114 files changed, 11468 insertions(+)
 create mode 100644 Source/ThirdParty/skia/modules/skresources/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skresources/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skresources/include/SkResources.h
 create mode 100644 Source/ThirdParty/skia/modules/skresources/skresources.gni
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGG.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGText.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/svg.gni
 create mode 100644 Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/tests/Filters.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/tests/Text.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp

diff --git a/Source/ThirdParty/skia/modules/skresources/BUILD.bazel b/Source/ThirdParty/skia/modules/skresources/BUILD.bazel
new file mode 100644
index 00000000..5cf92fe3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/BUILD.bazel
@@ -0,0 +1,31 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "legacy_skresources",
+    srcs = ["//modules/skresources/src:srcs"],
+    hdrs = ["//modules/skresources/include:hdrs"],
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//:skia_internal",
+    ],
+)
+
+skia_cc_library(
+    name = "skresources",
+    srcs = ["//modules/skresources/src:srcs"],
+    hdrs = ["//modules/skresources/include:hdrs"],
+    features = ["layering_check"],
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//:core",
+        "//src/base",
+        "//src/codec:codec_support_priv",
+        "//src/core:core_priv",
+    ],
+)
diff --git a/Source/ThirdParty/skia/modules/skresources/BUILD.gn b/Source/ThirdParty/skia/modules/skresources/BUILD.gn
new file mode 100644
index 00000000..12b3d5b5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/BUILD.gn
@@ -0,0 +1,25 @@
+# Copyright 2019 Google LLC
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+
+config("public_config") {
+  include_dirs = [ "include" ]
+}
+
+static_library("skresources") {
+  import("skresources.gni")
+  public_configs = [ ":public_config" ]
+  public = skia_skresources_public
+  sources = skia_skresources_sources
+  configs += [
+    "../../:skia_private",
+    "../../:skia_library",
+  ]
+  deps = [
+    "../..:skia",
+    "../../experimental/ffmpeg:video_decoder",
+  ]
+}
diff --git a/Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel b/Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel
new file mode 100644
index 00000000..22c3d7b5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel
@@ -0,0 +1,13 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "hdrs",
+    srcs = ["SkResources.h"],
+    visibility = ["//modules/skresources:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skresources/include/SkResources.h b/Source/ThirdParty/skia/modules/skresources/include/SkResources.h
new file mode 100644
index 00000000..3a465efb
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/include/SkResources.h
@@ -0,0 +1,289 @@
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkResources_DEFINED
+#define SkResources_DEFINED
+
+#include "include/core/SkData.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSamplingOptions.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypeface.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkMutex.h"
+#include "src/core/SkTHash.h"
+
+#include <memory>
+
+class SkAnimCodecPlayer;
+class SkCodec;
+class SkImage;
+
+namespace skresources {
+
+/**
+ * Image asset proxy interface.
+ */
+class SK_API ImageAsset : public SkRefCnt {
+public:
+    /**
+     * Returns true if the image asset is animated.
+     */
+    virtual bool isMultiFrame() = 0;
+
+    /**
+     * DEPRECATED: override getFrameData() instead.
+     *
+     * Returns the SkImage for a given frame.
+     *
+     * If the image asset is static, getFrame() is only called once, at animation load time.
+     * Otherwise, this gets invoked every time the animation time is adjusted (on every seek).
+     *
+     * Embedders should cache and serve the same SkImage whenever possible, for efficiency.
+     *
+     * @param t   Frame time code, in seconds, relative to the image layer timeline origin
+     *            (in-point).
+     */
+    virtual sk_sp<SkImage> getFrame(float t);
+
+    // Describes how the frame image is to be scaled to the animation-declared asset size.
+    enum class SizeFit {
+        // See SkMatrix::ScaleToFit
+        kFill   = SkMatrix::kFill_ScaleToFit,
+        kStart  = SkMatrix::kStart_ScaleToFit,
+        kCenter = SkMatrix::kCenter_ScaleToFit,
+        kEnd    = SkMatrix::kEnd_ScaleToFit,
+
+        // No scaling.
+        kNone,
+    };
+
+    struct FrameData {
+        // SkImage payload.
+        sk_sp<SkImage>    image;
+        // Resampling parameters.
+        SkSamplingOptions sampling;
+        // Additional image transform to be applied before AE scaling rules.
+        SkMatrix          matrix = SkMatrix::I();
+        // Strategy for image size -> AE asset size scaling.
+        SizeFit           scaling = SizeFit::kCenter;
+    };
+
+    /**
+     * Returns the payload for a given frame.
+     *
+     * If the image asset is static, getFrameData() is only called once, at animation load time.
+     * Otherwise, this gets invoked every time the animation time is adjusted (on every seek).
+     *
+     * Embedders should cache and serve the same SkImage whenever possible, for efficiency.
+     *
+     * @param t   Frame time code, in seconds, relative to the image layer timeline origin
+     *            (in-point).
+     */
+    virtual FrameData getFrameData(float t);
+};
+
+enum class ImageDecodeStrategy {
+    // Images are decoded on-the-fly, at rasterization time.
+    // Large images may cause jank as decoding is expensive (and can thrash internal caches).
+    kLazyDecode,
+    // Force-decode all images upfront, at the cost of potentially more RAM and slower
+    // animation build times.
+    kPreDecode,
+};
+
+class MultiFrameImageAsset final : public ImageAsset {
+public:
+    // Clients must call SkCodec::Register() to load the required decoding image codecs before
+    // calling Make. For example:
+    //     SkCodec::Register(SkPngDecoder::Decoder());
+    static sk_sp<MultiFrameImageAsset> Make(sk_sp<SkData>,
+                                            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode);
+    // If the client has already decoded the data, they can use this constructor.
+    static sk_sp<MultiFrameImageAsset> Make(std::unique_ptr<SkCodec>,
+                                            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode);
+
+
+    bool isMultiFrame() override;
+
+    sk_sp<SkImage> getFrame(float t) override;
+
+private:
+    explicit MultiFrameImageAsset(std::unique_ptr<SkAnimCodecPlayer>, ImageDecodeStrategy);
+
+    sk_sp<SkImage> generateFrame(float t);
+
+    std::unique_ptr<SkAnimCodecPlayer> fPlayer;
+    sk_sp<SkImage>                     fCachedFrame;
+    ImageDecodeStrategy fStrategy;
+
+    using INHERITED = ImageAsset;
+};
+
+/**
+ * External track (e.g. audio playback) interface.
+ *
+ * Used to wrap data payload and playback controllers.
+ */
+class ExternalTrackAsset : public SkRefCnt {
+public:
+    /**
+     * Playback control callback, emitted for each corresponding Animation::seek().
+     *
+     * @param t  Frame time code, in seconds, relative to the layer's timeline origin
+     *           (in-point).
+     *
+     * Negative |t| values are used to signal off state (stop playback outside layer span).
+     */
+    virtual void seek(float t) = 0;
+};
+
+/**
+ * ResourceProvider is an interface that lets rich-content modules defer loading of external
+ * resources (images, fonts, etc.) to embedding clients.
+ */
+class SK_API ResourceProvider : public SkRefCnt {
+public:
+    /**
+     * Load a generic resource (currently only nested animations) specified by |path| + |name|,
+     * and return as an SkData.
+     */
+    virtual sk_sp<SkData> load(const char[] /* resource_path */,
+                               const char[] /* resource_name */) const {
+        return nullptr;
+    }
+
+    /**
+     * Load an image asset specified by |path| + |name|, and returns the corresponding
+     * ImageAsset proxy.
+     */
+    virtual sk_sp<ImageAsset> loadImageAsset(const char[] /* resource_path */,
+                                             const char[] /* resource_name */,
+                                             const char[] /* resource_id   */) const {
+        return nullptr;
+    }
+
+    /**
+     * Load an external audio track specified by |path|/|name|/|id|.
+     */
+    virtual sk_sp<ExternalTrackAsset> loadAudioAsset(const char[] /* resource_path */,
+                                                     const char[] /* resource_name */,
+                                                     const char[] /* resource_id   */) {
+        return nullptr;
+    }
+
+    /**
+     * DEPRECATED: implement loadTypeface() instead.
+     *
+     * Load an external font and return as SkData.
+     *
+     * @param name  font name    ("fName" Lottie property)
+     * @param url   web font URL ("fPath" Lottie property)
+     *
+     * -- Note --
+     *
+     *   This mechanism assumes monolithic fonts (single data blob).  Some web font providers may
+     *   serve multiple font blobs, segmented for various unicode ranges, depending on user agent
+     *   capabilities (woff, woff2).  In that case, the embedder would need to advertise no user
+     *   agent capabilities when fetching the URL, in order to receive full font data.
+     */
+    virtual sk_sp<SkData> loadFont(const char[] /* name */,
+                                   const char[] /* url  */) const {
+        return nullptr;
+    }
+
+    /**
+     * Load an external font and return as SkTypeface.
+     *
+     * @param name  font name
+     * @param url   web font URL
+     */
+    virtual sk_sp<SkTypeface> loadTypeface(const char[] /* name */,
+                                           const char[] /* url  */) const {
+        return nullptr;
+    }
+};
+
+class FileResourceProvider final : public ResourceProvider {
+public:
+    // To decode images, clients must call SkCodecs::Register() before calling Make.
+    static sk_sp<FileResourceProvider> Make(SkString base_dir,
+                                            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode);
+
+    sk_sp<SkData> load(const char resource_path[], const char resource_name[]) const override;
+
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+
+private:
+    FileResourceProvider(SkString, ImageDecodeStrategy);
+
+    const SkString fDir;
+    const ImageDecodeStrategy fStrategy;
+
+    using INHERITED = ResourceProvider;
+};
+
+class ResourceProviderProxyBase : public ResourceProvider {
+protected:
+    explicit ResourceProviderProxyBase(sk_sp<ResourceProvider>);
+
+    sk_sp<SkData> load(const char[], const char[]) const override;
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+    sk_sp<SkTypeface> loadTypeface(const char[], const char[]) const override;
+    sk_sp<SkData> loadFont(const char[], const char[]) const override;
+    sk_sp<ExternalTrackAsset> loadAudioAsset(const char[], const char[], const char[]) override;
+
+protected:
+    const sk_sp<ResourceProvider> fProxy;
+};
+
+class SK_API CachingResourceProvider final : public ResourceProviderProxyBase {
+public:
+    static sk_sp<CachingResourceProvider> Make(sk_sp<ResourceProvider> rp) {
+        return rp ? sk_sp<CachingResourceProvider>(new CachingResourceProvider(std::move(rp)))
+                  : nullptr;
+    }
+
+private:
+    explicit CachingResourceProvider(sk_sp<ResourceProvider>);
+
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+
+    mutable SkMutex                                             fMutex;
+    mutable skia_private::THashMap<SkString, sk_sp<ImageAsset>> fImageCache;
+
+    using INHERITED = ResourceProviderProxyBase;
+};
+
+class SK_API DataURIResourceProviderProxy final : public ResourceProviderProxyBase {
+public:
+    // If font data is supplied via base64 encoding, this needs a provided SkFontMgr to process
+    // that font data into an SkTypeface. To decode images, clients must call SkCodecs::Register()
+    // before calling Make.
+    static sk_sp<DataURIResourceProviderProxy> Make(
+            sk_sp<ResourceProvider> rp,
+            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode,
+            sk_sp<const SkFontMgr> fontMgr = nullptr);
+
+private:
+    DataURIResourceProviderProxy(sk_sp<ResourceProvider>,
+                                 ImageDecodeStrategy,
+                                 sk_sp<const SkFontMgr> fontMgr);
+
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+    sk_sp<SkTypeface> loadTypeface(const char[], const char[]) const override;
+
+    const ImageDecodeStrategy fStrategy;
+    sk_sp<const SkFontMgr> fFontMgr;
+
+    using INHERITED = ResourceProviderProxyBase;
+};
+
+} // namespace skresources
+
+#endif // SkResources_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skresources/skresources.gni b/Source/ThirdParty/skia/modules/skresources/skresources.gni
new file mode 100644
index 00000000..e0ffe26e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/skresources.gni
@@ -0,0 +1,20 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/skresources/include/BUILD.bazel
+#   //modules/skresources/src/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# Generated by Bazel rule //modules/skresources/include:hdrs
+skia_skresources_public = [ "$_modules/skresources/include/SkResources.h" ]
+
+# Generated by Bazel rule //modules/skresources/src:srcs
+skia_skresources_sources = [
+  "$_modules/skresources/src/SkAnimCodecPlayer.cpp",
+  "$_modules/skresources/src/SkAnimCodecPlayer.h",
+  "$_modules/skresources/src/SkResources.cpp",
+]
diff --git a/Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel b/Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel
new file mode 100644
index 00000000..0ce58dc6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel
@@ -0,0 +1,17 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "srcs",
+    srcs = [
+        "SkAnimCodecPlayer.cpp",
+        "SkAnimCodecPlayer.h",
+        "SkResources.cpp",
+    ],
+    visibility = ["//modules/skresources:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp
new file mode 100644
index 00000000..f562caaf
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2018 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/skresources/src/SkAnimCodecPlayer.h"
+
+#include "include/codec/SkCodec.h"
+#include "include/codec/SkEncodedOrigin.h"
+#include "include/core/SkAlphaType.h"
+#include "include/core/SkBlendMode.h"
+#include "include/core/SkCanvas.h"
+#include "include/core/SkData.h"
+#include "include/core/SkImage.h"
+#include "include/core/SkImageInfo.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkPaint.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSamplingOptions.h"
+#include "include/core/SkSize.h"
+#include "include/core/SkTypes.h"
+#include "src/codec/SkCodecImageGenerator.h"
+
+#include <algorithm>
+#include <cstddef>
+#include <memory>
+#include <utility>
+#include <vector>
+
+SkAnimCodecPlayer::SkAnimCodecPlayer(std::unique_ptr<SkCodec> codec) : fCodec(std::move(codec)) {
+    fImageInfo = fCodec->getInfo();
+    fFrameInfos = fCodec->getFrameInfo();
+    fImages.resize(fFrameInfos.size());
+
+    // change the interpretation of fDuration to a end-time for that frame
+    size_t dur = 0;
+    for (auto& f : fFrameInfos) {
+        dur += f.fDuration;
+        f.fDuration = dur;
+    }
+    fTotalDuration = dur;
+
+    if (!fTotalDuration) {
+        // Static image -- may or may not have returned a single frame info.
+        fFrameInfos.clear();
+        fImages.clear();
+        fImages.push_back(SkImages::DeferredFromGenerator(
+                SkCodecImageGenerator::MakeFromCodec(std::move(fCodec))));
+    }
+}
+
+SkAnimCodecPlayer::~SkAnimCodecPlayer() {}
+
+SkISize SkAnimCodecPlayer::dimensions() const {
+    if (!fCodec) {
+        auto image = fImages.front();
+        return image ? image->dimensions() : SkISize::MakeEmpty();
+    }
+    if (SkEncodedOriginSwapsWidthHeight(fCodec->getOrigin())) {
+        return { fImageInfo.height(), fImageInfo.width() };
+    }
+    return { fImageInfo.width(), fImageInfo.height() };
+}
+
+sk_sp<SkImage> SkAnimCodecPlayer::getFrameAt(int index) {
+    SkASSERT((unsigned)index < fFrameInfos.size());
+
+    if (fImages[index]) {
+        return fImages[index];
+    }
+
+    size_t rb = fImageInfo.minRowBytes();
+    size_t size = fImageInfo.computeByteSize(rb);
+    auto data = SkData::MakeUninitialized(size);
+
+    SkCodec::Options opts;
+    opts.fFrameIndex = index;
+
+    const auto origin = fCodec->getOrigin();
+    const auto orientedDims = this->dimensions();
+    const auto originMatrix = SkEncodedOriginToMatrix(origin, orientedDims.width(),
+                                                              orientedDims.height());
+
+    SkPaint paint;
+    paint.setBlendMode(SkBlendMode::kSrc);
+
+    auto imageInfo = fImageInfo;
+    if (fFrameInfos[index].fAlphaType != kOpaque_SkAlphaType && imageInfo.isOpaque()) {
+        imageInfo = imageInfo.makeAlphaType(kPremul_SkAlphaType);
+    }
+    const int requiredFrame = fFrameInfos[index].fRequiredFrame;
+    if (requiredFrame != SkCodec::kNoFrame && fImages[requiredFrame]) {
+        auto requiredImage = fImages[requiredFrame];
+        auto canvas = SkCanvas::MakeRasterDirect(imageInfo, data->writable_data(), rb);
+        if (origin != kDefault_SkEncodedOrigin) {
+            // The required frame is stored after applying the origin. Undo that,
+            // because the codec decodes prior to applying the origin.
+            // FIXME: Another approach would be to decode the frame's delta on top
+            // of transparent black, and then draw that through the origin matrix
+            // onto the required frame. To do that, SkCodec needs to expose the
+            // rectangle of the delta and the blend mode, so we can handle
+            // kRestoreBGColor frames and Blend::kSrc.
+            SkMatrix inverse;
+            SkAssertResult(originMatrix.invert(&inverse));
+            canvas->concat(inverse);
+        }
+        canvas->drawImage(requiredImage, 0, 0, SkSamplingOptions(), &paint);
+        opts.fPriorFrame = requiredFrame;
+    }
+
+    if (SkCodec::kSuccess != fCodec->getPixels(imageInfo, data->writable_data(), rb, &opts)) {
+        return nullptr;
+    }
+
+    auto image = SkImages::RasterFromData(imageInfo, std::move(data), rb);
+    if (origin != kDefault_SkEncodedOrigin) {
+        imageInfo = imageInfo.makeDimensions(orientedDims);
+        rb = imageInfo.minRowBytes();
+        size = imageInfo.computeByteSize(rb);
+        data = SkData::MakeUninitialized(size);
+        auto canvas = SkCanvas::MakeRasterDirect(imageInfo, data->writable_data(), rb);
+        canvas->concat(originMatrix);
+        canvas->drawImage(image, 0, 0, SkSamplingOptions(), &paint);
+        image = SkImages::RasterFromData(imageInfo, std::move(data), rb);
+    }
+    return fImages[index] = image;
+}
+
+sk_sp<SkImage> SkAnimCodecPlayer::getFrame() {
+    SkASSERT(fTotalDuration > 0 || fImages.size() == 1);
+
+    return fTotalDuration > 0
+        ? this->getFrameAt(fCurrIndex)
+        : fImages.front();
+}
+
+bool SkAnimCodecPlayer::seek(uint32_t msec) {
+    if (!fTotalDuration) {
+        return false;
+    }
+
+    msec %= fTotalDuration;
+
+    auto lower = std::lower_bound(fFrameInfos.begin(), fFrameInfos.end(), msec,
+                                  [](const SkCodec::FrameInfo& info, uint32_t msec) {
+                                      return (uint32_t)info.fDuration <= msec;
+                                  });
+    int prevIndex = fCurrIndex;
+    fCurrIndex = lower - fFrameInfos.begin();
+    return fCurrIndex != prevIndex;
+}
+
+
diff --git a/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h
new file mode 100644
index 00000000..f4729aa3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2018 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkAnimCodecPlayer_DEFINED
+#define SkAnimCodecPlayer_DEFINED
+
+#include "include/codec/SkCodec.h"
+#include "include/core/SkImageInfo.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSize.h"
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+class SkImage;
+
+class SkAnimCodecPlayer {
+public:
+    SkAnimCodecPlayer(std::unique_ptr<SkCodec> codec);
+    ~SkAnimCodecPlayer();
+
+    /**
+     *  Returns the current frame of the animation. This defaults to the first frame for
+     *  animated codecs (i.e. msec = 0). Calling this multiple times (without calling seek())
+     *  will always return the same image object (or null if there was an error).
+     */
+    sk_sp<SkImage> getFrame();
+
+    /**
+     *  Return the size of the image(s) that will be returned by getFrame().
+     */
+    SkISize dimensions() const;
+
+    /**
+     *  Returns the total duration of the animation in milliseconds. Returns 0 for a single-frame
+     *  image.
+     */
+    uint32_t duration() const { return fTotalDuration; }
+
+    /**
+     *  Finds the closest frame associated with the time code (in milliseconds) and sets that
+     *  to be the current frame (call getFrame() to retrieve that image).
+     *  Returns true iff this call to seek() changed the "current frame" for the animation.
+     *  Thus if seek() returns false, then getFrame() will return the same image as it did
+     *  before this call to seek().
+     */
+    bool seek(uint32_t msec);
+
+
+private:
+    std::unique_ptr<SkCodec>        fCodec;
+    SkImageInfo                     fImageInfo;
+    std::vector<SkCodec::FrameInfo> fFrameInfos;
+    std::vector<sk_sp<SkImage> >    fImages;
+    int                             fCurrIndex = 0;
+    uint32_t                        fTotalDuration;
+
+    sk_sp<SkImage> getFrameAt(int index);
+};
+
+#endif
+
diff --git a/Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp b/Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp
new file mode 100644
index 00000000..166639df
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp
@@ -0,0 +1,337 @@
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/skresources/include/SkResources.h"
+
+#include "include/codec/SkCodec.h"
+#include "include/core/SkBitmap.h"
+#include "include/core/SkData.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkImage.h"
+#include "include/private/base/SkTPin.h"
+#include "modules/skresources/src/SkAnimCodecPlayer.h"
+#include "src/base/SkBase64.h"
+#include "src/core/SkOSFile.h"
+#include "src/utils/SkOSPath.h"
+
+#include <cmath>
+
+#if defined(HAVE_VIDEO_DECODER)
+    #include "experimental/ffmpeg/SkVideoDecoder.h"
+    #include "include/core/SkStream.h"
+#endif
+
+namespace skresources {
+namespace  {
+
+#if defined(HAVE_VIDEO_DECODER)
+
+class VideoAsset final : public ImageAsset {
+public:
+    static sk_sp<VideoAsset> Make(sk_sp<SkData> data) {
+        auto decoder = std::make_unique<SkVideoDecoder>();
+
+        if (!decoder->loadStream(SkMemoryStream::Make(std::move(data))) ||
+            decoder->duration() <= 0) {
+            return nullptr;
+        }
+
+        return sk_sp<VideoAsset>(new VideoAsset(std::move(decoder)));
+    }
+
+private:
+    explicit VideoAsset(std::unique_ptr<SkVideoDecoder> decoder)
+        : fDecoder(std::move(decoder)) {
+    }
+
+    bool isMultiFrame() override { return true; }
+
+    // Each frame has a presentation timestamp
+    //   => the timespan for frame N is [stamp_N .. stamp_N+1)
+    //   => we use a two-frame sliding window to track the current interval.
+    void advance() {
+        fWindow[0] = std::move(fWindow[1]);
+        fWindow[1].frame = fDecoder->nextImage(&fWindow[1].stamp);
+        fEof = !fWindow[1].frame;
+    }
+
+    sk_sp<SkImage> getFrame(float t_float) override {
+        const auto t = SkTPin(static_cast<double>(t_float), 0.0, fDecoder->duration());
+
+        if (t < fWindow[0].stamp) {
+            // seeking back requires a full rewind
+            fDecoder->rewind();
+            fWindow[0].stamp = fWindow[1].stamp = 0;
+            fEof = 0;
+        }
+
+        while (!fEof && t >= fWindow[1].stamp) {
+            this->advance();
+        }
+
+        SkASSERT(fWindow[0].stamp <= t && (fEof || t < fWindow[1].stamp));
+
+        return fWindow[0].frame;
+    }
+
+    const std::unique_ptr<SkVideoDecoder> fDecoder;
+
+    struct FrameRec {
+        sk_sp<SkImage> frame;
+        double         stamp = 0;
+    };
+
+    FrameRec fWindow[2];
+    bool     fEof = false;
+};
+
+#endif // defined(HAVE_VIDEO_DECODER)
+
+} // namespace
+
+sk_sp<SkImage> ImageAsset::getFrame(float t) {
+    return nullptr;
+}
+
+ImageAsset::FrameData ImageAsset::getFrameData(float t) {
+    // legacy behavior
+    return {
+        this->getFrame(t),
+        SkSamplingOptions(SkFilterMode::kLinear, SkMipmapMode::kNearest),
+        SkMatrix::I(),
+        SizeFit::kCenter,
+    };
+}
+
+sk_sp<MultiFrameImageAsset> MultiFrameImageAsset::Make(sk_sp<SkData> data, ImageDecodeStrategy strat) {
+    if (auto codec = SkCodec::MakeFromData(std::move(data))) {
+        return sk_sp<MultiFrameImageAsset>(new MultiFrameImageAsset(
+                std::make_unique<SkAnimCodecPlayer>(std::move(codec)), strat));
+    }
+
+    return nullptr;
+}
+
+sk_sp<MultiFrameImageAsset> MultiFrameImageAsset::Make(std::unique_ptr<SkCodec> codec, ImageDecodeStrategy strat) {
+    SkASSERT(codec);
+    return sk_sp<MultiFrameImageAsset>(new MultiFrameImageAsset(
+            std::make_unique<SkAnimCodecPlayer>(std::move(codec)), strat));
+}
+
+MultiFrameImageAsset::MultiFrameImageAsset(std::unique_ptr<SkAnimCodecPlayer> player,
+                                           ImageDecodeStrategy strat)
+        : fPlayer(std::move(player)), fStrategy(strat) {
+    SkASSERT(fPlayer);
+}
+
+bool MultiFrameImageAsset::isMultiFrame() {
+    return fPlayer->duration() > 0;
+}
+
+sk_sp<SkImage> MultiFrameImageAsset::generateFrame(float t) {
+    auto decode = [](sk_sp<SkImage> image) {
+        SkASSERT(image->isLazyGenerated());
+
+        static constexpr size_t kMaxArea = 2048 * 2048;
+        const auto image_area = SkToSizeT(image->width() * image->height());
+
+        if (image_area > kMaxArea) {
+            // When the image is too large, decode and scale down to a reasonable size.
+            const auto scale = std::sqrt(static_cast<float>(kMaxArea) / image_area);
+            const auto info  = SkImageInfo::MakeN32Premul(scale * image->width(),
+                                                          scale * image->height());
+            SkBitmap bm;
+            if (bm.tryAllocPixels(info, info.minRowBytes()) &&
+                    image->scalePixels(bm.pixmap(),
+                                       SkSamplingOptions(SkFilterMode::kLinear,
+                                                         SkMipmapMode::kNearest),
+                                       SkImage::kDisallow_CachingHint)) {
+                image = bm.asImage();
+            }
+        } else {
+            // When the image size is OK, just force-decode.
+            image = image->makeRasterImage();
+        }
+
+        return image;
+    };
+
+    fPlayer->seek(static_cast<uint32_t>(t * 1000));
+    auto frame = fPlayer->getFrame();
+
+    if (fStrategy == ImageDecodeStrategy::kPreDecode && frame && frame->isLazyGenerated()) {
+        // The multi-frame decoder should never return lazy images.
+        SkASSERT(!this->isMultiFrame());
+        frame = decode(std::move(frame));
+    }
+
+    return frame;
+}
+
+sk_sp<SkImage> MultiFrameImageAsset::getFrame(float t) {
+    // For static images we can reuse the cached frame
+    // (which includes the optional pre-decode step).
+    if (!fCachedFrame || this->isMultiFrame()) {
+        fCachedFrame = this->generateFrame(t);
+    }
+
+    return fCachedFrame;
+}
+
+sk_sp<FileResourceProvider> FileResourceProvider::Make(SkString base_dir, ImageDecodeStrategy strat) {
+    return sk_isdir(base_dir.c_str()) ? sk_sp<FileResourceProvider>(new FileResourceProvider(
+                                                std::move(base_dir), strat))
+                                      : nullptr;
+}
+
+FileResourceProvider::FileResourceProvider(SkString base_dir, ImageDecodeStrategy strat)
+        : fDir(std::move(base_dir)), fStrategy(strat) {}
+
+sk_sp<SkData> FileResourceProvider::load(const char resource_path[],
+                                         const char resource_name[]) const {
+    const auto full_dir  = SkOSPath::Join(fDir.c_str()    , resource_path),
+               full_path = SkOSPath::Join(full_dir.c_str(), resource_name);
+    return SkData::MakeFromFileName(full_path.c_str());
+}
+
+sk_sp<ImageAsset> FileResourceProvider::loadImageAsset(const char resource_path[],
+                                                       const char resource_name[],
+                                                       const char[]) const {
+    auto data = this->load(resource_path, resource_name);
+
+    if (auto image = MultiFrameImageAsset::Make(data, fStrategy)) {
+        return std::move(image);
+    }
+
+#if defined(HAVE_VIDEO_DECODER)
+    if (auto video = VideoAsset::Make(data)) {
+        return std::move(video);
+    }
+#endif
+
+    return nullptr;
+}
+
+ResourceProviderProxyBase::ResourceProviderProxyBase(sk_sp<ResourceProvider> rp)
+    : fProxy(std::move(rp)) {}
+
+sk_sp<SkData> ResourceProviderProxyBase::load(const char resource_path[],
+                                              const char resource_name[]) const {
+    return fProxy ? fProxy->load(resource_path, resource_name)
+                  : nullptr;
+}
+
+sk_sp<ImageAsset> ResourceProviderProxyBase::loadImageAsset(const char rpath[],
+                                                            const char rname[],
+                                                            const char rid[]) const {
+    return fProxy ? fProxy->loadImageAsset(rpath, rname, rid)
+                  : nullptr;
+}
+
+sk_sp<SkTypeface> ResourceProviderProxyBase::loadTypeface(const char name[],
+                                                          const char url[]) const {
+    return fProxy ? fProxy->loadTypeface(name, url)
+                  : nullptr;
+}
+
+sk_sp<SkData> ResourceProviderProxyBase::loadFont(const char name[], const char url[]) const {
+    return fProxy ? fProxy->loadFont(name, url)
+                  : nullptr;
+}
+
+sk_sp<ExternalTrackAsset> ResourceProviderProxyBase::loadAudioAsset(const char path[],
+                                                                    const char name[],
+                                                                    const char id[]) {
+    return fProxy ? fProxy->loadAudioAsset(path, name, id)
+                  : nullptr;
+}
+
+CachingResourceProvider::CachingResourceProvider(sk_sp<ResourceProvider> rp)
+    : INHERITED(std::move(rp)) {}
+
+sk_sp<ImageAsset> CachingResourceProvider::loadImageAsset(const char resource_path[],
+                                                          const char resource_name[],
+                                                          const char resource_id[]) const {
+    SkAutoMutexExclusive amx(fMutex);
+
+    const SkString key(resource_id);
+    if (const auto* asset = fImageCache.find(key)) {
+        return *asset;
+    }
+
+    auto asset = this->INHERITED::loadImageAsset(resource_path, resource_name, resource_id);
+    fImageCache.set(key, asset);
+
+    return asset;
+}
+
+sk_sp<DataURIResourceProviderProxy> DataURIResourceProviderProxy::Make(sk_sp<ResourceProvider> rp,
+                                                                       ImageDecodeStrategy strat,
+                                                                       sk_sp<const SkFontMgr> mgr) {
+    return sk_sp<DataURIResourceProviderProxy>(
+            new DataURIResourceProviderProxy(std::move(rp), strat, std::move(mgr)));
+}
+
+DataURIResourceProviderProxy::DataURIResourceProviderProxy(sk_sp<ResourceProvider> rp,
+                                                           ImageDecodeStrategy strat,
+                                                           sk_sp<const SkFontMgr> mgr)
+        : INHERITED(std::move(rp)), fStrategy(strat), fFontMgr(std::move(mgr)) {}
+
+static sk_sp<SkData> decode_datauri(const char prefix[], const char uri[]) {
+    // We only handle B64 encoded image dataURIs: data:image/<type>;base64,<data>
+    // (https://en.wikipedia.org/wiki/Data_URI_scheme)
+    static constexpr char kDataURIEncodingStr[] = ";base64,";
+
+    const size_t prefixLen = strlen(prefix);
+    if (strncmp(uri, prefix, prefixLen) != 0) {
+        return nullptr;
+    }
+
+    const char* encoding = strstr(uri + prefixLen, kDataURIEncodingStr);
+    if (!encoding) {
+        return nullptr;
+    }
+
+    const char* b64Data = encoding + std::size(kDataURIEncodingStr) - 1;
+    size_t b64DataLen = strlen(b64Data);
+    size_t dataLen;
+    if (SkBase64::Decode(b64Data, b64DataLen, nullptr, &dataLen) != SkBase64::kNoError) {
+        return nullptr;
+    }
+
+    sk_sp<SkData> data = SkData::MakeUninitialized(dataLen);
+    void* rawData = data->writable_data();
+    if (SkBase64::Decode(b64Data, b64DataLen, rawData, &dataLen) != SkBase64::kNoError) {
+        return nullptr;
+    }
+
+    return data;
+}
+
+sk_sp<ImageAsset> DataURIResourceProviderProxy::loadImageAsset(const char rpath[],
+                                                               const char rname[],
+                                                               const char rid[]) const {
+    // First try to decode the data as base64 using codecs registered with SkCodecs::Register()
+    if (auto data = decode_datauri("data:image/", rname)) {
+        return MultiFrameImageAsset::Make(std::move(data), fStrategy);
+    }
+    // Fallback to the asking the ProviderProxy to load this image for us.
+    return this->INHERITED::loadImageAsset(rpath, rname, rid);
+}
+
+sk_sp<SkTypeface> DataURIResourceProviderProxy::loadTypeface(const char name[],
+                                                             const char url[]) const {
+    if (fFontMgr) {
+        if (auto data = decode_datauri("data:font/", url)) {
+            return fFontMgr->makeFromData(std::move(data));
+        }
+    }
+
+    return this->INHERITED::loadTypeface(name, url);
+}
+
+} // namespace skresources
diff --git a/Source/ThirdParty/skia/modules/svg/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/BUILD.bazel
new file mode 100644
index 00000000..c5bcb0a1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/BUILD.bazel
@@ -0,0 +1,29 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "svg_renderer",
+    srcs = [
+        "//modules/svg/src:private_hdrs",
+        "//modules/svg/src:srcs",
+    ],
+    hdrs = ["//modules/svg/include:public_hdrs"],
+    features = ["layering_check"],
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//:core",
+        "//:jpeg_decode_codec",
+        "//:pathops",
+        "//:png_decode_codec",
+        "//modules/skresources",
+        "//modules/skshaper:skshaper_core",
+        "//src/base",
+        "//src/core:core_priv",
+        "//src/xml",
+    ],
+)
diff --git a/Source/ThirdParty/skia/modules/svg/BUILD.gn b/Source/ThirdParty/skia/modules/svg/BUILD.gn
new file mode 100644
index 00000000..b0fee5da
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/BUILD.gn
@@ -0,0 +1,70 @@
+# Copyright 2020 Google Inc.
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+
+if (skia_enable_svg && skia_use_expat) {
+  config("public_config") {
+    defines = [ "SK_ENABLE_SVG" ]
+    include_dirs = [ "include" ]
+  }
+
+  skia_component("svg") {
+    check_includes = false
+    import("svg.gni")
+    public_configs = [ ":public_config" ]
+    public = skia_svg_public
+    sources = skia_svg_sources
+    configs = [ "../../:skia_private" ]
+    deps = [
+      "../..:skia",
+      "../skresources",
+      "../skshaper",
+      "../skunicode",
+    ]
+  }
+
+  if (skia_enable_tools) {
+    if (defined(is_skia_standalone)) {
+      skia_source_set("tool") {
+        check_includes = false
+        testonly = true
+
+        configs = [ "../..:skia_private" ]
+        sources = [ "utils/SvgTool.cpp" ]
+
+        deps = [
+          "../..:flags",
+          "../..:skia",
+          "../..:tool_utils",
+        ]
+
+        public_deps = [ ":svg" ]
+      }
+    }
+
+    skia_source_set("tests") {
+      testonly = true
+
+      configs = [ "../..:skia_private" ]
+      sources = [
+        "tests/Filters.cpp",
+        "tests/Text.cpp",
+      ]
+
+      deps = [
+        ":svg",
+        "../..:skia",
+        "../..:test",
+        "../skshaper",
+      ]
+    }
+  }
+} else {
+  group("svg") {
+  }
+  group("tests") {
+  }
+}
diff --git a/Source/ThirdParty/skia/modules/svg/include/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/include/BUILD.bazel
new file mode 100644
index 00000000..bb19778e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/BUILD.bazel
@@ -0,0 +1,64 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+# This group is exported as //modules/svg/svg.gni:skia_svg_public
+skia_filegroup(
+    name = "public_hdrs",
+    srcs = [
+        "SkSVGAttribute.h",
+        "SkSVGAttributeParser.h",
+        "SkSVGCircle.h",
+        "SkSVGClipPath.h",
+        "SkSVGContainer.h",
+        "SkSVGDOM.h",
+        "SkSVGDefs.h",
+        "SkSVGEllipse.h",
+        "SkSVGFe.h",
+        "SkSVGFeBlend.h",
+        "SkSVGFeColorMatrix.h",
+        "SkSVGFeComponentTransfer.h",
+        "SkSVGFeComposite.h",
+        "SkSVGFeDisplacementMap.h",
+        "SkSVGFeFlood.h",
+        "SkSVGFeGaussianBlur.h",
+        "SkSVGFeImage.h",
+        "SkSVGFeLightSource.h",
+        "SkSVGFeLighting.h",
+        "SkSVGFeMerge.h",
+        "SkSVGFeMorphology.h",
+        "SkSVGFeOffset.h",
+        "SkSVGFeTurbulence.h",
+        "SkSVGFilter.h",
+        "SkSVGFilterContext.h",
+        "SkSVGG.h",
+        "SkSVGGradient.h",
+        "SkSVGHiddenContainer.h",
+        "SkSVGIDMapper.h",
+        "SkSVGImage.h",
+        "SkSVGLine.h",
+        "SkSVGLinearGradient.h",
+        "SkSVGMask.h",
+        "SkSVGNode.h",
+        "SkSVGOpenTypeSVGDecoder.h",
+        "SkSVGPath.h",
+        "SkSVGPattern.h",
+        "SkSVGPoly.h",
+        "SkSVGRadialGradient.h",
+        "SkSVGRect.h",
+        "SkSVGRenderContext.h",
+        "SkSVGSVG.h",
+        "SkSVGShape.h",
+        "SkSVGStop.h",
+        "SkSVGText.h",
+        "SkSVGTransformableNode.h",
+        "SkSVGTypes.h",
+        "SkSVGUse.h",
+        "SkSVGValue.h",
+    ],
+    visibility = ["//modules/svg:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h
new file mode 100644
index 00000000..8e4d56ca
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGAttribute_DEFINED
+#define SkSVGAttribute_DEFINED
+
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkTLazy.h"
+
+class SkSVGRenderContext;
+
+enum class SkSVGAttribute {
+    kClipRule,
+    kColor,
+    kColorInterpolation,
+    kColorInterpolationFilters,
+    kCx, // <circle>, <ellipse>, <radialGradient>: center x position
+    kCy, // <circle>, <ellipse>, <radialGradient>: center y position
+    kFill,
+    kFillOpacity,
+    kFillRule,
+    kFilter,
+    kFilterUnits,
+    kFontFamily,
+    kFontSize,
+    kFontStyle,
+    kFontWeight,
+    kFx, // <radialGradient>: focal point x position
+    kFy, // <radialGradient>: focal point y position
+    kGradientUnits,
+    kGradientTransform,
+    kHeight,
+    kHref,
+    kOpacity,
+    kPoints,
+    kPreserveAspectRatio,
+    kR,  // <circle>, <radialGradient>: radius
+    kRx, // <ellipse>,<rect>: horizontal (corner) radius
+    kRy, // <ellipse>,<rect>: vertical (corner) radius
+    kSpreadMethod,
+    kStroke,
+    kStrokeDashArray,
+    kStrokeDashOffset,
+    kStrokeOpacity,
+    kStrokeLineCap,
+    kStrokeLineJoin,
+    kStrokeMiterLimit,
+    kStrokeWidth,
+    kTransform,
+    kText,
+    kTextAnchor,
+    kViewBox,
+    kVisibility,
+    kWidth,
+    kX,
+    kX1, // <line>: first endpoint x
+    kX2, // <line>: second endpoint x
+    kY,
+    kY1, // <line>: first endpoint y
+    kY2, // <line>: second endpoint y
+
+    kUnknown,
+};
+
+struct SkSVGPresentationAttributes {
+    static SkSVGPresentationAttributes MakeInitial();
+
+    // TODO: SkSVGProperty adds an extra ptr per attribute; refactor to reduce overhead.
+
+    SkSVGProperty<SkSVGPaint     , true> fFill;
+    SkSVGProperty<SkSVGNumberType, true> fFillOpacity;
+    SkSVGProperty<SkSVGFillRule  , true> fFillRule;
+    SkSVGProperty<SkSVGFillRule  , true> fClipRule;
+
+    SkSVGProperty<SkSVGPaint     , true> fStroke;
+    SkSVGProperty<SkSVGDashArray , true> fStrokeDashArray;
+    SkSVGProperty<SkSVGLength    , true> fStrokeDashOffset;
+    SkSVGProperty<SkSVGLineCap   , true> fStrokeLineCap;
+    SkSVGProperty<SkSVGLineJoin  , true> fStrokeLineJoin;
+    SkSVGProperty<SkSVGNumberType, true> fStrokeMiterLimit;
+    SkSVGProperty<SkSVGNumberType, true> fStrokeOpacity;
+    SkSVGProperty<SkSVGLength    , true> fStrokeWidth;
+
+    SkSVGProperty<SkSVGVisibility, true> fVisibility;
+
+    SkSVGProperty<SkSVGColorType , true> fColor;
+    SkSVGProperty<SkSVGColorspace, true> fColorInterpolation;
+    SkSVGProperty<SkSVGColorspace, true> fColorInterpolationFilters;
+
+    SkSVGProperty<SkSVGFontFamily, true> fFontFamily;
+    SkSVGProperty<SkSVGFontStyle , true> fFontStyle;
+    SkSVGProperty<SkSVGFontSize  , true> fFontSize;
+    SkSVGProperty<SkSVGFontWeight, true> fFontWeight;
+    SkSVGProperty<SkSVGTextAnchor, true> fTextAnchor;
+
+    // uninherited
+    SkSVGProperty<SkSVGNumberType, false> fOpacity;
+    SkSVGProperty<SkSVGFuncIRI   , false> fClipPath;
+    SkSVGProperty<SkSVGDisplay   , false> fDisplay;
+    SkSVGProperty<SkSVGFuncIRI   , false> fMask;
+    SkSVGProperty<SkSVGFuncIRI   , false> fFilter;
+    SkSVGProperty<SkSVGColor     , false> fStopColor;
+    SkSVGProperty<SkSVGNumberType, false> fStopOpacity;
+    SkSVGProperty<SkSVGColor     , false> fFloodColor;
+    SkSVGProperty<SkSVGNumberType, false> fFloodOpacity;
+    SkSVGProperty<SkSVGColor     , false> fLightingColor;
+};
+
+#endif // SkSVGAttribute_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h
new file mode 100644
index 00000000..ce66852e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGAttributeParser_DEFINED
+#define SkSVGAttributeParser_DEFINED
+
+#include <vector>
+
+#include "include/private/base/SkNoncopyable.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkTLazy.h"
+
+class SkSVGAttributeParser : public SkNoncopyable {
+public:
+    SkSVGAttributeParser(const char[]);
+
+    bool parseInteger(SkSVGIntegerType*);
+    bool parseViewBox(SkSVGViewBoxType*);
+    bool parsePreserveAspectRatio(SkSVGPreserveAspectRatio*);
+
+    // TODO: Migrate all parse*() functions to this style (and delete the old version)
+    //      so they can be used by parse<T>():
+    bool parse(SkSVGIntegerType* v) { return parseInteger(v); }
+
+    template <typename T> using ParseResult = SkTLazy<T>;
+
+    template <typename T> static ParseResult<T> parse(const char* value) {
+        ParseResult<T> result;
+        T parsedValue;
+        if (SkSVGAttributeParser(value).parse(&parsedValue)) {
+            result.set(std::move(parsedValue));
+        }
+        return result;
+    }
+
+    template <typename T>
+    static ParseResult<T> parse(const char* expectedName,
+                                const char* name,
+                                const char* value) {
+        if (!strcmp(name, expectedName)) {
+            return parse<T>(value);
+        }
+
+        return ParseResult<T>();
+    }
+
+    template <typename PropertyT>
+    static ParseResult<PropertyT> parseProperty(const char* expectedName,
+                                                const char* name,
+                                                const char* value) {
+        if (strcmp(name, expectedName) != 0) {
+            return ParseResult<PropertyT>();
+        }
+
+        if (!strcmp(value, "inherit")) {
+            PropertyT result(SkSVGPropertyState::kInherit);
+            return ParseResult<PropertyT>(&result);
+        }
+
+        auto pr = parse<typename PropertyT::ValueT>(value);
+        if (pr.isValid()) {
+            PropertyT result(*pr);
+            return ParseResult<PropertyT>(&result);
+        }
+
+        return ParseResult<PropertyT>();
+    }
+
+private:
+    class RestoreCurPos {
+    public:
+        explicit RestoreCurPos(SkSVGAttributeParser* self)
+            : fSelf(self), fCurPos(self->fCurPos) {}
+
+        ~RestoreCurPos() {
+            if (fSelf) {
+                fSelf->fCurPos = this->fCurPos;
+            }
+        }
+
+        void clear() { fSelf = nullptr; }
+    private:
+        SkSVGAttributeParser* fSelf;
+        const char* fCurPos;
+
+        RestoreCurPos(           const RestoreCurPos&) = delete;
+        RestoreCurPos& operator=(const RestoreCurPos&) = delete;
+    };
+
+    // Stack-only
+    void* operator new(size_t) = delete;
+    void* operator new(size_t, void*) = delete;
+
+    template <typename T>
+    bool parse(T*);
+
+    template <typename F>
+    bool advanceWhile(F func);
+
+    bool matchStringToken(const char* token, const char** newPos = nullptr) const;
+    bool matchHexToken(const char** newPos) const;
+
+    bool parseWSToken();
+    bool parseEOSToken();
+    bool parseSepToken();
+    bool parseCommaWspToken();
+    bool parseExpectedStringToken(const char*);
+    bool parseScalarToken(SkScalar*);
+    bool parseInt32Token(int32_t*);
+    bool parseEscape(SkUnichar*);
+    bool parseIdentToken(SkString*);
+    bool parseLengthUnitToken(SkSVGLength::Unit*);
+    bool parseNamedColorToken(SkColor*);
+    bool parseHexColorToken(SkColor*);
+    bool parseColorComponentScalarToken(int32_t*);
+    bool parseColorComponentIntegralToken(int32_t*);
+    bool parseColorComponentFractionalToken(int32_t*);
+    bool parseColorComponentToken(int32_t*);
+    bool parseColorToken(SkColor*);
+    bool parseRGBColorToken(SkColor*);
+    bool parseRGBAColorToken(SkColor*);
+    bool parseSVGColor(SkSVGColor*, SkSVGColor::Vars&&);
+    bool parseSVGColorType(SkSVGColorType*);
+    bool parseFuncIRI(SkSVGFuncIRI*);
+
+    // Transform helpers
+    bool parseMatrixToken(SkMatrix*);
+    bool parseTranslateToken(SkMatrix*);
+    bool parseScaleToken(SkMatrix*);
+    bool parseRotateToken(SkMatrix*);
+    bool parseSkewXToken(SkMatrix*);
+    bool parseSkewYToken(SkMatrix*);
+
+    // Parses a sequence of 'WS* <prefix> WS* (<nested>)', where the nested sequence
+    // is handled by the passed functor.
+    template <typename Func, typename T>
+    bool parseParenthesized(const char* prefix, Func, T* result);
+
+    template <typename T>
+    bool parseList(std::vector<T>*);
+
+    template <typename T, typename TArray>
+    bool parseEnumMap(const TArray& arr, T* result) {
+        for (size_t i = 0; i < std::size(arr); ++i) {
+            if (this->parseExpectedStringToken(std::get<0>(arr[i]))) {
+                *result = std::get<1>(arr[i]);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // The current position in the input string.
+    const char* fCurPos;
+    const char* fEndPos;
+
+    using INHERITED = SkNoncopyable;
+};
+
+#endif // SkSVGAttributeParser_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h
new file mode 100644
index 00000000..83683b8b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGCircle_DEFINED
+#define SkSVGCircle_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+struct SkPoint;
+
+class SK_API SkSVGCircle final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGCircle> Make() { return sk_sp<SkSVGCircle>(new SkSVGCircle()); }
+
+    SVG_ATTR(Cx, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Cy, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(R , SkSVGLength, SkSVGLength(0))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGCircle();
+
+    // resolve and return the center and radius values
+    std::tuple<SkPoint, SkScalar> resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGCircle_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h
new file mode 100644
index 00000000..a981b879
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGClipPath_DEFINED
+#define SkSVGClipPath_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGClipPath final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGClipPath> Make() {
+        return sk_sp<SkSVGClipPath>(new SkSVGClipPath());
+    }
+
+    SVG_ATTR(ClipPathUnits, SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse))
+
+private:
+    friend class SkSVGRenderContext;
+
+    SkSVGClipPath();
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    SkPath resolveClip(const SkSVGRenderContext&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGClipPath_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h
new file mode 100644
index 00000000..9449cd22
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGContainer_DEFINED
+#define SkSVGContainer_DEFINED
+
+#include "include/private/base/SkTArray.h"
+#include "modules/svg/include/SkSVGTransformableNode.h"
+
+class SK_API SkSVGContainer : public SkSVGTransformableNode {
+public:
+    void appendChild(sk_sp<SkSVGNode>) override;
+
+protected:
+    explicit SkSVGContainer(SkSVGTag);
+
+    void onRender(const SkSVGRenderContext&) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+    bool hasChildren() const final;
+
+    template <typename NodeType, typename Func>
+    void forEachChild(Func func) const {
+        for (const auto& child : fChildren) {
+            if (child->tag() == NodeType::tag) {
+                func(static_cast<const NodeType*>(child.get()));
+            }
+        }
+    }
+
+    // TODO: convert remaining direct users to iterators, and make the container private.
+    skia_private::STArray<1, sk_sp<SkSVGNode>, true> fChildren;
+
+private:
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif // SkSVGContainer_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h
new file mode 100644
index 00000000..87fc347e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGDOM_DEFINED
+#define SkSVGDOM_DEFINED
+
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSize.h"
+#include "include/private/base/SkTemplates.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+#include "modules/svg/include/SkSVGIDMapper.h"
+
+class SkCanvas;
+class SkDOM;
+class SkStream;
+class SkSVGNode;
+struct SkSVGPresentationContext;
+class SkSVGSVG;
+
+class SK_API SkSVGDOM : public SkRefCnt {
+public:
+    class Builder final {
+    public:
+        /**
+         * Specify a font manager for loading fonts (e.g. from the system) to render <text>
+         * SVG nodes.
+         * If this is not set, but a font is required as part of rendering, the text will
+         * not be displayed.
+         */
+        Builder& setFontManager(sk_sp<SkFontMgr>);
+
+        /**
+         * Specify a resource provider for loading images etc.
+         */
+        Builder& setResourceProvider(sk_sp<skresources::ResourceProvider>);
+
+        /**
+         * Specify the callbacks for dealing with shaping text. See also
+         * modules/skshaper/utils/FactoryHelpers.h
+         */
+        Builder& setTextShapingFactory(sk_sp<SkShapers::Factory>);
+
+        sk_sp<SkSVGDOM> make(SkStream&) const;
+
+    private:
+        sk_sp<SkFontMgr>                             fFontMgr;
+        sk_sp<skresources::ResourceProvider>         fResourceProvider;
+        sk_sp<SkShapers::Factory>                    fTextShapingFactory;
+    };
+
+    static sk_sp<SkSVGDOM> MakeFromStream(SkStream& str) {
+        return Builder().make(str);
+    }
+
+    /**
+     * Returns the root (outermost) SVG element.
+     */
+    SkSVGSVG* getRoot() const { return fRoot.get(); }
+
+    /**
+     * Specify a "container size" for the SVG dom.
+     *
+     * This is used to resolve the initial viewport when the root SVG width/height are specified
+     * in relative units.
+     *
+     * If the root dimensions are in absolute units, then the container size has no effect since
+     * the initial viewport is fixed.
+     */
+    void setContainerSize(const SkSize&);
+
+    /**
+     * DEPRECATED: use getRoot()->intrinsicSize() to query the root element intrinsic size.
+     *
+     * Returns the SVG dom container size.
+     *
+     * If the client specified a container size via setContainerSize(), then the same size is
+     * returned.
+     *
+     * When unspecified by clients, this returns the intrinsic size of the root element, as defined
+     * by its width/height attributes.  If either width or height is specified in relative units
+     * (e.g. "100%"), then the corresponding intrinsic size dimension is zero.
+     */
+    const SkSize& containerSize() const;
+
+    // Returns the node with the given id, or nullptr if not found.
+    sk_sp<SkSVGNode>* findNodeById(const char* id);
+
+    void render(SkCanvas*) const;
+
+    /** Render the node with the given id as if it were the only child of the root. */
+    void renderNode(SkCanvas*, SkSVGPresentationContext&, const char* id) const;
+
+private:
+    SkSVGDOM(sk_sp<SkSVGSVG>,
+             sk_sp<SkFontMgr>,
+             sk_sp<skresources::ResourceProvider>,
+             SkSVGIDMapper&&,
+             sk_sp<SkShapers::Factory>);
+
+    const sk_sp<SkSVGSVG>                       fRoot;
+    const sk_sp<SkFontMgr>                      fFontMgr;
+    const sk_sp<SkShapers::Factory>             fTextShapingFactory;
+    const sk_sp<skresources::ResourceProvider>  fResourceProvider;
+    const SkSVGIDMapper                         fIDMapper;
+    SkSize                                      fContainerSize;
+};
+
+#endif // SkSVGDOM_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h
new file mode 100644
index 00000000..0e63b0fc
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGDefs_DEFINED
+#define SkSVGDefs_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+
+class SK_API SkSVGDefs : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGDefs> Make() { return sk_sp<SkSVGDefs>(new SkSVGDefs()); }
+
+private:
+    SkSVGDefs() : INHERITED(SkSVGTag::kDefs) {}
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGDefs_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h
new file mode 100644
index 00000000..eb2eb513
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGEllipse_DEFINED
+#define SkSVGEllipse_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+struct SkRect;
+
+class SK_API SkSVGEllipse final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGEllipse> Make() { return sk_sp<SkSVGEllipse>(new SkSVGEllipse()); }
+
+    SVG_ATTR(Cx, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Cy, SkSVGLength, SkSVGLength(0))
+
+    SVG_OPTIONAL_ATTR(Rx, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Ry, SkSVGLength)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGEllipse();
+
+    SkRect resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGEllipse_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h
new file mode 100644
index 00000000..ba0e3300
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFe_DEFINED
+#define SkSVGFe_DEFINED
+
+#include <vector>
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+
+class SkImageFilter;
+class SkSVGFilterContext;
+
+class SK_API SkSVGFe : public SkSVGHiddenContainer {
+public:
+    static bool IsFilterEffect(const sk_sp<SkSVGNode>& node) {
+        switch (node->tag()) {
+            case SkSVGTag::kFeBlend:
+            case SkSVGTag::kFeColorMatrix:
+            case SkSVGTag::kFeComponentTransfer:
+            case SkSVGTag::kFeComposite:
+            case SkSVGTag::kFeDiffuseLighting:
+            case SkSVGTag::kFeDisplacementMap:
+            case SkSVGTag::kFeFlood:
+            case SkSVGTag::kFeGaussianBlur:
+            case SkSVGTag::kFeImage:
+            case SkSVGTag::kFeMerge:
+            case SkSVGTag::kFeMorphology:
+            case SkSVGTag::kFeOffset:
+            case SkSVGTag::kFeSpecularLighting:
+            case SkSVGTag::kFeTurbulence:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    sk_sp<SkImageFilter> makeImageFilter(const SkSVGRenderContext& ctx,
+                                         const SkSVGFilterContext& fctx) const;
+
+    // https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveSubRegion
+    SkRect resolveFilterSubregion(const SkSVGRenderContext&, const SkSVGFilterContext&) const;
+
+    /**
+     * Resolves the colorspace within which this filter effect should be applied.
+     * Spec: https://www.w3.org/TR/SVG11/painting.html#ColorInterpolationProperties
+     * 'color-interpolation-filters' property.
+     */
+    virtual SkSVGColorspace resolveColorspace(const SkSVGRenderContext&,
+                                              const SkSVGFilterContext&) const;
+
+    /** Propagates any inherited presentation attributes in the given context. */
+    void applyProperties(SkSVGRenderContext*) const;
+
+    SVG_ATTR(In, SkSVGFeInputType, SkSVGFeInputType())
+    SVG_ATTR(Result, SkSVGStringType, SkSVGStringType())
+    SVG_OPTIONAL_ATTR(X, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Y, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Width, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Height, SkSVGLength)
+
+protected:
+    explicit SkSVGFe(SkSVGTag t) : INHERITED(t) {}
+
+    virtual sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                                   const SkSVGFilterContext&) const = 0;
+
+    virtual std::vector<SkSVGFeInputType> getInputs() const = 0;
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    /**
+     * Resolves the rect specified by the x, y, width and height attributes (if specified) on this
+     * filter effect. These attributes are resolved according to the given length context and
+     * the value of 'primitiveUnits' on the parent <filter> element.
+     */
+    SkRect resolveBoundaries(const SkSVGRenderContext&, const SkSVGFilterContext&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif  // SkSVGFe_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h
new file mode 100644
index 00000000..414a9559
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeBlend_DEFINED
+#define SkSVGFeBlend_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeBlend : public SkSVGFe {
+public:
+    enum class Mode {
+        kNormal,
+        kMultiply,
+        kScreen,
+        kDarken,
+        kLighten,
+    };
+
+    static sk_sp<SkSVGFeBlend> Make() { return sk_sp<SkSVGFeBlend>(new SkSVGFeBlend()); }
+
+    SVG_ATTR(Mode, Mode, Mode::kNormal)
+    SVG_ATTR(In2, SkSVGFeInputType, SkSVGFeInputType())
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override {
+        return {this->getIn(), this->getIn2()};
+    }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeBlend() : INHERITED(SkSVGTag::kFeBlend) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeBlend_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h
new file mode 100644
index 00000000..908a6bfb
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeColorMatrix_DEFINED
+#define SkSVGFeColorMatrix_DEFINED
+
+#include "include/effects/SkColorMatrix.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeColorMatrix final : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeColorMatrix> Make() {
+        return sk_sp<SkSVGFeColorMatrix>(new SkSVGFeColorMatrix());
+    }
+
+    SVG_ATTR(Type, SkSVGFeColorMatrixType, SkSVGFeColorMatrixType(SkSVGFeColorMatrixType::kMatrix))
+    SVG_ATTR(Values, SkSVGFeColorMatrixValues, SkSVGFeColorMatrixValues())
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeColorMatrix() : INHERITED(SkSVGTag::kFeColorMatrix) {}
+
+    SkColorMatrix makeMatrixForType() const;
+
+    static SkColorMatrix MakeSaturate(SkSVGNumberType s);
+
+    static SkColorMatrix MakeHueRotate(SkSVGNumberType degrees);
+
+    static SkColorMatrix MakeLuminanceToAlpha();
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeColorMatrix_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h
new file mode 100644
index 00000000..696b3824
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeComponentTransfer_DEFINED
+#define SkSVGFeComponentTransfer_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+#include <cstdint>
+
+class SkSVGFeFunc final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGFeFunc> MakeFuncA() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncA));
+    }
+
+    static sk_sp<SkSVGFeFunc> MakeFuncR() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncR));
+    }
+
+    static sk_sp<SkSVGFeFunc> MakeFuncG() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncG));
+    }
+
+    static sk_sp<SkSVGFeFunc> MakeFuncB() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncB));
+    }
+
+    SVG_ATTR(Amplitude  , SkSVGNumberType,                          1)
+    SVG_ATTR(Exponent   , SkSVGNumberType,                          1)
+    SVG_ATTR(Intercept  , SkSVGNumberType,                          0)
+    SVG_ATTR(Offset     , SkSVGNumberType,                          0)
+    SVG_ATTR(Slope      , SkSVGNumberType,                          1)
+    SVG_ATTR(TableValues, std::vector<SkSVGNumberType>,            {})
+    SVG_ATTR(Type       , SkSVGFeFuncType, SkSVGFeFuncType::kIdentity)
+
+    std::vector<uint8_t> getTable() const;
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeFunc(SkSVGTag tag) : INHERITED(tag) {}
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+class SK_API SkSVGFeComponentTransfer final : public SkSVGFe {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kFeComponentTransfer;
+
+    static sk_sp<SkSVGFeComponentTransfer> Make() {
+        return sk_sp<SkSVGFeComponentTransfer>(new SkSVGFeComponentTransfer());
+    }
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+private:
+    SkSVGFeComponentTransfer() : INHERITED(tag) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif //  SkSVGFeComponentTransfer_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h
new file mode 100644
index 00000000..42cbf18a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeComposite_DEFINED
+#define SkSVGFeComposite_DEFINED
+
+#include "include/core/SkBlendMode.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeComposite final : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeComposite> Make() {
+        return sk_sp<SkSVGFeComposite>(new SkSVGFeComposite());
+    }
+
+    SVG_ATTR(In2, SkSVGFeInputType, SkSVGFeInputType())
+    SVG_ATTR(K1, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(K2, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(K3, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(K4, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(Operator, SkSVGFeCompositeOperator, SkSVGFeCompositeOperator::kOver)
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override {
+        return {this->getIn(), this->getIn2()};
+    }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeComposite() : INHERITED(SkSVGTag::kFeComposite) {}
+
+    static SkBlendMode BlendModeForOperator(SkSVGFeCompositeOperator);
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeComposite_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h
new file mode 100644
index 00000000..8d2ef8a2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeDisplacementMap_DEFINED
+#define SkSVGFeDisplacementMap_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeDisplacementMap : public SkSVGFe {
+public:
+    using ChannelSelector = SkColorChannel;
+
+    static sk_sp<SkSVGFeDisplacementMap> Make() {
+        return sk_sp<SkSVGFeDisplacementMap>(new SkSVGFeDisplacementMap());
+    }
+
+    SkSVGColorspace resolveColorspace(const SkSVGRenderContext&,
+                                      const SkSVGFilterContext&) const final;
+
+    SVG_ATTR(In2             , SkSVGFeInputType, SkSVGFeInputType())
+    SVG_ATTR(XChannelSelector, ChannelSelector , ChannelSelector::kA)
+    SVG_ATTR(YChannelSelector, ChannelSelector , ChannelSelector::kA)
+    SVG_ATTR(Scale           , SkSVGNumberType , SkSVGNumberType(0))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override {
+        return {this->getIn(), this->getIn2()};
+    }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeDisplacementMap() : INHERITED(SkSVGTag::kFeDisplacementMap) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeDisplacementMap_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h
new file mode 100644
index 00000000..dbcaaec9
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeFlood_DEFINED
+#define SkSVGFeFlood_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeFlood : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeFlood> Make() { return sk_sp<SkSVGFeFlood>(new SkSVGFeFlood()); }
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {}; }
+
+private:
+    SkSVGFeFlood() : INHERITED(SkSVGTag::kFeFlood) {}
+
+    SkColor resolveFloodColor(const SkSVGRenderContext&) const;
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeFlood_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h
new file mode 100644
index 00000000..b053956a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeGaussianBlur_DEFINED
+#define SkSVGFeGaussianBlur_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeGaussianBlur : public SkSVGFe {
+public:
+    struct StdDeviation {
+        SkSVGNumberType fX;
+        SkSVGNumberType fY;
+    };
+
+    static sk_sp<SkSVGFeGaussianBlur> Make() {
+        return sk_sp<SkSVGFeGaussianBlur>(new SkSVGFeGaussianBlur());
+    }
+
+    SVG_ATTR(StdDeviation, StdDeviation, StdDeviation({0, 0}))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeGaussianBlur() : INHERITED(SkSVGTag::kFeGaussianBlur) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeGaussianBlur_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h
new file mode 100644
index 00000000..7cc123d4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeImage_DEFINED
+#define SkSVGFeImage_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeImage : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeImage> Make() { return sk_sp<SkSVGFeImage>(new SkSVGFeImage()); }
+
+    SVG_ATTR(Href               , SkSVGIRI                , SkSVGIRI())
+    SVG_ATTR(PreserveAspectRatio, SkSVGPreserveAspectRatio, SkSVGPreserveAspectRatio())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {}; }
+
+private:
+    SkSVGFeImage() : INHERITED(SkSVGTag::kFeImage) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeImage_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h
new file mode 100644
index 00000000..8be65c51
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeLightSource_DEFINED
+#define SkSVGFeLightSource_DEFINED
+
+#include "include/core/SkPoint3.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeLightSource : public SkSVGHiddenContainer {
+public:
+    void appendChild(sk_sp<SkSVGNode>) final {
+        SkDebugf("cannot append child nodes to an SVG light source.\n");
+    }
+
+protected:
+    explicit SkSVGFeLightSource(SkSVGTag tag) : INHERITED(tag) {}
+
+private:
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+class SkSVGFeDistantLight final : public SkSVGFeLightSource {
+public:
+    static sk_sp<SkSVGFeDistantLight> Make() {
+        return sk_sp<SkSVGFeDistantLight>(new SkSVGFeDistantLight());
+    }
+
+    SkPoint3 computeDirection() const;
+
+    SVG_ATTR(Azimuth  , SkSVGNumberType, 0)
+    SVG_ATTR(Elevation, SkSVGNumberType, 0)
+
+private:
+    SkSVGFeDistantLight() : INHERITED(SkSVGTag::kFeDistantLight) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGFeLightSource;
+};
+
+class SkSVGFePointLight final : public SkSVGFeLightSource {
+public:
+    static sk_sp<SkSVGFePointLight> Make() {
+        return sk_sp<SkSVGFePointLight>(new SkSVGFePointLight());
+    }
+
+    SVG_ATTR(X, SkSVGNumberType, 0)
+    SVG_ATTR(Y, SkSVGNumberType, 0)
+    SVG_ATTR(Z, SkSVGNumberType, 0)
+
+private:
+    SkSVGFePointLight() : INHERITED(SkSVGTag::kFePointLight) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGFeLightSource;
+};
+
+class SkSVGFeSpotLight final : public SkSVGFeLightSource {
+public:
+    static sk_sp<SkSVGFeSpotLight> Make() {
+        return sk_sp<SkSVGFeSpotLight>(new SkSVGFeSpotLight());
+    }
+
+    SVG_ATTR(X               , SkSVGNumberType, 0)
+    SVG_ATTR(Y               , SkSVGNumberType, 0)
+    SVG_ATTR(Z               , SkSVGNumberType, 0)
+    SVG_ATTR(PointsAtX       , SkSVGNumberType, 0)
+    SVG_ATTR(PointsAtY       , SkSVGNumberType, 0)
+    SVG_ATTR(PointsAtZ       , SkSVGNumberType, 0)
+    SVG_ATTR(SpecularExponent, SkSVGNumberType, 1)
+
+    SVG_OPTIONAL_ATTR(LimitingConeAngle, SkSVGNumberType)
+
+private:
+    SkSVGFeSpotLight() : INHERITED(SkSVGTag::kFeSpotLight) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGFeLightSource;
+};
+
+#endif  // SkSVGFeLightSource_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h
new file mode 100644
index 00000000..5321ca3e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeLighting_DEFINED
+#define SkSVGFeLighting_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGFeDistantLight;
+class SkSVGFePointLight;
+class SkSVGFeSpotLight;
+
+class SK_API SkSVGFeLighting : public SkSVGFe {
+public:
+    struct KernelUnitLength {
+        SkSVGNumberType fDx;
+        SkSVGNumberType fDy;
+    };
+
+    SVG_ATTR(SurfaceScale, SkSVGNumberType, 1)
+    SVG_OPTIONAL_ATTR(KernelUnitLength, KernelUnitLength)
+
+protected:
+    explicit SkSVGFeLighting(SkSVGTag t) : INHERITED(t) {}
+
+    std::vector<SkSVGFeInputType> getInputs() const final { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const final;
+
+    virtual sk_sp<SkImageFilter> makeDistantLight(const SkSVGRenderContext&,
+                                                  const SkSVGFilterContext&,
+                                                  const SkSVGFeDistantLight*) const = 0;
+
+    virtual sk_sp<SkImageFilter> makePointLight(const SkSVGRenderContext&,
+                                                const SkSVGFilterContext&,
+                                                const SkSVGFePointLight*) const = 0;
+
+    virtual sk_sp<SkImageFilter> makeSpotLight(const SkSVGRenderContext&,
+                                               const SkSVGFilterContext&,
+                                               const SkSVGFeSpotLight*) const = 0;
+
+    SkColor resolveLightingColor(const SkSVGRenderContext&) const;
+
+    SkPoint3 resolveXYZ(const SkSVGRenderContext&,
+                        const SkSVGFilterContext&,
+                        SkSVGNumberType,
+                        SkSVGNumberType,
+                        SkSVGNumberType) const;
+
+private:
+    using INHERITED = SkSVGFe;
+};
+
+class SkSVGFeSpecularLighting final : public SkSVGFeLighting {
+public:
+    static sk_sp<SkSVGFeSpecularLighting> Make() {
+        return sk_sp<SkSVGFeSpecularLighting>(new SkSVGFeSpecularLighting());
+    }
+
+    SVG_ATTR(SpecularConstant, SkSVGNumberType, 1)
+    SVG_ATTR(SpecularExponent, SkSVGNumberType, 1)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> makeDistantLight(const SkSVGRenderContext&,
+                                          const SkSVGFilterContext&,
+                                          const SkSVGFeDistantLight*) const final;
+
+    sk_sp<SkImageFilter> makePointLight(const SkSVGRenderContext&,
+                                        const SkSVGFilterContext&,
+                                        const SkSVGFePointLight*) const final;
+
+    sk_sp<SkImageFilter> makeSpotLight(const SkSVGRenderContext&,
+                                       const SkSVGFilterContext&,
+                                       const SkSVGFeSpotLight*) const final;
+
+private:
+    SkSVGFeSpecularLighting() : INHERITED(SkSVGTag::kFeSpecularLighting) {}
+
+    using INHERITED = SkSVGFeLighting;
+};
+
+class SkSVGFeDiffuseLighting final : public SkSVGFeLighting {
+public:
+    static sk_sp<SkSVGFeDiffuseLighting> Make() {
+        return sk_sp<SkSVGFeDiffuseLighting>(new SkSVGFeDiffuseLighting());
+    }
+
+    SVG_ATTR(DiffuseConstant, SkSVGNumberType, 1)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> makeDistantLight(const SkSVGRenderContext&,
+                                          const SkSVGFilterContext&,
+                                          const SkSVGFeDistantLight*) const final;
+
+    sk_sp<SkImageFilter> makePointLight(const SkSVGRenderContext&,
+                                        const SkSVGFilterContext&,
+                                        const SkSVGFePointLight*) const final;
+
+    sk_sp<SkImageFilter> makeSpotLight(const SkSVGRenderContext&,
+                                       const SkSVGFilterContext&,
+                                       const SkSVGFeSpotLight*) const final;
+
+private:
+    SkSVGFeDiffuseLighting() : INHERITED(SkSVGTag::kFeDiffuseLighting) {}
+
+    using INHERITED = SkSVGFeLighting;
+};
+
+#endif  // SkSVGFeLighting_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h
new file mode 100644
index 00000000..0c5e317b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeMerge_DEFINED
+#define SkSVGFeMerge_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+// https://www.w3.org/TR/SVG11/filters.html#feMergeNodeElement
+class SK_API SkSVGFeMergeNode : public SkSVGHiddenContainer {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kFeMergeNode;
+
+    static sk_sp<SkSVGFeMergeNode> Make() {
+        return sk_sp<SkSVGFeMergeNode>(new SkSVGFeMergeNode());
+    }
+
+    SVG_ATTR(In, SkSVGFeInputType, SkSVGFeInputType())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeMergeNode() : INHERITED(tag) {}
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+// https://www.w3.org/TR/SVG11/filters.html#feMergeElement
+class SK_API SkSVGFeMerge : public SkSVGFe {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kFeMerge;
+
+    static sk_sp<SkSVGFeMerge> Make() { return sk_sp<SkSVGFeMerge>(new SkSVGFeMerge()); }
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override;
+
+private:
+    SkSVGFeMerge() : INHERITED(tag) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif //  SkSVGFeMerge_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h
new file mode 100644
index 00000000..172460f7
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeMorphology_DEFINED
+#define SkSVGFeMorphology_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGFeMorphology : public SkSVGFe {
+public:
+    struct Radius {
+        SkSVGNumberType fX;
+        SkSVGNumberType fY;
+    };
+
+    enum class Operator {
+        kErode,
+        kDilate,
+    };
+
+    static sk_sp<SkSVGFeMorphology> Make() {
+        return sk_sp<SkSVGFeMorphology>(new SkSVGFeMorphology());
+    }
+
+    SVG_ATTR(Operator, Operator, Operator::kErode)
+    SVG_ATTR(Radius  , Radius  , Radius({0, 0}))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeMorphology() : INHERITED(SkSVGTag::kFeMorphology) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeMorphology_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h
new file mode 100644
index 00000000..8ed6288b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeOffset_DEFINED
+#define SkSVGFeOffset_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeOffset : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeOffset> Make() { return sk_sp<SkSVGFeOffset>(new SkSVGFeOffset()); }
+
+    SVG_ATTR(Dx, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(Dy, SkSVGNumberType, SkSVGNumberType(0))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeOffset() : INHERITED(SkSVGTag::kFeOffset) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeOffset_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h
new file mode 100644
index 00000000..53f300c8
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeTurbulence_DEFINED
+#define SkSVGFeTurbulence_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeTurbulence : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeTurbulence> Make() {
+        return sk_sp<SkSVGFeTurbulence>(new SkSVGFeTurbulence());
+    }
+
+    SVG_ATTR(BaseFrequency, SkSVGFeTurbulenceBaseFrequency, SkSVGFeTurbulenceBaseFrequency({}))
+    SVG_ATTR(NumOctaves, SkSVGIntegerType, SkSVGIntegerType(1))
+    SVG_ATTR(Seed, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(TurbulenceType,
+             SkSVGFeTurbulenceType,
+             SkSVGFeTurbulenceType(SkSVGFeTurbulenceType::Type::kTurbulence))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+private:
+    SkSVGFeTurbulence() : INHERITED(SkSVGTag::kFeTurbulence) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeTurbulence_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h
new file mode 100644
index 00000000..b4320a13
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFilter_DEFINED
+#define SkSVGFilter_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFilter final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGFilter> Make() { return sk_sp<SkSVGFilter>(new SkSVGFilter()); }
+
+    /** Propagates any inherited presentation attributes in the given context. */
+    void applyProperties(SkSVGRenderContext*) const;
+
+    sk_sp<SkImageFilter> buildFilterDAG(const SkSVGRenderContext&) const;
+
+    SVG_ATTR(X, SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y, SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Width, SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Height, SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(FilterUnits,
+             SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox))
+    SVG_ATTR(PrimitiveUnits,
+             SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse))
+
+private:
+    SkSVGFilter() : INHERITED(SkSVGTag::kFilter) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif  // SkSVGFilter_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h
new file mode 100644
index 00000000..dcd938d1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFilterContext_DEFINED
+#define SkSVGFilterContext_DEFINED
+
+#include "include/core/SkRect.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkString.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/core/SkTHash.h"
+
+class SkImageFilter;
+class SkSVGFeInputType;
+class SkSVGRenderContext;
+
+class SkSVGFilterContext {
+public:
+    SkSVGFilterContext(const SkRect& filterEffectsRegion,
+                       const SkSVGObjectBoundingBoxUnits& primitiveUnits)
+            : fFilterEffectsRegion(filterEffectsRegion)
+            , fPrimitiveUnits(primitiveUnits)
+            , fPreviousResult({nullptr, filterEffectsRegion, SkSVGColorspace::kSRGB}) {}
+
+    const SkRect& filterEffectsRegion() const { return fFilterEffectsRegion; }
+
+    const SkRect& filterPrimitiveSubregion(const SkSVGFeInputType&) const;
+
+    const SkSVGObjectBoundingBoxUnits& primitiveUnits() const { return fPrimitiveUnits; }
+
+    void registerResult(const SkSVGStringType&, const sk_sp<SkImageFilter>&, const SkRect&, SkSVGColorspace);
+
+    void setPreviousResult(const sk_sp<SkImageFilter>&, const SkRect&, SkSVGColorspace);
+
+    bool previousResultIsSourceGraphic() const;
+
+    SkSVGColorspace resolveInputColorspace(const SkSVGRenderContext&,
+                                           const SkSVGFeInputType&) const;
+
+    sk_sp<SkImageFilter> resolveInput(const SkSVGRenderContext&, const SkSVGFeInputType&) const;
+
+    sk_sp<SkImageFilter> resolveInput(const SkSVGRenderContext&, const SkSVGFeInputType&, SkSVGColorspace) const;
+
+private:
+    struct Result {
+        sk_sp<SkImageFilter> fImageFilter;
+        SkRect fFilterSubregion;
+        SkSVGColorspace fColorspace;
+    };
+
+    const Result* findResultById(const SkSVGStringType&) const;
+
+    std::tuple<sk_sp<SkImageFilter>, SkSVGColorspace> getInput(const SkSVGRenderContext&,
+                                                               const SkSVGFeInputType&) const;
+
+    SkRect fFilterEffectsRegion;
+
+    SkSVGObjectBoundingBoxUnits fPrimitiveUnits;
+
+    skia_private::THashMap<SkSVGStringType, Result> fResults;
+
+    Result fPreviousResult;
+};
+
+#endif  // SkSVGFilterContext_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGG.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGG.h
new file mode 100644
index 00000000..10b90816
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGG.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGG_DEFINED
+#define SkSVGG_DEFINED
+
+#include "modules/svg/include/SkSVGContainer.h"
+
+class SK_API SkSVGG : public SkSVGContainer {
+public:
+    static sk_sp<SkSVGG> Make() { return sk_sp<SkSVGG>(new SkSVGG()); }
+
+private:
+    SkSVGG() : INHERITED(SkSVGTag::kG) { }
+
+    using INHERITED = SkSVGContainer;
+};
+
+#endif // SkSVGG_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h
new file mode 100644
index 00000000..4a7feefd
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGGradient_DEFINED
+#define SkSVGGradient_DEFINED
+
+#include "include/core/SkShader.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkMatrix;
+class SkSVGRenderContext;
+class SkSVGStop;
+
+class SK_API SkSVGGradient : public SkSVGHiddenContainer {
+public:
+    SVG_ATTR(Href, SkSVGIRI, SkSVGIRI())
+    SVG_ATTR(GradientTransform, SkSVGTransformType, SkSVGTransformType(SkMatrix::I()))
+    SVG_ATTR(SpreadMethod, SkSVGSpreadMethod, SkSVGSpreadMethod(SkSVGSpreadMethod::Type::kPad))
+    SVG_ATTR(GradientUnits,
+             SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox))
+
+protected:
+    explicit SkSVGGradient(SkSVGTag t) : INHERITED(t) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    bool onAsPaint(const SkSVGRenderContext&, SkPaint*) const final;
+
+    virtual sk_sp<SkShader> onMakeShader(const SkSVGRenderContext&,
+                                         const SkColor4f*, const SkScalar*, int count,
+                                         SkTileMode, const SkMatrix& localMatrix) const = 0;
+
+private:
+    using StopPositionArray = skia_private::STArray<2, SkScalar , true>;
+    using    StopColorArray = skia_private::STArray<2, SkColor4f, true>;
+    void collectColorStops(const SkSVGRenderContext&, StopPositionArray*, StopColorArray*) const;
+    SkColor4f resolveStopColor(const SkSVGRenderContext&, const SkSVGStop&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGGradient_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h
new file mode 100644
index 00000000..72af219b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGHiddenContainer_DEFINED
+#define SkSVGHiddenContainer_DEFINED
+
+#include "modules/svg/include/SkSVGContainer.h"
+
+class SK_API SkSVGHiddenContainer : public SkSVGContainer {
+protected:
+    explicit SkSVGHiddenContainer(SkSVGTag t) : INHERITED(t) {}
+
+    void onRender(const SkSVGRenderContext&) const final {}
+
+private:
+    using INHERITED = SkSVGContainer;
+};
+
+#endif // SkSVGHiddenContainer_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h
new file mode 100644
index 00000000..e78f28de
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGIDMapper_DEFINED
+#define SkSVGIDMapper_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "src/core/SkTHash.h"
+
+class SkString;
+class SkSVGNode;
+
+using SkSVGIDMapper = skia_private::THashMap<SkString, sk_sp<SkSVGNode>>;
+
+#endif // SkSVGIDMapper_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h
new file mode 100644
index 00000000..5b3146c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGImage_DEFINED
+#define SkSVGImage_DEFINED
+
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+namespace skresources {
+class ResourceProvider;
+}
+
+class SK_API SkSVGImage final : public SkSVGTransformableNode {
+public:
+    static sk_sp<SkSVGImage> Make() {
+        return sk_sp<SkSVGImage>(new SkSVGImage());
+    }
+
+    void appendChild(sk_sp<SkSVGNode>) override {
+        SkDebugf("cannot append child nodes to this element.\n");
+    }
+
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+    void onRender(const SkSVGRenderContext&) const override;
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+    struct ImageInfo {
+        sk_sp<SkImage> fImage;
+        SkRect         fDst;
+    };
+    static ImageInfo LoadImage(const sk_sp<skresources::ResourceProvider>&,
+                               const SkSVGIRI&,
+                               const SkRect&,
+                               SkSVGPreserveAspectRatio);
+
+    SVG_ATTR(X                  , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Y                  , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Width              , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Height             , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Href               , SkSVGIRI                , SkSVGIRI())
+    SVG_ATTR(PreserveAspectRatio, SkSVGPreserveAspectRatio, SkSVGPreserveAspectRatio())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGImage() : INHERITED(SkSVGTag::kImage) {}
+
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif  // SkSVGImage_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h
new file mode 100644
index 00000000..c6b27481
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGLine_DEFINED
+#define SkSVGLine_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+struct SkPoint;
+
+class SK_API SkSVGLine final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGLine> Make() { return sk_sp<SkSVGLine>(new SkSVGLine()); }
+
+    SVG_ATTR(X1, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y1, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(X2, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y2, SkSVGLength, SkSVGLength(0))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGLine();
+
+    // resolve and return the two endpoints
+    std::tuple<SkPoint, SkPoint> resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGLine_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h
new file mode 100644
index 00000000..3efc46f5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGLinearGradient_DEFINED
+#define SkSVGLinearGradient_DEFINED
+
+#include "modules/svg/include/SkSVGGradient.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGLinearGradient final : public SkSVGGradient {
+public:
+    static sk_sp<SkSVGLinearGradient> Make() {
+        return sk_sp<SkSVGLinearGradient>(new SkSVGLinearGradient());
+    }
+
+    SVG_ATTR(X1, SkSVGLength, SkSVGLength(0  , SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y1, SkSVGLength, SkSVGLength(0  , SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(X2, SkSVGLength, SkSVGLength(100, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y2, SkSVGLength, SkSVGLength(0  , SkSVGLength::Unit::kPercentage))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkShader> onMakeShader(const SkSVGRenderContext&,
+                                 const SkColor4f*, const SkScalar*, int count,
+                                 SkTileMode, const SkMatrix&) const override;
+private:
+    SkSVGLinearGradient();
+
+    using INHERITED = SkSVGGradient;
+};
+
+#endif // SkSVGLinearGradient_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h
new file mode 100644
index 00000000..1063c887
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGMask_DEFINED
+#define SkSVGMask_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGMask final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGMask> Make() {
+        return sk_sp<SkSVGMask>(new SkSVGMask());
+    }
+
+    SVG_ATTR(X     , SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y     , SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Width , SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Height, SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+
+    SVG_ATTR(MaskUnits, SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox))
+    SVG_ATTR(MaskContentUnits, SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse))
+
+private:
+    friend class SkSVGRenderContext;
+
+    SkSVGMask() : INHERITED(SkSVGTag::kMask) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    SkRect bounds(const SkSVGRenderContext&) const;
+    void renderMask(const SkSVGRenderContext&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGMask_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h
new file mode 100644
index 00000000..7759ddf5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGNode_DEFINED
+#define SkSVGNode_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/svg/include/SkSVGAttribute.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+
+class SkCanvas;
+class SkMatrix;
+class SkPaint;
+class SkPath;
+class SkSVGLengthContext;
+class SkSVGRenderContext;
+class SkSVGValue;
+
+enum class SkSVGTag {
+    kCircle,
+    kClipPath,
+    kDefs,
+    kEllipse,
+    kFeBlend,
+    kFeColorMatrix,
+    kFeComponentTransfer,
+    kFeComposite,
+    kFeDiffuseLighting,
+    kFeDisplacementMap,
+    kFeDistantLight,
+    kFeFlood,
+    kFeFuncA,
+    kFeFuncR,
+    kFeFuncG,
+    kFeFuncB,
+    kFeGaussianBlur,
+    kFeImage,
+    kFeMerge,
+    kFeMergeNode,
+    kFeMorphology,
+    kFeOffset,
+    kFePointLight,
+    kFeSpecularLighting,
+    kFeSpotLight,
+    kFeTurbulence,
+    kFilter,
+    kG,
+    kImage,
+    kLine,
+    kLinearGradient,
+    kMask,
+    kPath,
+    kPattern,
+    kPolygon,
+    kPolyline,
+    kRadialGradient,
+    kRect,
+    kStop,
+    kSvg,
+    kText,
+    kTextLiteral,
+    kTextPath,
+    kTSpan,
+    kUse
+};
+
+#define SVG_PRES_ATTR(attr_name, attr_type, attr_inherited)                  \
+private:                                                                     \
+    bool set##attr_name(SkSVGAttributeParser::ParseResult<                   \
+                            SkSVGProperty<attr_type, attr_inherited>>&& pr) {\
+        if (pr.isValid()) { this->set##attr_name(std::move(*pr)); }          \
+        return pr.isValid();                                                 \
+    }                                                                        \
+                                                                             \
+public:                                                                      \
+    const SkSVGProperty<attr_type, attr_inherited>& get##attr_name() const { \
+        return fPresentationAttributes.f##attr_name;                         \
+    }                                                                        \
+    void set##attr_name(const SkSVGProperty<attr_type, attr_inherited>& v) { \
+        auto* dest = &fPresentationAttributes.f##attr_name;                  \
+        if (!dest->isInheritable() || v.isValue()) {                         \
+            /* TODO: If dest is not inheritable, handle v == "inherit" */    \
+            *dest = v;                                                       \
+        } else {                                                             \
+            dest->set(SkSVGPropertyState::kInherit);                         \
+        }                                                                    \
+    }                                                                        \
+    void set##attr_name(SkSVGProperty<attr_type, attr_inherited>&& v) {      \
+        auto* dest = &fPresentationAttributes.f##attr_name;                  \
+        if (!dest->isInheritable() || v.isValue()) {                         \
+            /* TODO: If dest is not inheritable, handle v == "inherit" */    \
+            *dest = std::move(v);                                            \
+        } else {                                                             \
+            dest->set(SkSVGPropertyState::kInherit);                         \
+        }                                                                    \
+    }
+
+class SK_API SkSVGNode : public SkRefCnt {
+public:
+    ~SkSVGNode() override;
+
+    SkSVGTag tag() const { return fTag; }
+
+    virtual void appendChild(sk_sp<SkSVGNode>) = 0;
+
+    void render(const SkSVGRenderContext&) const;
+    bool asPaint(const SkSVGRenderContext&, SkPaint*) const;
+    SkPath asPath(const SkSVGRenderContext&) const;
+    SkRect objectBoundingBox(const SkSVGRenderContext&) const;
+
+    void setAttribute(SkSVGAttribute, const SkSVGValue&);
+    bool setAttribute(const char* attributeName, const char* attributeValue);
+
+    // TODO: consolidate with existing setAttribute
+    virtual bool parseAndSetAttribute(const char* name, const char* value);
+
+    // inherited
+    SVG_PRES_ATTR(ClipRule                 , SkSVGFillRule  , true)
+    SVG_PRES_ATTR(Color                    , SkSVGColorType , true)
+    SVG_PRES_ATTR(ColorInterpolation       , SkSVGColorspace, true)
+    SVG_PRES_ATTR(ColorInterpolationFilters, SkSVGColorspace, true)
+    SVG_PRES_ATTR(FillRule                 , SkSVGFillRule  , true)
+    SVG_PRES_ATTR(Fill                     , SkSVGPaint     , true)
+    SVG_PRES_ATTR(FillOpacity              , SkSVGNumberType, true)
+    SVG_PRES_ATTR(FontFamily               , SkSVGFontFamily, true)
+    SVG_PRES_ATTR(FontSize                 , SkSVGFontSize  , true)
+    SVG_PRES_ATTR(FontStyle                , SkSVGFontStyle , true)
+    SVG_PRES_ATTR(FontWeight               , SkSVGFontWeight, true)
+    SVG_PRES_ATTR(Stroke                   , SkSVGPaint     , true)
+    SVG_PRES_ATTR(StrokeDashArray          , SkSVGDashArray , true)
+    SVG_PRES_ATTR(StrokeDashOffset         , SkSVGLength    , true)
+    SVG_PRES_ATTR(StrokeLineCap            , SkSVGLineCap   , true)
+    SVG_PRES_ATTR(StrokeLineJoin           , SkSVGLineJoin  , true)
+    SVG_PRES_ATTR(StrokeMiterLimit         , SkSVGNumberType, true)
+    SVG_PRES_ATTR(StrokeOpacity            , SkSVGNumberType, true)
+    SVG_PRES_ATTR(StrokeWidth              , SkSVGLength    , true)
+    SVG_PRES_ATTR(TextAnchor               , SkSVGTextAnchor, true)
+    SVG_PRES_ATTR(Visibility               , SkSVGVisibility, true)
+
+    // not inherited
+    SVG_PRES_ATTR(ClipPath                 , SkSVGFuncIRI   , false)
+    SVG_PRES_ATTR(Display                  , SkSVGDisplay   , false)
+    SVG_PRES_ATTR(Mask                     , SkSVGFuncIRI   , false)
+    SVG_PRES_ATTR(Filter                   , SkSVGFuncIRI   , false)
+    SVG_PRES_ATTR(Opacity                  , SkSVGNumberType, false)
+    SVG_PRES_ATTR(StopColor                , SkSVGColor     , false)
+    SVG_PRES_ATTR(StopOpacity              , SkSVGNumberType, false)
+    SVG_PRES_ATTR(FloodColor               , SkSVGColor     , false)
+    SVG_PRES_ATTR(FloodOpacity             , SkSVGNumberType, false)
+    SVG_PRES_ATTR(LightingColor            , SkSVGColor     , false)
+
+protected:
+    SkSVGNode(SkSVGTag);
+
+    static SkMatrix ComputeViewboxMatrix(const SkRect&, const SkRect&, SkSVGPreserveAspectRatio);
+
+    // Called before onRender(), to apply local attributes to the context.  Unlike onRender(),
+    // onPrepareToRender() bubbles up the inheritance chain: overriders should always call
+    // INHERITED::onPrepareToRender(), unless they intend to short-circuit rendering
+    // (return false).
+    // Implementations are expected to return true if rendering is to continue, or false if
+    // the node/subtree rendering is disabled.
+    virtual bool onPrepareToRender(SkSVGRenderContext*) const;
+
+    virtual void onRender(const SkSVGRenderContext&) const = 0;
+
+    virtual bool onAsPaint(const SkSVGRenderContext&, SkPaint*) const { return false; }
+
+    virtual SkPath onAsPath(const SkSVGRenderContext&) const = 0;
+
+    virtual void onSetAttribute(SkSVGAttribute, const SkSVGValue&) {}
+
+    virtual bool hasChildren() const { return false; }
+
+    virtual SkRect onObjectBoundingBox(const SkSVGRenderContext&) const {
+        return SkRect::MakeEmpty();
+    }
+
+private:
+    SkSVGTag                    fTag;
+
+    // FIXME: this should be sparse
+    SkSVGPresentationAttributes fPresentationAttributes;
+
+    using INHERITED = SkRefCnt;
+};
+
+#undef SVG_PRES_ATTR // presentation attributes are only defined for the base class
+
+#define _SVG_ATTR_SETTERS(attr_name, attr_type, attr_default, set_cp, set_mv) \
+    private:                                                                  \
+        bool set##attr_name(                                                  \
+                const SkSVGAttributeParser::ParseResult<attr_type>& pr) {     \
+            if (pr.isValid()) { this->set##attr_name(*pr); }                  \
+            return pr.isValid();                                              \
+        }                                                                     \
+        bool set##attr_name(                                                  \
+                SkSVGAttributeParser::ParseResult<attr_type>&& pr) {          \
+            if (pr.isValid()) { this->set##attr_name(std::move(*pr)); }       \
+            return pr.isValid();                                              \
+        }                                                                     \
+    public:                                                                   \
+        void set##attr_name(const attr_type& a) { set_cp(a); }                \
+        void set##attr_name(attr_type&& a) { set_mv(std::move(a)); }
+
+#define SVG_ATTR(attr_name, attr_type, attr_default)                        \
+    private:                                                                \
+        attr_type f##attr_name = attr_default;                              \
+    public:                                                                 \
+        const attr_type& get##attr_name() const { return f##attr_name; }    \
+    _SVG_ATTR_SETTERS(                                                      \
+            attr_name, attr_type, attr_default,                             \
+            [this](const attr_type& a) { this->f##attr_name = a; },         \
+            [this](attr_type&& a) { this->f##attr_name = std::move(a); })
+
+#define SVG_OPTIONAL_ATTR(attr_name, attr_type)                                   \
+    private:                                                                      \
+        SkTLazy<attr_type> f##attr_name;                                          \
+    public:                                                                       \
+        const SkTLazy<attr_type>& get##attr_name() const { return f##attr_name; } \
+    _SVG_ATTR_SETTERS(                                                            \
+            attr_name, attr_type, attr_default,                                   \
+            [this](const attr_type& a) { this->f##attr_name.set(a); },            \
+            [this](attr_type&& a) { this->f##attr_name.set(std::move(a)); })
+
+#endif // SkSVGNode_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h
new file mode 100644
index 00000000..fb4f8304
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2022 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGOpenTypeSVGDecoder_DEFINED
+#define SkSVGOpenTypeSVGDecoder_DEFINED
+
+#include "include/core/SkColor.h"
+#include "include/core/SkOpenTypeSVGDecoder.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkTypes.h"
+
+class SkCanvas;
+class SkSVGDOM;
+
+class SkSVGOpenTypeSVGDecoder : public SkOpenTypeSVGDecoder {
+public:
+    static std::unique_ptr<SkOpenTypeSVGDecoder> Make(const uint8_t* svg, size_t svgLength);
+    size_t approximateSize() override;
+    bool render(SkCanvas&, int upem, SkGlyphID glyphId,
+                SkColor foregroundColor, SkSpan<SkColor> palette) override;
+    ~SkSVGOpenTypeSVGDecoder() override;
+private:
+    SkSVGOpenTypeSVGDecoder(sk_sp<SkSVGDOM> skSvg, size_t approximateSize);
+    sk_sp<SkSVGDOM> fSkSvg;
+    size_t fApproximateSize;
+};
+
+#endif  // SkSVGOpenTypeSVGDecoder_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h
new file mode 100644
index 00000000..77436d1f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGPath_DEFINED
+#define SkSVGPath_DEFINED
+
+#include "include/core/SkPath.h"
+#include "modules/svg/include/SkSVGShape.h"
+
+class SK_API SkSVGPath final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGPath> Make() { return sk_sp<SkSVGPath>(new SkSVGPath()); }
+
+    SVG_ATTR(Path, SkPath, SkPath())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGPath();
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGPath_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h
new file mode 100644
index 00000000..57d934c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGPattern_DEFINED
+#define SkSVGPattern_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGRenderContext;
+
+class SK_API SkSVGPattern final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGPattern> Make() {
+        return sk_sp<SkSVGPattern>(new SkSVGPattern());
+    }
+
+    SVG_ATTR(Href, SkSVGIRI, SkSVGIRI())
+    SVG_OPTIONAL_ATTR(X               , SkSVGLength)
+    SVG_OPTIONAL_ATTR(Y               , SkSVGLength)
+    SVG_OPTIONAL_ATTR(Width           , SkSVGLength)
+    SVG_OPTIONAL_ATTR(Height          , SkSVGLength)
+    SVG_OPTIONAL_ATTR(PatternTransform, SkSVGTransformType)
+
+protected:
+    SkSVGPattern();
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    bool onAsPaint(const SkSVGRenderContext&, SkPaint*) const override;
+
+private:
+    struct PatternAttributes {
+        SkTLazy<SkSVGLength>        fX,
+                                    fY,
+                                    fWidth,
+                                    fHeight;
+        SkTLazy<SkSVGTransformType> fPatternTransform;
+    };
+
+    const SkSVGPattern* resolveHref(const SkSVGRenderContext&, PatternAttributes*) const;
+    const SkSVGPattern* hrefTarget(const SkSVGRenderContext&) const;
+
+    // TODO:
+    //   - patternUnits
+    //   - patternContentUnits
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGPattern_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h
new file mode 100644
index 00000000..949490af
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGPoly_DEFINED
+#define SkSVGPoly_DEFINED
+
+#include "include/core/SkPath.h"
+#include "modules/svg/include/SkSVGShape.h"
+
+// Handles <polygon> and <polyline> elements.
+class SK_API SkSVGPoly final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGPoly> MakePolygon() {
+        return sk_sp<SkSVGPoly>(new SkSVGPoly(SkSVGTag::kPolygon));
+    }
+
+    static sk_sp<SkSVGPoly> MakePolyline() {
+        return sk_sp<SkSVGPoly>(new SkSVGPoly(SkSVGTag::kPolyline));
+    }
+
+    SVG_ATTR(Points, SkSVGPointsType, SkSVGPointsType())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGPoly(SkSVGTag);
+
+    mutable SkPath fPath;  // mutated in onDraw(), to apply inherited fill types.
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGPoly_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h
new file mode 100644
index 00000000..9b25c436
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRadialGradient_DEFINED
+#define SkSVGRadialGradient_DEFINED
+
+#include "modules/svg/include/SkSVGGradient.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGRadialGradient final : public SkSVGGradient {
+public:
+    static sk_sp<SkSVGRadialGradient> Make() {
+        return sk_sp<SkSVGRadialGradient>(new SkSVGRadialGradient());
+    }
+
+    SVG_ATTR(Cx, SkSVGLength, SkSVGLength(50, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Cy, SkSVGLength, SkSVGLength(50, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(R,  SkSVGLength, SkSVGLength(50, SkSVGLength::Unit::kPercentage))
+    SVG_OPTIONAL_ATTR(Fx, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Fy, SkSVGLength)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkShader> onMakeShader(const SkSVGRenderContext&,
+                                 const SkColor4f*, const SkScalar*, int count,
+                                 SkTileMode, const SkMatrix&) const override;
+private:
+    SkSVGRadialGradient();
+
+    using INHERITED = SkSVGGradient;
+};
+
+#endif // SkSVGRadialGradient_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h
new file mode 100644
index 00000000..d2983a19
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRect_DEFINED
+#define SkSVGRect_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkRRect;
+
+class SK_API SkSVGRect final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGRect> Make() { return sk_sp<SkSVGRect>(new SkSVGRect()); }
+
+    SVG_ATTR(X     , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y     , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Width , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Height, SkSVGLength, SkSVGLength(0))
+
+    SVG_OPTIONAL_ATTR(Rx, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Ry, SkSVGLength)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGRect();
+
+    SkRRect resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGRect_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h
new file mode 100644
index 00000000..1a0c067f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRenderContext_DEFINED
+#define SkSVGRenderContext_DEFINED
+
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkM44.h"
+#include "include/core/SkPaint.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkRect.h"
+#include "include/core/SkSize.h"
+#include "include/core/SkTypes.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+#include "modules/svg/include/SkSVGAttribute.h"
+#include "modules/svg/include/SkSVGIDMapper.h"
+#include "src/base/SkTLazy.h"
+#include "src/core/SkTHash.h"
+
+class SkCanvas;
+class SkSVGLength;
+
+class SK_API SkSVGLengthContext {
+public:
+    SkSVGLengthContext(const SkSize& viewport, SkScalar dpi = 90)
+        : fViewport(viewport), fDPI(dpi) {}
+
+    enum class LengthType {
+        kHorizontal,
+        kVertical,
+        kOther,
+    };
+
+    const SkSize& viewPort() const { return fViewport; }
+    void setViewPort(const SkSize& viewport) { fViewport = viewport; }
+
+    SkScalar resolve(const SkSVGLength&, LengthType) const;
+    SkRect   resolveRect(const SkSVGLength& x, const SkSVGLength& y,
+                         const SkSVGLength& w, const SkSVGLength& h) const;
+
+private:
+    SkSize   fViewport;
+    SkScalar fDPI;
+};
+
+struct SK_API SkSVGPresentationContext {
+    SkSVGPresentationContext();
+    SkSVGPresentationContext(const SkSVGPresentationContext&)            = default;
+    SkSVGPresentationContext& operator=(const SkSVGPresentationContext&) = default;
+
+    const skia_private::THashMap<SkString, SkSVGColorType>* fNamedColors = nullptr;
+
+    // Inherited presentation attributes, computed for the current node.
+    SkSVGPresentationAttributes fInherited;
+};
+
+class SK_API SkSVGRenderContext {
+public:
+    // Captures data required for object bounding box resolution.
+    struct OBBScope {
+        const SkSVGNode*          fNode;
+        const SkSVGRenderContext* fCtx;
+    };
+
+    SkSVGRenderContext(SkCanvas*,
+                       const sk_sp<SkFontMgr>&,
+                       const sk_sp<skresources::ResourceProvider>&,
+                       const SkSVGIDMapper&,
+                       const SkSVGLengthContext&,
+                       const SkSVGPresentationContext&,
+                       const OBBScope&,
+                       const sk_sp<SkShapers::Factory>&);
+    SkSVGRenderContext(const SkSVGRenderContext&);
+    SkSVGRenderContext(const SkSVGRenderContext&, SkCanvas*);
+    // Establish a new OBB scope.  Normally used when entering a node's render scope.
+    SkSVGRenderContext(const SkSVGRenderContext&, const SkSVGNode*);
+    ~SkSVGRenderContext();
+
+    const SkSVGLengthContext& lengthContext() const { return *fLengthContext; }
+    SkSVGLengthContext* writableLengthContext() { return fLengthContext.writable(); }
+
+    const SkSVGPresentationContext& presentationContext() const { return *fPresentationContext; }
+
+    SkCanvas* canvas() const { return fCanvas; }
+    void saveOnce();
+
+    enum ApplyFlags {
+        kLeaf = 1 << 0, // the target node doesn't have descendants
+    };
+    void applyPresentationAttributes(const SkSVGPresentationAttributes&, uint32_t flags);
+
+    // Scoped wrapper that temporarily clears the original node reference.
+    class BorrowedNode {
+    public:
+        explicit BorrowedNode(sk_sp<SkSVGNode>* node)
+            : fOwner(node) {
+            if (fOwner) {
+                fBorrowed = std::move(*fOwner);
+                *fOwner = nullptr;
+            }
+        }
+
+        ~BorrowedNode() {
+            if (fOwner) {
+                *fOwner = std::move(fBorrowed);
+            }
+        }
+
+        const SkSVGNode* get() const { return fBorrowed.get(); }
+        const SkSVGNode* operator->() const { return fBorrowed.get(); }
+        const SkSVGNode& operator*() const { return *fBorrowed; }
+
+        explicit operator bool() const { return !!fBorrowed; }
+
+    private:
+        // noncopyable
+        BorrowedNode(const BorrowedNode&)      = delete;
+        BorrowedNode& operator=(BorrowedNode&) = delete;
+
+        sk_sp<SkSVGNode>* fOwner;
+        sk_sp<SkSVGNode>  fBorrowed;
+    };
+
+    // Note: the id->node association is cleared for the lifetime of the returned value
+    // (effectively breaks reference cycles, assuming appropriate return value scoping).
+    BorrowedNode findNodeById(const SkSVGIRI&) const;
+
+    SkTLazy<SkPaint> fillPaint() const;
+    SkTLazy<SkPaint> strokePaint() const;
+
+    SkSVGColorType resolveSvgColor(const SkSVGColor&) const;
+
+    // The local computed clip path (not inherited).
+    const SkPath* clipPath() const { return fClipPath.getMaybeNull(); }
+
+    const sk_sp<skresources::ResourceProvider>& resourceProvider() const {
+        return fResourceProvider;
+    }
+
+    sk_sp<SkFontMgr> fontMgr() const {
+        // It is probably an oversight to try to render <text> without having set the SkFontMgr.
+        // We will assert this in debug mode, but fallback to an empty fontmgr in release builds.
+        SkASSERT(fFontMgr);
+        return fFontMgr ? fFontMgr : SkFontMgr::RefEmpty();
+    }
+
+    // Returns the translate/scale transformation required to map into the current OBB scope,
+    // with the specified units.
+    struct OBBTransform {
+        SkV2 offset, scale;
+    };
+    OBBTransform transformForCurrentOBB(SkSVGObjectBoundingBoxUnits) const;
+
+    SkRect resolveOBBRect(const SkSVGLength& x, const SkSVGLength& y,
+                          const SkSVGLength& w, const SkSVGLength& h,
+                          SkSVGObjectBoundingBoxUnits) const;
+
+    std::unique_ptr<SkShaper> makeShaper() const {
+        SkASSERT(fTextShapingFactory);
+        return fTextShapingFactory->makeShaper(this->fontMgr());
+    }
+
+    std::unique_ptr<SkShaper::BiDiRunIterator> makeBidiRunIterator(const char* utf8,
+                                                                   size_t utf8Bytes,
+                                                                   uint8_t bidiLevel) const {
+        SkASSERT(fTextShapingFactory);
+        return fTextShapingFactory->makeBidiRunIterator(utf8, utf8Bytes, bidiLevel);
+    }
+
+    std::unique_ptr<SkShaper::ScriptRunIterator> makeScriptRunIterator(const char* utf8,
+                                                                       size_t utf8Bytes) const {
+        SkASSERT(fTextShapingFactory);
+        constexpr SkFourByteTag unknownScript = SkSetFourByteTag('Z', 'z', 'z', 'z');
+        return fTextShapingFactory->makeScriptRunIterator(utf8, utf8Bytes, unknownScript);
+    }
+
+private:
+    // Stack-only
+    void* operator new(size_t)                               = delete;
+    void* operator new(size_t, void*)                        = delete;
+    SkSVGRenderContext& operator=(const SkSVGRenderContext&) = delete;
+
+    void applyOpacity(SkScalar opacity, uint32_t flags, bool hasFilter);
+    void applyFilter(const SkSVGFuncIRI&);
+    void applyClip(const SkSVGFuncIRI&);
+    void applyMask(const SkSVGFuncIRI&);
+
+    SkTLazy<SkPaint> commonPaint(const SkSVGPaint&, float opacity) const;
+
+    const sk_sp<SkFontMgr>&                       fFontMgr;
+    const sk_sp<SkShapers::Factory>&              fTextShapingFactory;
+    const sk_sp<skresources::ResourceProvider>&   fResourceProvider;
+    const SkSVGIDMapper&                          fIDMapper;
+    SkTCopyOnFirstWrite<SkSVGLengthContext>       fLengthContext;
+    SkTCopyOnFirstWrite<SkSVGPresentationContext> fPresentationContext;
+    SkCanvas*                                     fCanvas;
+    // The save count on 'fCanvas' at construction time.
+    // A restoreToCount() will be issued on destruction.
+    int                                           fCanvasSaveCount;
+
+    // clipPath, if present for the current context (not inherited).
+    SkTLazy<SkPath>                               fClipPath;
+
+    // Deferred opacity optimization for leaf nodes.
+    float                                         fDeferredPaintOpacity = 1;
+
+    // Current object bounding box scope.
+    const OBBScope                                fOBBScope;
+};
+
+#endif // SkSVGRenderContext_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h
new file mode 100644
index 00000000..b45555b1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGSVG_DEFINED
+#define SkSVGSVG_DEFINED
+
+#include "modules/svg/include/SkSVGContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkTLazy.h"
+
+class SkSVGLengthContext;
+
+class SK_API SkSVGSVG : public SkSVGContainer {
+public:
+    enum class Type {
+        kRoot,
+        kInner,
+    };
+    static sk_sp<SkSVGSVG> Make(Type t = Type::kInner) { return sk_sp<SkSVGSVG>(new SkSVGSVG(t)); }
+
+    SVG_ATTR(X                  , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y                  , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Width              , SkSVGLength, SkSVGLength(100, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Height             , SkSVGLength, SkSVGLength(100, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(PreserveAspectRatio, SkSVGPreserveAspectRatio, SkSVGPreserveAspectRatio())
+
+    SVG_OPTIONAL_ATTR(ViewBox, SkSVGViewBoxType)
+
+    SkSize intrinsicSize(const SkSVGLengthContext&) const;
+
+    void renderNode(const SkSVGRenderContext&, const SkSVGIRI& iri) const;
+
+protected:
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+
+    void onSetAttribute(SkSVGAttribute, const SkSVGValue&) override;
+
+private:
+    explicit SkSVGSVG(Type t)
+        : INHERITED(SkSVGTag::kSvg)
+        , fType(t)
+    {}
+
+    // Some attributes behave differently for the outermost svg element.
+    const Type fType;
+
+    using INHERITED = SkSVGContainer;
+};
+
+#endif // SkSVGSVG_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h
new file mode 100644
index 00000000..49d7a621
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGShape_DEFINED
+#define SkSVGShape_DEFINED
+
+#include "include/core/SkPath.h"
+#include "modules/svg/include/SkSVGTransformableNode.h"
+
+class SkSVGLengthContext;
+class SkPaint;
+
+class SK_API SkSVGShape : public SkSVGTransformableNode {
+public:
+    void appendChild(sk_sp<SkSVGNode>) override;
+
+protected:
+    SkSVGShape(SkSVGTag);
+
+    void onRender(const SkSVGRenderContext&) const final;
+
+    virtual void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                        SkPathFillType) const = 0;
+
+private:
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif // SkSVGShape_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h
new file mode 100644
index 00000000..8a3a7f66
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGStop_DEFINED
+#define SkSVGStop_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGLengthContext;
+
+class SK_API SkSVGStop : public SkSVGHiddenContainer {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kStop;
+
+    static sk_sp<SkSVGStop> Make() {
+        return sk_sp<SkSVGStop>(new SkSVGStop());
+    }
+
+    SVG_ATTR(Offset, SkSVGLength, SkSVGLength(0, SkSVGLength::Unit::kPercentage))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGStop();
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGStop_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGText.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGText.h
new file mode 100644
index 00000000..a9aca608
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGText.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2019 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGText_DEFINED
+#define SkSVGText_DEFINED
+
+#include <vector>
+
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGTextContext;
+
+// Base class for text-rendering nodes.
+class SkSVGTextFragment : public SkSVGTransformableNode {
+public:
+    void renderText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const;
+
+protected:
+    explicit SkSVGTextFragment(SkSVGTag t) : INHERITED(t) {}
+
+    virtual void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const = 0;
+
+    // Text nodes other than the root <text> element are not rendered directly.
+    void onRender(const SkSVGRenderContext&) const override {}
+
+private:
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    using INHERITED = SkSVGTransformableNode;
+};
+
+// Base class for nestable text containers (<text>, <tspan>, etc).
+class SkSVGTextContainer : public SkSVGTextFragment {
+public:
+    SVG_ATTR(X, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Y, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Dx, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Dy, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Rotate, std::vector<SkSVGNumberType>, {})
+
+    SVG_ATTR(XmlSpace, SkSVGXmlSpace, SkSVGXmlSpace::kDefault)
+
+    void appendChild(sk_sp<SkSVGNode>) final;
+
+protected:
+    explicit SkSVGTextContainer(SkSVGTag t) : INHERITED(t) {}
+
+    void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const override;
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    std::vector<sk_sp<SkSVGTextFragment>> fChildren;
+
+    using INHERITED = SkSVGTextFragment;
+};
+
+class SkSVGText final : public SkSVGTextContainer {
+public:
+    static sk_sp<SkSVGText> Make() { return sk_sp<SkSVGText>(new SkSVGText()); }
+
+private:
+    SkSVGText() : INHERITED(SkSVGTag::kText) {}
+
+    void onRender(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    using INHERITED = SkSVGTextContainer;
+};
+
+class SkSVGTSpan final : public SkSVGTextContainer {
+public:
+    static sk_sp<SkSVGTSpan> Make() { return sk_sp<SkSVGTSpan>(new SkSVGTSpan()); }
+
+private:
+    SkSVGTSpan() : INHERITED(SkSVGTag::kTSpan) {}
+
+    using INHERITED = SkSVGTextContainer;
+};
+
+class SkSVGTextLiteral final : public SkSVGTextFragment {
+public:
+    static sk_sp<SkSVGTextLiteral> Make() {
+        return sk_sp<SkSVGTextLiteral>(new SkSVGTextLiteral());
+    }
+
+    SVG_ATTR(Text, SkSVGStringType, SkSVGStringType())
+
+private:
+    SkSVGTextLiteral() : INHERITED(SkSVGTag::kTextLiteral) {}
+
+    void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const override;
+
+    void appendChild(sk_sp<SkSVGNode>) override {}
+
+    using INHERITED = SkSVGTextFragment;
+};
+
+class SkSVGTextPath final : public SkSVGTextContainer {
+public:
+    static sk_sp<SkSVGTextPath> Make() { return sk_sp<SkSVGTextPath>(new SkSVGTextPath()); }
+
+    SVG_ATTR(Href       , SkSVGIRI   , {}  )
+    SVG_ATTR(StartOffset, SkSVGLength, SkSVGLength(0))
+
+private:
+    SkSVGTextPath() : INHERITED(SkSVGTag::kTextPath) {}
+
+    void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const override;
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGTextContainer;
+};
+
+#endif  // SkSVGText_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h
new file mode 100644
index 00000000..bb74e288
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGTransformableNode_DEFINED
+#define SkSVGTransformableNode_DEFINED
+
+#include "include/core/SkMatrix.h"
+#include "modules/svg/include/SkSVGNode.h"
+
+class SK_API SkSVGTransformableNode : public SkSVGNode {
+public:
+    void setTransform(const SkSVGTransformType& t) { fTransform = t; }
+
+protected:
+    SkSVGTransformableNode(SkSVGTag);
+
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+
+    void onSetAttribute(SkSVGAttribute, const SkSVGValue&) override;
+
+    void mapToParent(SkPath*) const;
+
+    void mapToParent(SkRect*) const;
+
+private:
+    // FIXME: should be sparse
+    SkSVGTransformType fTransform;
+
+    using INHERITED = SkSVGNode;
+};
+
+#endif // SkSVGTransformableNode_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h
new file mode 100644
index 00000000..f03d8c27
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h
@@ -0,0 +1,740 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGTypes_DEFINED
+#define SkSVGTypes_DEFINED
+
+#include "include/core/SkColor.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkPoint.h"
+#include "include/core/SkRect.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkScalar.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+
+#include <optional>
+#include <vector>
+
+using SkSVGColorType     = SkColor;
+using SkSVGIntegerType   = int;
+using SkSVGNumberType    = SkScalar;
+using SkSVGStringType    = SkString;
+using SkSVGViewBoxType   = SkRect;
+using SkSVGTransformType = SkMatrix;
+using SkSVGPointsType    = std::vector<SkPoint>;
+
+enum class SkSVGPropertyState {
+    kUnspecified,
+    kInherit,
+    kValue,
+};
+
+// https://www.w3.org/TR/SVG11/intro.html#TermProperty
+template <typename T, bool kInheritable> class SkSVGProperty {
+public:
+    using ValueT = T;
+
+    SkSVGProperty() : fState(SkSVGPropertyState::kUnspecified) {}
+
+    explicit SkSVGProperty(SkSVGPropertyState state) : fState(state) {}
+
+    explicit SkSVGProperty(const T& value) : fState(SkSVGPropertyState::kValue) {
+        fValue = value;
+    }
+
+    explicit SkSVGProperty(T&& value) : fState(SkSVGPropertyState::kValue) {
+        fValue = std::move(value);
+    }
+
+    template <typename... Args>
+    void init(Args&&... args) {
+        fState = SkSVGPropertyState::kValue;
+        fValue.emplace(std::forward<Args>(args)...);
+    }
+
+    constexpr bool isInheritable() const { return kInheritable; }
+
+    bool isValue() const { return fState == SkSVGPropertyState::kValue; }
+
+    T* getMaybeNull() const {
+        return fValue.has_value() ? &fValue.value() : nullptr;
+    }
+
+    void set(SkSVGPropertyState state) {
+        fState = state;
+        if (fState != SkSVGPropertyState::kValue) {
+            fValue.reset();
+        }
+    }
+
+    void set(const T& value) {
+        fState = SkSVGPropertyState::kValue;
+        fValue = value;
+    }
+
+    void set(T&& value) {
+        fState = SkSVGPropertyState::kValue;
+        fValue = std::move(value);
+    }
+
+    T* operator->() {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return &fValue.value();
+    }
+
+    const T* operator->() const {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return &fValue.value();
+    }
+
+    T& operator*() {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return *fValue;
+    }
+
+    const T& operator*() const {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return *fValue;
+    }
+
+private:
+    SkSVGPropertyState fState;
+    std::optional<T>   fValue;
+};
+
+class SK_API SkSVGLength {
+public:
+    enum class Unit {
+        kUnknown,
+        kNumber,
+        kPercentage,
+        kEMS,
+        kEXS,
+        kPX,
+        kCM,
+        kMM,
+        kIN,
+        kPT,
+        kPC,
+    };
+
+    constexpr SkSVGLength()                    : fValue(0), fUnit(Unit::kUnknown) {}
+    explicit constexpr SkSVGLength(SkScalar v, Unit u = Unit::kNumber)
+        : fValue(v), fUnit(u) {}
+    SkSVGLength(const SkSVGLength&)            = default;
+    SkSVGLength& operator=(const SkSVGLength&) = default;
+
+    bool operator==(const SkSVGLength& other) const {
+        return fUnit == other.fUnit && fValue == other.fValue;
+    }
+    bool operator!=(const SkSVGLength& other) const { return !(*this == other); }
+
+    const SkScalar& value() const { return fValue; }
+    const Unit&     unit()  const { return fUnit;  }
+
+private:
+    SkScalar fValue;
+    Unit     fUnit;
+};
+
+// https://www.w3.org/TR/SVG11/linking.html#IRIReference
+class SK_API SkSVGIRI {
+public:
+    enum class Type {
+        kLocal,
+        kNonlocal,
+        kDataURI,
+    };
+
+    SkSVGIRI() : fType(Type::kLocal) {}
+    SkSVGIRI(Type t, const SkSVGStringType& iri) : fType(t), fIRI(iri) {}
+
+    Type type() const { return fType; }
+    const SkSVGStringType& iri() const { return fIRI; }
+
+    bool operator==(const SkSVGIRI& other) const {
+        return fType == other.fType && fIRI == other.fIRI;
+    }
+    bool operator!=(const SkSVGIRI& other) const { return !(*this == other); }
+
+private:
+    Type fType;
+    SkSVGStringType fIRI;
+};
+
+// https://www.w3.org/TR/SVG11/types.html#InterfaceSVGColor
+class SK_API SkSVGColor {
+public:
+    enum class Type {
+        kCurrentColor,
+        kColor,
+        kICCColor,
+    };
+    using Vars = std::vector<SkString>;
+
+    SkSVGColor() : SkSVGColor(SK_ColorBLACK) {}
+    explicit SkSVGColor(const SkSVGColorType& c) : fType(Type::kColor), fColor(c), fVars(nullptr) {}
+    explicit SkSVGColor(Type t, Vars&& vars)
+        : fType(t), fColor(SK_ColorBLACK)
+        , fVars(vars.empty() ? nullptr : new RefCntVars(std::move(vars))) {}
+    explicit SkSVGColor(const SkSVGColorType& c, Vars&& vars)
+        : fType(Type::kColor), fColor(c)
+        , fVars(vars.empty() ? nullptr : new RefCntVars(std::move(vars))) {}
+
+    SkSVGColor(const SkSVGColor&)            = default;
+    SkSVGColor& operator=(const SkSVGColor&) = default;
+    SkSVGColor(SkSVGColor&&)                 = default;
+    SkSVGColor& operator=(SkSVGColor&&)      = default;
+
+    bool operator==(const SkSVGColor& other) const {
+        return fType == other.fType && fColor == other.fColor && fVars == other.fVars;
+    }
+    bool operator!=(const SkSVGColor& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGColorType& color() const { SkASSERT(fType == Type::kColor); return fColor; }
+    SkSpan<const SkString> vars() const {
+        return fVars ? SkSpan<const SkString>(fVars->fData) : SkSpan<const SkString>();
+    }
+    SkSpan<SkString> vars()       {
+        return fVars ? SkSpan<SkString>(fVars->fData) : SkSpan<SkString>();
+    }
+
+private:
+    Type fType;
+    SkSVGColorType fColor;
+    struct RefCntVars : public SkNVRefCnt<RefCntVars> {
+        RefCntVars(Vars&& vars) : fData(std::move(vars)) {}
+        Vars fData;
+    };
+    sk_sp<RefCntVars> fVars;
+};
+
+class SK_API SkSVGPaint {
+public:
+    enum class Type {
+        kNone,
+        kColor,
+        kIRI,
+    };
+
+    SkSVGPaint() : fType(Type::kNone), fColor(SK_ColorBLACK) {}
+    explicit SkSVGPaint(Type t) : fType(t), fColor(SK_ColorBLACK) {}
+    explicit SkSVGPaint(SkSVGColor c) : fType(Type::kColor), fColor(std::move(c)) {}
+    SkSVGPaint(const SkSVGIRI& iri, SkSVGColor fallback_color)
+        : fType(Type::kIRI), fColor(std::move(fallback_color)), fIRI(iri) {}
+
+    SkSVGPaint(const SkSVGPaint&)            = default;
+    SkSVGPaint& operator=(const SkSVGPaint&) = default;
+    SkSVGPaint(SkSVGPaint&&)                 = default;
+    SkSVGPaint& operator=(SkSVGPaint&&)      = default;
+
+    bool operator==(const SkSVGPaint& other) const {
+        return fType == other.fType && fColor == other.fColor && fIRI == other.fIRI;
+    }
+    bool operator!=(const SkSVGPaint& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGColor& color() const {
+        SkASSERT(fType == Type::kColor || fType == Type::kIRI);
+        return fColor;
+    }
+    const SkSVGIRI& iri() const { SkASSERT(fType == Type::kIRI); return fIRI; }
+
+private:
+    Type fType;
+
+    // Logical union.
+    SkSVGColor fColor;
+    SkSVGIRI   fIRI;
+};
+
+// <funciri> | none (used for clip/mask/filter properties)
+class SK_API SkSVGFuncIRI {
+public:
+    enum class Type {
+        kNone,
+        kIRI,
+    };
+
+    SkSVGFuncIRI() : fType(Type::kNone) {}
+    explicit SkSVGFuncIRI(Type t) : fType(t) {}
+    explicit SkSVGFuncIRI(SkSVGIRI&& iri) : fType(Type::kIRI), fIRI(std::move(iri)) {}
+
+    bool operator==(const SkSVGFuncIRI& other) const {
+        return fType == other.fType && fIRI == other.fIRI;
+    }
+    bool operator!=(const SkSVGFuncIRI& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGIRI& iri() const { SkASSERT(fType == Type::kIRI); return fIRI; }
+
+private:
+    Type           fType;
+    SkSVGIRI       fIRI;
+};
+
+enum class SkSVGLineCap {
+    kButt,
+    kRound,
+    kSquare,
+};
+
+class SK_API SkSVGLineJoin {
+public:
+    enum class Type {
+        kMiter,
+        kRound,
+        kBevel,
+        kInherit,
+    };
+
+    constexpr SkSVGLineJoin() : fType(Type::kInherit) {}
+    constexpr explicit SkSVGLineJoin(Type t) : fType(t) {}
+
+    SkSVGLineJoin(const SkSVGLineJoin&)            = default;
+    SkSVGLineJoin& operator=(const SkSVGLineJoin&) = default;
+
+    bool operator==(const SkSVGLineJoin& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGLineJoin& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGSpreadMethod {
+public:
+    // These values must match Skia's SkShader::TileMode enum.
+    enum class Type {
+        kPad,       // kClamp_TileMode
+        kRepeat,    // kRepeat_TileMode
+        kReflect,   // kMirror_TileMode
+    };
+
+    constexpr SkSVGSpreadMethod() : fType(Type::kPad) {}
+    constexpr explicit SkSVGSpreadMethod(Type t) : fType(t) {}
+
+    SkSVGSpreadMethod(const SkSVGSpreadMethod&)            = default;
+    SkSVGSpreadMethod& operator=(const SkSVGSpreadMethod&) = default;
+
+    bool operator==(const SkSVGSpreadMethod& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGSpreadMethod& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGFillRule {
+public:
+    enum class Type {
+        kNonZero,
+        kEvenOdd,
+        kInherit,
+    };
+
+    constexpr SkSVGFillRule() : fType(Type::kInherit) {}
+    constexpr explicit SkSVGFillRule(Type t) : fType(t) {}
+
+    SkSVGFillRule(const SkSVGFillRule&)            = default;
+    SkSVGFillRule& operator=(const SkSVGFillRule&) = default;
+
+    bool operator==(const SkSVGFillRule& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGFillRule& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    SkPathFillType asFillType() const {
+        SkASSERT(fType != Type::kInherit); // should never be called for unresolved values.
+        return fType == Type::kEvenOdd ? SkPathFillType::kEvenOdd : SkPathFillType::kWinding;
+    }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGVisibility {
+public:
+    enum class Type {
+        kVisible,
+        kHidden,
+        kCollapse,
+        kInherit,
+    };
+
+    constexpr SkSVGVisibility() : fType(Type::kVisible) {}
+    constexpr explicit SkSVGVisibility(Type t) : fType(t) {}
+
+    SkSVGVisibility(const SkSVGVisibility&)            = default;
+    SkSVGVisibility& operator=(const SkSVGVisibility&) = default;
+
+    bool operator==(const SkSVGVisibility& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGVisibility& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGDashArray {
+public:
+    enum class Type {
+        kNone,
+        kDashArray,
+        kInherit,
+    };
+
+    SkSVGDashArray()                : fType(Type::kNone) {}
+    explicit SkSVGDashArray(Type t) : fType(t) {}
+    explicit SkSVGDashArray(std::vector<SkSVGLength>&& dashArray)
+        : fType(Type::kDashArray)
+        , fDashArray(std::move(dashArray)) {}
+
+    SkSVGDashArray(const SkSVGDashArray&)            = default;
+    SkSVGDashArray& operator=(const SkSVGDashArray&) = default;
+
+    bool operator==(const SkSVGDashArray& other) const {
+        return fType == other.fType && fDashArray == other.fDashArray;
+    }
+    bool operator!=(const SkSVGDashArray& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    const std::vector<SkSVGLength>& dashArray() const { return fDashArray; }
+
+private:
+    Type fType;
+    std::vector<SkSVGLength> fDashArray;
+};
+
+class SK_API SkSVGStopColor {
+public:
+    enum class Type {
+        kColor,
+        kCurrentColor,
+        kICCColor,
+        kInherit,
+    };
+
+    SkSVGStopColor() : fType(Type::kColor), fColor(SK_ColorBLACK) {}
+    explicit SkSVGStopColor(Type t) : fType(t), fColor(SK_ColorBLACK) {}
+    explicit SkSVGStopColor(const SkSVGColorType& c) : fType(Type::kColor), fColor(c) {}
+
+    SkSVGStopColor(const SkSVGStopColor&)            = default;
+    SkSVGStopColor& operator=(const SkSVGStopColor&) = default;
+
+    bool operator==(const SkSVGStopColor& other) const {
+        return fType == other.fType && fColor == other.fColor;
+    }
+    bool operator!=(const SkSVGStopColor& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGColorType& color() const { SkASSERT(fType == Type::kColor); return fColor; }
+
+private:
+    Type fType;
+    SkSVGColorType fColor;
+};
+
+class SK_API SkSVGObjectBoundingBoxUnits {
+public:
+    enum class Type {
+        kUserSpaceOnUse,
+        kObjectBoundingBox,
+    };
+
+    SkSVGObjectBoundingBoxUnits() : fType(Type::kUserSpaceOnUse) {}
+    explicit SkSVGObjectBoundingBoxUnits(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGObjectBoundingBoxUnits& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGObjectBoundingBoxUnits& other) const {
+        return !(*this == other);
+    }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGFontFamily {
+public:
+    enum class Type {
+        kFamily,
+        kInherit,
+    };
+
+    SkSVGFontFamily() : fType(Type::kInherit) {}
+    explicit SkSVGFontFamily(const char family[])
+        : fType(Type::kFamily)
+        , fFamily(family) {}
+
+    bool operator==(const SkSVGFontFamily& other) const {
+        return fType == other.fType && fFamily == other.fFamily;
+    }
+    bool operator!=(const SkSVGFontFamily& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    const SkString& family() const { return fFamily; }
+
+private:
+    Type     fType;
+    SkString fFamily;
+};
+
+class SK_API SkSVGFontStyle {
+public:
+    enum class Type {
+        kNormal,
+        kItalic,
+        kOblique,
+        kInherit,
+    };
+
+    SkSVGFontStyle() : fType(Type::kInherit) {}
+    explicit SkSVGFontStyle(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGFontStyle& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGFontStyle& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGFontSize {
+public:
+    enum class Type {
+        kLength,
+        kInherit,
+    };
+
+    SkSVGFontSize() : fType(Type::kInherit), fSize(0) {}
+    explicit SkSVGFontSize(const SkSVGLength& s)
+        : fType(Type::kLength)
+        , fSize(s) {}
+
+    bool operator==(const SkSVGFontSize& other) const {
+        return fType == other.fType && fSize == other.fSize;
+    }
+    bool operator!=(const SkSVGFontSize& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    const SkSVGLength& size() const { return fSize; }
+
+private:
+    Type        fType;
+    SkSVGLength fSize;
+};
+
+class SK_API SkSVGFontWeight {
+public:
+    enum class Type {
+        k100,
+        k200,
+        k300,
+        k400,
+        k500,
+        k600,
+        k700,
+        k800,
+        k900,
+        kNormal,
+        kBold,
+        kBolder,
+        kLighter,
+        kInherit,
+    };
+
+    SkSVGFontWeight() : fType(Type::kInherit) {}
+    explicit SkSVGFontWeight(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGFontWeight& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGFontWeight& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+struct SK_API SkSVGPreserveAspectRatio {
+    enum Align : uint8_t {
+        // These values are chosen such that bits [0,1] encode X alignment, and
+        // bits [2,3] encode Y alignment.
+        kXMinYMin = 0x00,
+        kXMidYMin = 0x01,
+        kXMaxYMin = 0x02,
+        kXMinYMid = 0x04,
+        kXMidYMid = 0x05,
+        kXMaxYMid = 0x06,
+        kXMinYMax = 0x08,
+        kXMidYMax = 0x09,
+        kXMaxYMax = 0x0a,
+
+        kNone     = 0x10,
+    };
+
+    enum Scale {
+        kMeet,
+        kSlice,
+    };
+
+    Align fAlign = kXMidYMid;
+    Scale fScale = kMeet;
+};
+
+class SK_API SkSVGTextAnchor {
+public:
+    enum class Type {
+        kStart,
+        kMiddle,
+        kEnd,
+        kInherit,
+    };
+
+    SkSVGTextAnchor() : fType(Type::kInherit) {}
+    explicit SkSVGTextAnchor(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGTextAnchor& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGTextAnchor& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+// https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveInAttribute
+class SK_API SkSVGFeInputType {
+public:
+    enum class Type {
+        kSourceGraphic,
+        kSourceAlpha,
+        kBackgroundImage,
+        kBackgroundAlpha,
+        kFillPaint,
+        kStrokePaint,
+        kFilterPrimitiveReference,
+        kUnspecified,
+    };
+
+    SkSVGFeInputType() : fType(Type::kUnspecified) {}
+    explicit SkSVGFeInputType(Type t) : fType(t) {}
+    explicit SkSVGFeInputType(const SkSVGStringType& id)
+            : fType(Type::kFilterPrimitiveReference), fId(id) {}
+
+    bool operator==(const SkSVGFeInputType& other) const {
+        return fType == other.fType && fId == other.fId;
+    }
+    bool operator!=(const SkSVGFeInputType& other) const { return !(*this == other); }
+
+    const SkString& id() const {
+        SkASSERT(fType == Type::kFilterPrimitiveReference);
+        return fId;
+    }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+    SkString fId;
+};
+
+enum class SkSVGFeColorMatrixType {
+    kMatrix,
+    kSaturate,
+    kHueRotate,
+    kLuminanceToAlpha,
+};
+
+using SkSVGFeColorMatrixValues = std::vector<SkSVGNumberType>;
+
+enum class SkSVGFeCompositeOperator {
+    kOver,
+    kIn,
+    kOut,
+    kAtop,
+    kXor,
+    kArithmetic,
+};
+
+class SK_API SkSVGFeTurbulenceBaseFrequency {
+public:
+    SkSVGFeTurbulenceBaseFrequency() : fFreqX(0), fFreqY(0) {}
+    SkSVGFeTurbulenceBaseFrequency(SkSVGNumberType freqX, SkSVGNumberType freqY)
+            : fFreqX(freqX), fFreqY(freqY) {}
+
+    SkSVGNumberType freqX() const { return fFreqX; }
+    SkSVGNumberType freqY() const { return fFreqY; }
+
+private:
+    SkSVGNumberType fFreqX;
+    SkSVGNumberType fFreqY;
+};
+
+struct SK_API SkSVGFeTurbulenceType {
+    enum Type {
+        kFractalNoise,
+        kTurbulence,
+    };
+
+    Type fType;
+
+    SkSVGFeTurbulenceType() : fType(kTurbulence) {}
+    explicit SkSVGFeTurbulenceType(Type type) : fType(type) {}
+};
+
+enum class SkSVGXmlSpace {
+    kDefault,
+    kPreserve,
+};
+
+enum class SkSVGColorspace {
+    kAuto,
+    kSRGB,
+    kLinearRGB,
+};
+
+// https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
+enum class SkSVGDisplay {
+    kInline,
+    kNone,
+};
+
+// https://www.w3.org/TR/SVG11/filters.html#TransferFunctionElementAttributes
+enum class SkSVGFeFuncType {
+    kIdentity,
+    kTable,
+    kDiscrete,
+    kLinear,
+    kGamma,
+};
+
+#endif // SkSVGTypes_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h
new file mode 100644
index 00000000..1b41614a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGUse_DEFINED
+#define SkSVGUse_DEFINED
+
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+/**
+ * Implements support for <use> (reference) elements.
+ * (https://www.w3.org/TR/SVG11/struct.html#UseElement)
+ */
+class SK_API SkSVGUse final : public SkSVGTransformableNode {
+public:
+    static sk_sp<SkSVGUse> Make() { return sk_sp<SkSVGUse>(new SkSVGUse()); }
+
+    void appendChild(sk_sp<SkSVGNode>) override;
+
+    SVG_ATTR(X   , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y   , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Href, SkSVGIRI   , SkSVGIRI())
+
+protected:
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+    void onRender(const SkSVGRenderContext&) const override;
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGUse();
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif // SkSVGUse_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h
new file mode 100644
index 00000000..5a574b9b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGValue_DEFINED
+#define SkSVGValue_DEFINED
+
+#include "include/core/SkColor.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkNoncopyable.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGValue : public SkNoncopyable {
+public:
+    enum class Type {
+        kColor,
+        kFilter,
+        kLength,
+        kNumber,
+        kObjectBoundingBoxUnits,
+        kPreserveAspectRatio,
+        kStopColor,
+        kString,
+        kTransform,
+        kViewBox,
+    };
+
+    Type type() const { return fType; }
+
+    template <typename T>
+    const T* as() const {
+        return fType == T::TYPE ? static_cast<const T*>(this) : nullptr;
+    }
+
+protected:
+    SkSVGValue(Type t) : fType(t) { }
+
+private:
+    Type fType;
+
+    using INHERITED = SkNoncopyable;
+};
+
+template <typename T, SkSVGValue::Type ValueType>
+class SK_API SkSVGWrapperValue final : public SkSVGValue {
+public:
+    static constexpr Type TYPE = ValueType;
+
+    explicit SkSVGWrapperValue(const T& v)
+        : INHERITED(ValueType)
+        , fWrappedValue(v) { }
+
+    operator const T&() const { return fWrappedValue; }
+    const T* operator->() const { return &fWrappedValue; }
+
+private:
+    // Stack-only
+    void* operator new(size_t) = delete;
+    void* operator new(size_t, void*) = delete;
+
+    const T& fWrappedValue;
+
+    using INHERITED = SkSVGValue;
+};
+
+using SkSVGColorValue        = SkSVGWrapperValue<SkSVGColorType    , SkSVGValue::Type::kColor     >;
+using SkSVGLengthValue       = SkSVGWrapperValue<SkSVGLength       , SkSVGValue::Type::kLength    >;
+using SkSVGTransformValue    = SkSVGWrapperValue<SkSVGTransformType, SkSVGValue::Type::kTransform >;
+using SkSVGViewBoxValue      = SkSVGWrapperValue<SkSVGViewBoxType  , SkSVGValue::Type::kViewBox   >;
+using SkSVGNumberValue       = SkSVGWrapperValue<SkSVGNumberType   , SkSVGValue::Type::kNumber    >;
+using SkSVGStringValue       = SkSVGWrapperValue<SkSVGStringType   , SkSVGValue::Type::kString    >;
+using SkSVGStopColorValue    = SkSVGWrapperValue<SkSVGStopColor    , SkSVGValue::Type::kStopColor >;
+
+using SkSVGPreserveAspectRatioValue    = SkSVGWrapperValue<SkSVGPreserveAspectRatio,
+                                                           SkSVGValue::Type::kPreserveAspectRatio>;
+
+using SkSVGObjectBoundingBoxUnitsValue = SkSVGWrapperValue<SkSVGObjectBoundingBoxUnits,
+                                                           SkSVGValue::Type::kObjectBoundingBoxUnits>;
+
+#endif // SkSVGValue_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/src/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/src/BUILD.bazel
new file mode 100644
index 00000000..e478438e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/BUILD.bazel
@@ -0,0 +1,69 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+# This group is exported as //modules/svg/svg.gni:skia_svg_sources.
+skia_filegroup(
+    name = "private_hdrs",
+    srcs = [
+        "SkSVGRectPriv.h",
+        "SkSVGTextPriv.h",
+    ],
+    visibility = ["//modules/svg:__pkg__"],
+)
+
+# This group is exported as //modules/svg/svg.gni:skia_svg_sources.
+skia_filegroup(
+    name = "srcs",
+    srcs = [
+        "SkSVGAttribute.cpp",
+        "SkSVGAttributeParser.cpp",
+        "SkSVGCircle.cpp",
+        "SkSVGClipPath.cpp",
+        "SkSVGContainer.cpp",
+        "SkSVGDOM.cpp",
+        "SkSVGEllipse.cpp",
+        "SkSVGFe.cpp",
+        "SkSVGFeBlend.cpp",
+        "SkSVGFeColorMatrix.cpp",
+        "SkSVGFeComponentTransfer.cpp",
+        "SkSVGFeComposite.cpp",
+        "SkSVGFeDisplacementMap.cpp",
+        "SkSVGFeFlood.cpp",
+        "SkSVGFeGaussianBlur.cpp",
+        "SkSVGFeImage.cpp",
+        "SkSVGFeLightSource.cpp",
+        "SkSVGFeLighting.cpp",
+        "SkSVGFeMerge.cpp",
+        "SkSVGFeMorphology.cpp",
+        "SkSVGFeOffset.cpp",
+        "SkSVGFeTurbulence.cpp",
+        "SkSVGFilter.cpp",
+        "SkSVGFilterContext.cpp",
+        "SkSVGGradient.cpp",
+        "SkSVGImage.cpp",
+        "SkSVGLine.cpp",
+        "SkSVGLinearGradient.cpp",
+        "SkSVGMask.cpp",
+        "SkSVGNode.cpp",
+        "SkSVGOpenTypeSVGDecoder.cpp",
+        "SkSVGPath.cpp",
+        "SkSVGPattern.cpp",
+        "SkSVGPoly.cpp",
+        "SkSVGRadialGradient.cpp",
+        "SkSVGRect.cpp",
+        "SkSVGRenderContext.cpp",
+        "SkSVGSVG.cpp",
+        "SkSVGShape.cpp",
+        "SkSVGStop.cpp",
+        "SkSVGText.cpp",
+        "SkSVGTransformableNode.cpp",
+        "SkSVGUse.cpp",
+        "SkSVGValue.cpp",
+    ],
+    visibility = ["//modules/svg:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp
new file mode 100644
index 00000000..ac99e64a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGAttribute.h"
+
+SkSVGPresentationAttributes SkSVGPresentationAttributes::MakeInitial() {
+    SkSVGPresentationAttributes result;
+
+    result.fFill.set(SkSVGPaint(SkSVGColor(SK_ColorBLACK)));
+    result.fFillOpacity.set(SkSVGNumberType(1));
+    result.fFillRule.set(SkSVGFillRule(SkSVGFillRule::Type::kNonZero));
+    result.fClipRule.set(SkSVGFillRule(SkSVGFillRule::Type::kNonZero));
+
+    result.fStroke.set(SkSVGPaint(SkSVGPaint::Type::kNone));
+    result.fStrokeDashArray.set(SkSVGDashArray(SkSVGDashArray::Type::kNone));
+    result.fStrokeDashOffset.set(SkSVGLength(0));
+    result.fStrokeLineCap.set(SkSVGLineCap::kButt);
+    result.fStrokeLineJoin.set(SkSVGLineJoin(SkSVGLineJoin::Type::kMiter));
+    result.fStrokeMiterLimit.set(SkSVGNumberType(4));
+    result.fStrokeOpacity.set(SkSVGNumberType(1));
+    result.fStrokeWidth.set(SkSVGLength(1));
+
+    result.fVisibility.set(SkSVGVisibility(SkSVGVisibility::Type::kVisible));
+
+    result.fColor.set(SkSVGColorType(SK_ColorBLACK));
+    result.fColorInterpolation.set(SkSVGColorspace::kSRGB);
+    result.fColorInterpolationFilters.set(SkSVGColorspace::kLinearRGB);
+
+    result.fFontFamily.init("Sans");
+    result.fFontStyle.init(SkSVGFontStyle::Type::kNormal);
+    result.fFontSize.init(SkSVGLength(24));
+    result.fFontWeight.init(SkSVGFontWeight::Type::kNormal);
+    result.fTextAnchor.init(SkSVGTextAnchor::Type::kStart);
+
+    result.fDisplay.init(SkSVGDisplay::kInline);
+
+    result.fStopColor.set(SkSVGColor(SK_ColorBLACK));
+    result.fStopOpacity.set(SkSVGNumberType(1));
+    result.fFloodColor.set(SkSVGColor(SK_ColorBLACK));
+    result.fFloodOpacity.set(SkSVGNumberType(1));
+    result.fLightingColor.set(SkSVGColor(SK_ColorWHITE));
+
+    return result;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp
new file mode 100644
index 00000000..0277add3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp
@@ -0,0 +1,1175 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/private/base/SkTPin.h"
+#include "include/utils/SkParse.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkUTF.h"
+
+namespace {
+
+// TODO: these should be shared with SkParse.cpp
+
+inline bool is_between(char c, char min, char max) {
+    SkASSERT(min <= max);
+    return (unsigned)(c - min) <= (unsigned)(max - min);
+}
+
+inline bool is_ws(char c) {
+    return is_between(c, 1, 32);
+}
+
+inline bool is_sep(char c) {
+    return is_ws(c) || c == ',' || c == ';';
+}
+
+inline bool is_nl(char c) {
+    return c == '\n' || c == '\r' || c == '\f';
+}
+
+inline bool is_hex(char c) {
+    return is_between(c, 'a', 'f') ||
+           is_between(c, 'A', 'F') ||
+           is_between(c, '0', '9');
+}
+
+}  // namespace
+
+SkSVGAttributeParser::SkSVGAttributeParser(const char attributeString[])
+    // TODO: need actual UTF-8 with length.
+    : fCurPos(attributeString), fEndPos(fCurPos + strlen(attributeString)) {}
+
+template <typename F>
+inline bool SkSVGAttributeParser::advanceWhile(F f) {
+    auto initial = fCurPos;
+    while (fCurPos < fEndPos && f(*fCurPos)) {
+        fCurPos++;
+    }
+    return fCurPos != initial;
+}
+
+bool SkSVGAttributeParser::matchStringToken(const char* token, const char** newPos) const {
+    const char* c = fCurPos;
+
+    while (c < fEndPos && *token && *c == *token) {
+        c++;
+        token++;
+    }
+
+    if (*token) {
+        return false;
+    }
+
+    if (newPos) {
+        *newPos = c;
+    }
+
+    return true;
+}
+
+bool SkSVGAttributeParser::parseEOSToken() {
+    return fCurPos == fEndPos;
+}
+
+bool SkSVGAttributeParser::parseSepToken() {
+    return this->advanceWhile(is_sep);
+}
+
+bool SkSVGAttributeParser::parseWSToken() {
+    return this->advanceWhile(is_ws);
+}
+
+bool SkSVGAttributeParser::parseCommaWspToken() {
+    // comma-wsp:
+    //     (wsp+ comma? wsp*) | (comma wsp*)
+    return this->parseWSToken() || this->parseExpectedStringToken(",");
+}
+
+bool SkSVGAttributeParser::parseExpectedStringToken(const char* expected) {
+    const char* newPos;
+    if (!matchStringToken(expected, &newPos)) {
+        return false;
+    }
+
+    fCurPos = newPos;
+    return true;
+}
+
+bool SkSVGAttributeParser::parseScalarToken(SkScalar* res) {
+    if (const char* next = SkParse::FindScalar(fCurPos, res)) {
+        fCurPos = next;
+        return true;
+    }
+    return false;
+}
+
+bool SkSVGAttributeParser::parseInt32Token(int32_t* res) {
+    if (const char* next = SkParse::FindS32(fCurPos, res)) {
+        fCurPos = next;
+        return true;
+    }
+    return false;
+}
+
+bool SkSVGAttributeParser::matchHexToken(const char** newPos) const {
+    *newPos = fCurPos;
+    while (*newPos < fEndPos && is_hex(**newPos)) { ++*newPos; }
+    return *newPos != fCurPos;
+}
+
+bool SkSVGAttributeParser::parseEscape(SkUnichar* c) {
+    // \(hexDigit{1,6}whitespace?|[^newline|hexDigit])
+    RestoreCurPos restoreCurPos(this);
+
+    if (!this->parseExpectedStringToken("\\")) {
+        return false;
+    }
+    const char* hexEnd;
+    if (this->matchHexToken(&hexEnd)) {
+        if (hexEnd - fCurPos > 6) {
+            hexEnd = fCurPos + 6;
+        }
+        char hexString[7];
+        size_t hexSize = hexEnd - fCurPos;
+        memcpy(hexString, fCurPos, hexSize);
+        hexString[hexSize] = '\0';
+        uint32_t cp;
+        const char* hexFound = SkParse::FindHex(hexString, &cp);
+        if (!hexFound || cp < 1 || (0xD800 <= cp && cp <= 0xDFFF) || 0x10FFFF < cp) {
+            cp = 0xFFFD;
+        }
+        *c = cp;
+        fCurPos = hexEnd;
+        this->parseWSToken();
+    } else if (this->parseEOSToken() || is_nl(*fCurPos)) {
+        *c = 0xFFFD;
+        return false;
+    } else {
+        if ((*c = SkUTF::NextUTF8(&fCurPos, fEndPos)) < 0) {
+            return false;
+        }
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseIdentToken(SkString* ident) {
+    // <ident-token>
+    // (--|-?([a-z|A-Z|_|non-ASCII]|escape))([a-z|A-Z|0-9|_|-|non-ASCII]|escape)?
+    RestoreCurPos restoreCurPos(this);
+
+    SkUnichar c;
+    if (this->parseExpectedStringToken("--")) {
+        ident->append("--");
+    } else {
+        if (this->parseExpectedStringToken("-")) {
+            ident->append("-");
+        }
+        if (this->parseEscape(&c)) {
+            ident->appendUnichar(c);
+        } else {
+            if ((c = SkUTF::NextUTF8(&fCurPos, fEndPos)) < 0) {
+                return false;
+            }
+            if ((c < 'a' || 'z' < c) &&
+                (c < 'A' || 'Z' < c) &&
+                (c != '_') &&
+                (c < 0x80 || 0x10FFFF < c))
+            {
+                return false;
+            }
+            ident->appendUnichar(c);
+        }
+    }
+    while (fCurPos < fEndPos) {
+        if (this->parseEscape(&c)) {
+            ident->appendUnichar(c);
+            continue;
+        }
+        const char* next = fCurPos;
+        if ((c = SkUTF::NextUTF8(&next, fEndPos)) < 0) {
+            break;
+        }
+        if ((c < 'a' || 'z' < c) &&
+            (c < 'A' || 'Z' < c) &&
+            (c < '0' || '9' < c) &&
+            (c != '_') &&
+            (c != '-') &&
+            (c < 0x80 || 0x10FFFF < c))
+        {
+            break;
+        }
+        ident->appendUnichar(c);
+        fCurPos = next;
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseLengthUnitToken(SkSVGLength::Unit* unit) {
+    static const struct {
+        const char*       fUnitName;
+        SkSVGLength::Unit fUnit;
+    } gUnitInfo[] = {
+        { "%" , SkSVGLength::Unit::kPercentage },
+        { "em", SkSVGLength::Unit::kEMS        },
+        { "ex", SkSVGLength::Unit::kEXS        },
+        { "px", SkSVGLength::Unit::kPX         },
+        { "cm", SkSVGLength::Unit::kCM         },
+        { "mm", SkSVGLength::Unit::kMM         },
+        { "in", SkSVGLength::Unit::kIN         },
+        { "pt", SkSVGLength::Unit::kPT         },
+        { "pc", SkSVGLength::Unit::kPC         },
+    };
+
+    for (size_t i = 0; i < std::size(gUnitInfo); ++i) {
+        if (this->parseExpectedStringToken(gUnitInfo[i].fUnitName)) {
+            *unit = gUnitInfo[i].fUnit;
+            return true;
+        }
+    }
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeColor
+bool SkSVGAttributeParser::parseNamedColorToken(SkColor* c) {
+    RestoreCurPos restoreCurPos(this);
+
+    SkString ident;
+    if (!this->parseIdentToken(&ident)) {
+        return false;
+    }
+    if (!SkParse::FindNamedColor(ident.c_str(), ident.size(), c)) {
+        return false;
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseHexColorToken(SkColor* c) {
+    RestoreCurPos restoreCurPos(this);
+
+    const char* hexEnd;
+    if (!this->parseExpectedStringToken("#") || !this->matchHexToken(&hexEnd)) {
+        return false;
+    }
+
+    uint32_t v;
+    SkString hexString(fCurPos, hexEnd - fCurPos);
+    SkParse::FindHex(hexString.c_str(), &v);
+
+    switch (hexString.size()) {
+    case 6:
+        // matched #xxxxxxx
+        break;
+    case 3:
+        // matched '#xxx;
+        v = ((v << 12) & 0x00f00000) |
+            ((v <<  8) & 0x000ff000) |
+            ((v <<  4) & 0x00000ff0) |
+            ((v <<  0) & 0x0000000f);
+        break;
+    default:
+        return false;
+    }
+
+    *c = v | 0xff000000;
+    fCurPos = hexEnd;
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseColorComponentIntegralToken(int32_t* c) {
+    const char* p = SkParse::FindS32(fCurPos, c);
+    if (!p || *p == '.') {
+        // No value parsed, or fractional value.
+        return false;
+    }
+
+    if (*p == '%') {
+        *c = SkScalarRoundToInt(*c * 255.0f / 100);
+        *c = SkTPin<int32_t>(*c, 0, 255);
+        p++;
+    }
+
+    fCurPos = p;
+    return true;
+}
+
+bool SkSVGAttributeParser::parseColorComponentFractionalToken(int32_t* c) {
+    SkScalar s;
+    const char* p = SkParse::FindScalar(fCurPos, &s);
+    if (!p || *p != '%') {
+        // Floating point must be a percentage (CSS2 rgb-percent syntax).
+        return false;
+    }
+    p++;  // Skip '%'
+
+    *c = SkScalarRoundToInt(s * 255.0f / 100);
+    *c = SkTPin<int32_t>(*c, 0, 255);
+    fCurPos = p;
+    return true;
+}
+
+bool SkSVGAttributeParser::parseColorComponentScalarToken(int32_t* c) {
+    SkScalar s;
+    if (const char* p = SkParse::FindScalar(fCurPos, &s)) {
+        *c = SkScalarRoundToInt(s * 255.0f);
+        *c = SkTPin<int32_t>(*c, 0, 255);
+        fCurPos = p;
+        return true;
+    }
+    return false;
+}
+
+bool SkSVGAttributeParser::parseColorComponentToken(int32_t* c) {
+    return parseColorComponentIntegralToken(c) ||
+           parseColorComponentFractionalToken(c);
+}
+
+bool SkSVGAttributeParser::parseRGBColorToken(SkColor* c) {
+    return this->parseParenthesized("rgb", [this](SkColor* c) -> bool {
+        int32_t r, g, b;
+        if (this->parseColorComponentToken(&r) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&g) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&b)) {
+
+            *c = SkColorSetRGB(static_cast<uint8_t>(r),
+                               static_cast<uint8_t>(g),
+                               static_cast<uint8_t>(b));
+            return true;
+        }
+        return false;
+    }, c);
+}
+
+bool SkSVGAttributeParser::parseRGBAColorToken(SkColor* c) {
+    return this->parseParenthesized("rgba", [this](SkColor* c) -> bool {
+        int32_t r, g, b, a;
+        if (this->parseColorComponentToken(&r) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&g) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&b) &&
+            this->parseSepToken() &&
+            this->parseColorComponentScalarToken(&a)) {
+
+            *c = SkColorSetARGB(static_cast<uint8_t>(a),
+                                static_cast<uint8_t>(r),
+                                static_cast<uint8_t>(g),
+                                static_cast<uint8_t>(b));
+            return true;
+        }
+        return false;
+    }, c);
+}
+
+bool SkSVGAttributeParser::parseColorToken(SkColor* c) {
+    return this->parseHexColorToken(c) ||
+           this->parseNamedColorToken(c) ||
+           this->parseRGBAColorToken(c) ||
+           this->parseRGBColorToken(c);
+}
+
+bool SkSVGAttributeParser::parseSVGColorType(SkSVGColorType* color) {
+    SkColor c;
+    if (!this->parseColorToken(&c)) {
+        return false;
+    }
+    *color = SkSVGColorType(c);
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeColor
+// And https://www.w3.org/TR/CSS2/syndata.html#color-units for the alternative
+// forms supported by SVG (e.g. RGB percentages).
+template <>
+bool SkSVGAttributeParser::parse(SkSVGColorType* color) {
+    this->parseWSToken();
+    if (!this->parseSVGColorType(color)) {
+        return false;
+    }
+    this->parseWSToken();
+    return this->parseEOSToken();
+}
+
+bool SkSVGAttributeParser::parseSVGColor(SkSVGColor* color, SkSVGColor::Vars&& vars) {
+    static const constexpr int kVarsLimit = 32;
+
+    if (SkSVGColorType c; this->parseSVGColorType(&c)) {
+        *color = SkSVGColor(c, std::move(vars));
+        return true;
+    }
+    if (this->parseExpectedStringToken("currentColor")) {
+        *color = SkSVGColor(SkSVGColor::Type::kCurrentColor, std::move(vars));
+        return true;
+    }
+    // https://drafts.csswg.org/css-variables/#using-variables
+    if (this->parseParenthesized("var", [this, &vars](SkSVGColor* colorResult) -> bool {
+            SkString ident;
+            if (!this->parseIdentToken(&ident) || ident.size() < 2 || !ident.startsWith("--")) {
+                return false;
+            }
+            ident.remove(0, 2);
+            vars.push_back(std::move(ident));
+            this->parseWSToken();
+            if (!this->parseExpectedStringToken(",")) {
+                *colorResult = SkSVGColor(SK_ColorBLACK, std::move(vars));
+                return true;
+            }
+            this->parseWSToken();
+            if (this->matchStringToken(")")) {
+                *colorResult = SkSVGColor(SK_ColorBLACK, std::move(vars));
+                return true;
+            }
+            return vars.size() < kVarsLimit && this->parseSVGColor(colorResult, std::move(vars));
+        }, color))
+    {
+        return true;
+    }
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#InterfaceSVGColor
+template <>
+bool SkSVGAttributeParser::parse(SkSVGColor* color) {
+    this->parseWSToken();
+    if (!this->parseSVGColor(color, SkSVGColor::Vars())) {
+        return false;
+    }
+    this->parseWSToken();
+    return this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/linking.html#IRIReference
+template <>
+bool SkSVGAttributeParser::parse(SkSVGIRI* iri) {
+    // consume preceding whitespace
+    this->parseWSToken();
+
+    SkSVGIRI::Type iriType;
+    if (this->parseExpectedStringToken("#")) {
+        iriType = SkSVGIRI::Type::kLocal;
+    } else if (this->matchStringToken("data:")) {
+        iriType = SkSVGIRI::Type::kDataURI;
+    } else {
+        iriType = SkSVGIRI::Type::kNonlocal;
+    }
+
+    const auto* start = fCurPos;
+    if (!this->advanceWhile([](char c) -> bool { return c != ')'; })) {
+        return false;
+    }
+    *iri = SkSVGIRI(iriType, SkString(start, fCurPos - start));
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeFuncIRI
+bool SkSVGAttributeParser::parseFuncIRI(SkSVGFuncIRI* iri) {
+    return this->parseParenthesized("url", [this](SkSVGFuncIRI* iriResult) -> bool {
+        SkSVGIRI iri;
+        if (this->parse(&iri)) {
+            *iriResult = SkSVGFuncIRI(std::move(iri));
+            return true;
+        }
+        return false;
+    }, iri);
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGStringType* result) {
+    if (this->parseEOSToken()) {
+        return false;
+    }
+    *result = SkSVGStringType(fCurPos);
+    fCurPos += result->size();
+    return this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeNumber
+template <>
+bool SkSVGAttributeParser::parse(SkSVGNumberType* number) {
+    // consume WS
+    this->parseWSToken();
+
+    SkScalar s;
+    if (this->parseScalarToken(&s)) {
+        *number = SkSVGNumberType(s);
+        // consume trailing separators
+        this->parseSepToken();
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeInteger
+bool SkSVGAttributeParser::parseInteger(SkSVGIntegerType* number) {
+    // consume WS
+    this->parseWSToken();
+
+    // consume optional '+'
+    this->parseExpectedStringToken("+");
+
+    SkSVGIntegerType i;
+    if (this->parseInt32Token(&i)) {
+        *number = SkSVGNumberType(i);
+        // consume trailing separators
+        this->parseSepToken();
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeLength
+template <>
+bool SkSVGAttributeParser::parse(SkSVGLength* length) {
+    SkScalar s;
+    SkSVGLength::Unit u = SkSVGLength::Unit::kNumber;
+
+    if (this->parseScalarToken(&s) &&
+        (this->parseLengthUnitToken(&u) || this->parseSepToken() || this->parseEOSToken())) {
+        *length = SkSVGLength(s, u);
+        // consume trailing separators
+        this->parseSepToken();
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute
+bool SkSVGAttributeParser::parseViewBox(SkSVGViewBoxType* vb) {
+    SkScalar x, y, w, h;
+    this->parseWSToken();
+
+    bool parsedValue = false;
+    if (this->parseScalarToken(&x) && this->parseSepToken() &&
+        this->parseScalarToken(&y) && this->parseSepToken() &&
+        this->parseScalarToken(&w) && this->parseSepToken() &&
+        this->parseScalarToken(&h)) {
+
+        *vb = SkSVGViewBoxType(SkRect::MakeXYWH(x, y, w, h));
+        parsedValue = true;
+        // consume trailing whitespace
+        this->parseWSToken();
+    }
+    return parsedValue && this->parseEOSToken();
+}
+
+template <typename Func, typename T>
+bool SkSVGAttributeParser::parseParenthesized(const char* prefix, Func f, T* result) {
+    RestoreCurPos restoreCurPos(this);
+
+    this->parseWSToken();
+    if (prefix && !this->parseExpectedStringToken(prefix)) {
+        return false;
+    }
+    this->parseWSToken();
+    if (!this->parseExpectedStringToken("(")) {
+        return false;
+    }
+    this->parseWSToken();
+
+    if (!f(result)) {
+        return false;
+    }
+
+    this->parseWSToken();
+    if (!this->parseExpectedStringToken(")")) {
+        return false;
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseMatrixToken(SkMatrix* matrix) {
+    return this->parseParenthesized("matrix", [this](SkMatrix* m) -> bool {
+        SkScalar scalars[6];
+        for (int i = 0; i < 6; ++i) {
+            if (!(this->parseScalarToken(scalars + i) &&
+                  (i > 4 || this->parseSepToken()))) {
+                return false;
+            }
+        }
+
+        m->setAll(scalars[0], scalars[2], scalars[4], scalars[1], scalars[3], scalars[5], 0, 0, 1);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseTranslateToken(SkMatrix* matrix) {
+    return this->parseParenthesized("translate", [this](SkMatrix* m) -> bool {
+        SkScalar tx = 0.0, ty = 0.0;
+        this->parseWSToken();
+        if (!this->parseScalarToken(&tx)) {
+            return false;
+        }
+
+        if (!this->parseSepToken() || !this->parseScalarToken(&ty)) {
+            ty = 0.0;
+        }
+
+        m->setTranslate(tx, ty);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseScaleToken(SkMatrix* matrix) {
+    return this->parseParenthesized("scale", [this](SkMatrix* m) -> bool {
+        SkScalar sx = 0.0, sy = 0.0;
+        if (!this->parseScalarToken(&sx)) {
+            return false;
+        }
+
+        if (!(this->parseSepToken() && this->parseScalarToken(&sy))) {
+            sy = sx;
+        }
+
+        m->setScale(sx, sy);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseRotateToken(SkMatrix* matrix) {
+    return this->parseParenthesized("rotate", [this](SkMatrix* m) -> bool {
+        SkScalar angle;
+        if (!this->parseScalarToken(&angle)) {
+            return false;
+        }
+
+        SkScalar cx = 0;
+        SkScalar cy = 0;
+        // optional [<cx> <cy>]
+        if (this->parseSepToken() && this->parseScalarToken(&cx)) {
+            if (!(this->parseSepToken() && this->parseScalarToken(&cy))) {
+                return false;
+            }
+        }
+
+        m->setRotate(angle, cx, cy);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseSkewXToken(SkMatrix* matrix) {
+    return this->parseParenthesized("skewX", [this](SkMatrix* m) -> bool {
+        SkScalar angle;
+        if (!this->parseScalarToken(&angle)) {
+            return false;
+        }
+        m->setSkewX(tanf(SkDegreesToRadians(angle)));
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseSkewYToken(SkMatrix* matrix) {
+    return this->parseParenthesized("skewY", [this](SkMatrix* m) -> bool {
+        SkScalar angle;
+        if (!this->parseScalarToken(&angle)) {
+            return false;
+        }
+        m->setSkewY(tanf(SkDegreesToRadians(angle)));
+        return true;
+    }, matrix);
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#TransformAttribute
+template <>
+bool SkSVGAttributeParser::parse(SkSVGTransformType* t) {
+    SkMatrix matrix = SkMatrix::I();
+
+    bool parsed = false;
+    while (true) {
+        SkMatrix m;
+
+        if (!( this->parseMatrixToken(&m)
+            || this->parseTranslateToken(&m)
+            || this->parseScaleToken(&m)
+            || this->parseRotateToken(&m)
+            || this->parseSkewXToken(&m)
+            || this->parseSkewYToken(&m))) {
+            break;
+        }
+
+        matrix.preConcat(m);
+        parsed = true;
+
+        this->parseCommaWspToken();
+    }
+
+    this->parseWSToken();
+    if (!parsed || !this->parseEOSToken()) {
+        return false;
+    }
+
+    *t = SkSVGTransformType(matrix);
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#SpecifyingPaint
+template <>
+bool SkSVGAttributeParser::parse(SkSVGPaint* paint) {
+    SkSVGColor c;
+    SkSVGFuncIRI iri;
+    bool parsedValue = false;
+
+    this->parseWSToken();
+    if (this->parseSVGColor(&c, SkSVGColor::Vars())) {
+        *paint = SkSVGPaint(std::move(c));
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("none")) {
+        *paint = SkSVGPaint(SkSVGPaint::Type::kNone);
+        parsedValue = true;
+    } else if (this->parseFuncIRI(&iri)) {
+        // optional fallback color
+        this->parseWSToken();
+        this->parseSVGColor(&c, SkSVGColor::Vars());
+        *paint = SkSVGPaint(iri.iri(), std::move(c));
+        parsedValue = true;
+    }
+    this->parseWSToken();
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/masking.html#ClipPathProperty
+// https://www.w3.org/TR/SVG11/masking.html#MaskProperty
+// https://www.w3.org/TR/SVG11/filters.html#FilterProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFuncIRI* firi) {
+    SkSVGStringType iri;
+    bool parsedValue = false;
+
+    if (this->parseExpectedStringToken("none")) {
+        *firi = SkSVGFuncIRI();
+        parsedValue = true;
+    } else if (this->parseFuncIRI(firi)) {
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGLineCap* cap) {
+    static const struct {
+        SkSVGLineCap fType;
+        const char*        fName;
+    } gCapInfo[] = {
+        { SkSVGLineCap::kButt   , "butt"    },
+        { SkSVGLineCap::kRound  , "round"   },
+        { SkSVGLineCap::kSquare , "square"  },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gCapInfo); ++i) {
+        if (this->parseExpectedStringToken(gCapInfo[i].fName)) {
+            *cap = SkSVGLineCap(gCapInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGLineJoin* join) {
+    static const struct {
+        SkSVGLineJoin::Type fType;
+        const char*         fName;
+    } gJoinInfo[] = {
+        { SkSVGLineJoin::Type::kMiter  , "miter"   },
+        { SkSVGLineJoin::Type::kRound  , "round"   },
+        { SkSVGLineJoin::Type::kBevel  , "bevel"   },
+        { SkSVGLineJoin::Type::kInherit, "inherit" },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gJoinInfo); ++i) {
+        if (this->parseExpectedStringToken(gJoinInfo[i].fName)) {
+            *join = SkSVGLineJoin(gJoinInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBoxUnits
+template <>
+bool SkSVGAttributeParser::parse(SkSVGObjectBoundingBoxUnits* objectBoundingBoxUnits) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("userSpaceOnUse")) {
+        *objectBoundingBoxUnits =
+                SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse);
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("objectBoundingBox")) {
+        *objectBoundingBoxUnits =
+                SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox);
+        parsedValue = true;
+    }
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute
+template <>
+bool SkSVGAttributeParser::parse(SkSVGPointsType* points) {
+    SkSVGPointsType pts;
+
+    // Skip initial wsp.
+    // list-of-points:
+    //     wsp* coordinate-pairs? wsp*
+    this->advanceWhile(is_ws);
+
+    bool parsedValue = false;
+    for (;;) {
+        // Adjacent coordinate-pairs separated by comma-wsp.
+        // coordinate-pairs:
+        //     coordinate-pair
+        //     | coordinate-pair comma-wsp coordinate-pairs
+        if (parsedValue && !this->parseCommaWspToken()) {
+            break;
+        }
+
+        SkScalar x, y;
+        if (!this->parseScalarToken(&x)) {
+            break;
+        }
+
+        // Coordinate values separated by comma-wsp or '-'.
+        // coordinate-pair:
+        //     coordinate comma-wsp coordinate
+        //     | coordinate negative-coordinate
+        if (!this->parseCommaWspToken() && !this->parseEOSToken() && *fCurPos != '-') {
+            break;
+        }
+
+        if (!this->parseScalarToken(&y)) {
+            break;
+        }
+
+        pts.push_back(SkPoint::Make(x, y));
+        parsedValue = true;
+    }
+
+    if (parsedValue && this->parseEOSToken()) {
+        *points = std::move(pts);
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#FillRuleProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFillRule* fillRule) {
+    static const struct {
+        SkSVGFillRule::Type fType;
+        const char*         fName;
+    } gFillRuleInfo[] = {
+        { SkSVGFillRule::Type::kNonZero, "nonzero" },
+        { SkSVGFillRule::Type::kEvenOdd, "evenodd" },
+        { SkSVGFillRule::Type::kInherit, "inherit" },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gFillRuleInfo); ++i) {
+        if (this->parseExpectedStringToken(gFillRuleInfo[i].fName)) {
+            *fillRule = SkSVGFillRule(gFillRuleInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#VisibilityProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGVisibility* visibility) {
+    static const struct {
+        SkSVGVisibility::Type fType;
+        const char*           fName;
+    } gVisibilityInfo[] = {
+        { SkSVGVisibility::Type::kVisible , "visible"  },
+        { SkSVGVisibility::Type::kHidden  , "hidden"   },
+        { SkSVGVisibility::Type::kCollapse, "collapse" },
+        { SkSVGVisibility::Type::kInherit , "inherit"  },
+    };
+
+    bool parsedValue = false;
+    for (const auto& parseInfo : gVisibilityInfo) {
+        if (this->parseExpectedStringToken(parseInfo.fName)) {
+            *visibility = SkSVGVisibility(parseInfo.fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#StrokeDasharrayProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGDashArray* dashArray) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("none")) {
+        *dashArray = SkSVGDashArray(SkSVGDashArray::Type::kNone);
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("inherit")) {
+        *dashArray = SkSVGDashArray(SkSVGDashArray::Type::kInherit);
+        parsedValue = true;
+    } else {
+        std::vector<SkSVGLength> dashes;
+        for (;;) {
+            SkSVGLength dash;
+            // parseLength() also consumes trailing separators.
+            if (!this->parse(&dash)) {
+                break;
+            }
+
+            dashes.push_back(dash);
+            parsedValue = true;
+        }
+
+        if (parsedValue) {
+            *dashArray = SkSVGDashArray(std::move(dashes));
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontFamilyProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontFamily* family) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("inherit")) {
+        *family = SkSVGFontFamily();
+        parsedValue = true;
+    } else {
+        // The spec allows specifying a comma-separated list for explicit fallback order.
+        // For now, we only use the first entry and rely on the font manager to handle fallback.
+        const auto* comma = strchr(fCurPos, ',');
+        auto family_name = comma ? SkString(fCurPos, comma - fCurPos)
+                                 : SkString(fCurPos);
+        *family = SkSVGFontFamily(family_name.c_str());
+        fCurPos += strlen(fCurPos);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontSizeProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontSize* size) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("inherit")) {
+        *size = SkSVGFontSize();
+        parsedValue = true;
+    } else {
+        SkSVGLength length;
+        if (this->parse(&length)) {
+            *size = SkSVGFontSize(length);
+            parsedValue = true;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontStyleProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontStyle* style) {
+    static constexpr std::tuple<const char*, SkSVGFontStyle::Type> gStyleMap[] = {
+        { "normal" , SkSVGFontStyle::Type::kNormal  },
+        { "italic" , SkSVGFontStyle::Type::kItalic  },
+        { "oblique", SkSVGFontStyle::Type::kOblique },
+        { "inherit", SkSVGFontStyle::Type::kInherit },
+    };
+
+    bool parsedValue = false;
+    SkSVGFontStyle::Type type;
+
+    if (this->parseEnumMap(gStyleMap, &type)) {
+        *style = SkSVGFontStyle(type);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontWeightProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontWeight* weight) {
+    static constexpr std::tuple<const char*, SkSVGFontWeight::Type> gWeightMap[] = {
+        { "normal" , SkSVGFontWeight::Type::kNormal  },
+        { "bold"   , SkSVGFontWeight::Type::kBold    },
+        { "bolder" , SkSVGFontWeight::Type::kBolder  },
+        { "lighter", SkSVGFontWeight::Type::kLighter },
+        { "100"    , SkSVGFontWeight::Type::k100     },
+        { "200"    , SkSVGFontWeight::Type::k200     },
+        { "300"    , SkSVGFontWeight::Type::k300     },
+        { "400"    , SkSVGFontWeight::Type::k400     },
+        { "500"    , SkSVGFontWeight::Type::k500     },
+        { "600"    , SkSVGFontWeight::Type::k600     },
+        { "700"    , SkSVGFontWeight::Type::k700     },
+        { "800"    , SkSVGFontWeight::Type::k800     },
+        { "900"    , SkSVGFontWeight::Type::k900     },
+        { "inherit", SkSVGFontWeight::Type::kInherit },
+    };
+
+    bool parsedValue = false;
+    SkSVGFontWeight::Type type;
+
+    if (this->parseEnumMap(gWeightMap, &type)) {
+        *weight = SkSVGFontWeight(type);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#TextAnchorProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGTextAnchor* anchor) {
+    static constexpr std::tuple<const char*, SkSVGTextAnchor::Type> gAnchorMap[] = {
+        { "start"  , SkSVGTextAnchor::Type::kStart  },
+        { "middle" , SkSVGTextAnchor::Type::kMiddle },
+        { "end"    , SkSVGTextAnchor::Type::kEnd    },
+        { "inherit", SkSVGTextAnchor::Type::kInherit},
+    };
+
+    bool parsedValue = false;
+    SkSVGTextAnchor::Type type;
+
+    if (this->parseEnumMap(gAnchorMap, &type)) {
+        *anchor = SkSVGTextAnchor(type);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#PreserveAspectRatioAttribute
+bool SkSVGAttributeParser::parsePreserveAspectRatio(SkSVGPreserveAspectRatio* par) {
+    static constexpr std::tuple<const char*, SkSVGPreserveAspectRatio::Align> gAlignMap[] = {
+        { "none"    , SkSVGPreserveAspectRatio::kNone     },
+        { "xMinYMin", SkSVGPreserveAspectRatio::kXMinYMin },
+        { "xMidYMin", SkSVGPreserveAspectRatio::kXMidYMin },
+        { "xMaxYMin", SkSVGPreserveAspectRatio::kXMaxYMin },
+        { "xMinYMid", SkSVGPreserveAspectRatio::kXMinYMid },
+        { "xMidYMid", SkSVGPreserveAspectRatio::kXMidYMid },
+        { "xMaxYMid", SkSVGPreserveAspectRatio::kXMaxYMid },
+        { "xMinYMax", SkSVGPreserveAspectRatio::kXMinYMax },
+        { "xMidYMax", SkSVGPreserveAspectRatio::kXMidYMax },
+        { "xMaxYMax", SkSVGPreserveAspectRatio::kXMaxYMax },
+    };
+
+    static constexpr std::tuple<const char*, SkSVGPreserveAspectRatio::Scale> gScaleMap[] = {
+        { "meet" , SkSVGPreserveAspectRatio::kMeet  },
+        { "slice", SkSVGPreserveAspectRatio::kSlice },
+    };
+
+    bool parsedValue = false;
+
+    // ignoring optional 'defer'
+    this->parseExpectedStringToken("defer");
+    this->parseWSToken();
+
+    if (this->parseEnumMap(gAlignMap, &par->fAlign)) {
+        parsedValue = true;
+
+        // optional scaling selector
+        this->parseWSToken();
+        this->parseEnumMap(gScaleMap, &par->fScale);
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGPreserveAspectRatio* par) {
+    return this->parsePreserveAspectRatio(par);
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeCoordinates
+template <typename T>
+bool SkSVGAttributeParser::parseList(std::vector<T>* vals) {
+    SkASSERT(vals->empty());
+
+    T v;
+    for (;;) {
+        if (!this->parse(&v)) {
+            break;
+        }
+
+        vals->push_back(v);
+
+        this->parseCommaWspToken();
+    }
+
+    return !vals->empty() && this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse(std::vector<SkSVGLength>* lengths) {
+    return this->parseList(lengths);
+}
+
+template <>
+bool SkSVGAttributeParser::parse(std::vector<SkSVGNumberType>* numbers) {
+    return this->parseList(numbers);
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGColorspace* colorspace) {
+    static constexpr std::tuple<const char*, SkSVGColorspace> gColorspaceMap[] = {
+        { "auto"     , SkSVGColorspace::kAuto      },
+        { "sRGB"     , SkSVGColorspace::kSRGB      },
+        { "linearRGB", SkSVGColorspace::kLinearRGB },
+    };
+
+    return this->parseEnumMap(gColorspaceMap, colorspace) && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGDisplay* display) {
+    static const struct {
+        SkSVGDisplay fType;
+        const char*  fName;
+    } gDisplayInfo[] = {
+        { SkSVGDisplay::kInline, "inline" },
+        { SkSVGDisplay::kNone  , "none"   },
+    };
+
+    bool parsedValue = false;
+    for (const auto& parseInfo : gDisplayInfo) {
+        if (this->parseExpectedStringToken(parseInfo.fName)) {
+            *display = SkSVGDisplay(parseInfo.fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp
new file mode 100644
index 00000000..31501d14
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGCircle.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGCircle::SkSVGCircle() : INHERITED(SkSVGTag::kCircle) {}
+
+bool SkSVGCircle::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setCx(SkSVGAttributeParser::parse<SkSVGLength>("cx", n, v)) ||
+           this->setCy(SkSVGAttributeParser::parse<SkSVGLength>("cy", n, v)) ||
+           this->setR(SkSVGAttributeParser::parse<SkSVGLength>("r", n, v));
+}
+
+std::tuple<SkPoint, SkScalar> SkSVGCircle::resolve(const SkSVGLengthContext& lctx) const {
+    const auto cx = lctx.resolve(fCx, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto cy = lctx.resolve(fCy, SkSVGLengthContext::LengthType::kVertical);
+    const auto  r = lctx.resolve(fR , SkSVGLengthContext::LengthType::kOther);
+
+    return std::make_tuple(SkPoint::Make(cx, cy), r);
+}
+void SkSVGCircle::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                         const SkPaint& paint, SkPathFillType) const {
+    SkPoint pos;
+    SkScalar r;
+    std::tie(pos, r) = this->resolve(lctx);
+
+    if (r > 0) {
+        canvas->drawCircle(pos.x(), pos.y(), r, paint);
+    }
+}
+
+SkPath SkSVGCircle::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPoint pos;
+    SkScalar r;
+    std::tie(pos, r) = this->resolve(ctx.lengthContext());
+
+    SkPath path = SkPath::Circle(pos.x(), pos.y(), r);
+    this->mapToParent(&path);
+
+    return path;
+}
+
+SkRect SkSVGCircle::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    const auto [pos, r] = this->resolve(ctx.lengthContext());
+    return SkRect::MakeXYWH(pos.fX - r, pos.fY - r, 2 * r, 2 * r);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp
new file mode 100644
index 00000000..06ef8ae3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGClipPath.h"
+
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+SkSVGClipPath::SkSVGClipPath() : INHERITED(SkSVGTag::kClipPath) {}
+
+bool SkSVGClipPath::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setClipPathUnits(
+                SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>("clipPathUnits", n, v));
+}
+
+SkPath SkSVGClipPath::resolveClip(const SkSVGRenderContext& ctx) const {
+    auto clip = this->asPath(ctx);
+
+    const auto obbt = ctx.transformForCurrentOBB(fClipPathUnits);
+    const auto m = SkMatrix::Translate(obbt.offset.x, obbt.offset.y)
+                 * SkMatrix::Scale(obbt.scale.x, obbt.scale.y);
+    clip.transform(m);
+
+    return clip;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp
new file mode 100644
index 00000000..c4b760c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGContainer.h"
+
+#include "include/core/SkPath.h"
+#include "include/pathops/SkPathOps.h"
+
+SkSVGContainer::SkSVGContainer(SkSVGTag t) : INHERITED(t) { }
+
+void SkSVGContainer::appendChild(sk_sp<SkSVGNode> node) {
+    SkASSERT(node);
+    fChildren.push_back(std::move(node));
+}
+
+bool SkSVGContainer::hasChildren() const {
+    return !fChildren.empty();
+}
+
+void SkSVGContainer::onRender(const SkSVGRenderContext& ctx) const {
+    for (int i = 0; i < fChildren.size(); ++i) {
+        fChildren[i]->render(ctx);
+    }
+}
+
+SkPath SkSVGContainer::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path;
+
+    for (int i = 0; i < fChildren.size(); ++i) {
+        const SkPath childPath = fChildren[i]->asPath(ctx);
+
+        Op(path, childPath, kUnion_SkPathOp, &path);
+    }
+
+    this->mapToParent(&path);
+    return path;
+}
+
+SkRect SkSVGContainer::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    SkRect bounds = SkRect::MakeEmpty();
+
+    for (int i = 0; i < fChildren.size(); ++i) {
+        const SkRect childBounds = fChildren[i]->objectBoundingBox(ctx);
+        bounds.join(childBounds);
+    }
+
+    return bounds;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp
new file mode 100644
index 00000000..25542889
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp
@@ -0,0 +1,510 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGDOM.h"
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkString.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGCircle.h"
+#include "modules/svg/include/SkSVGClipPath.h"
+#include "modules/svg/include/SkSVGDefs.h"
+#include "modules/svg/include/SkSVGEllipse.h"
+#include "modules/svg/include/SkSVGFeBlend.h"
+#include "modules/svg/include/SkSVGFeColorMatrix.h"
+#include "modules/svg/include/SkSVGFeComponentTransfer.h"
+#include "modules/svg/include/SkSVGFeComposite.h"
+#include "modules/svg/include/SkSVGFeDisplacementMap.h"
+#include "modules/svg/include/SkSVGFeFlood.h"
+#include "modules/svg/include/SkSVGFeGaussianBlur.h"
+#include "modules/svg/include/SkSVGFeImage.h"
+#include "modules/svg/include/SkSVGFeLightSource.h"
+#include "modules/svg/include/SkSVGFeLighting.h"
+#include "modules/svg/include/SkSVGFeMerge.h"
+#include "modules/svg/include/SkSVGFeMorphology.h"
+#include "modules/svg/include/SkSVGFeOffset.h"
+#include "modules/svg/include/SkSVGFeTurbulence.h"
+#include "modules/svg/include/SkSVGFilter.h"
+#include "modules/svg/include/SkSVGG.h"
+#include "modules/svg/include/SkSVGImage.h"
+#include "modules/svg/include/SkSVGLine.h"
+#include "modules/svg/include/SkSVGLinearGradient.h"
+#include "modules/svg/include/SkSVGMask.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGPath.h"
+#include "modules/svg/include/SkSVGPattern.h"
+#include "modules/svg/include/SkSVGPoly.h"
+#include "modules/svg/include/SkSVGRadialGradient.h"
+#include "modules/svg/include/SkSVGRect.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGSVG.h"
+#include "modules/svg/include/SkSVGStop.h"
+#include "modules/svg/include/SkSVGText.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "modules/svg/include/SkSVGUse.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/base/SkTSearch.h"
+#include "src/core/SkTraceEvent.h"
+#include "src/xml/SkDOM.h"
+
+namespace {
+
+bool SetIRIAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                      const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGIRI>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGStringValue(parseResult->iri()));
+    return true;
+}
+
+bool SetStringAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                           const char* stringValue) {
+    SkString str(stringValue, strlen(stringValue));
+    SkSVGStringType strType = SkSVGStringType(str);
+    node->setAttribute(attr, SkSVGStringValue(strType));
+    return true;
+}
+
+bool SetTransformAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                           const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGTransformType>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGTransformValue(*parseResult));
+    return true;
+}
+
+bool SetLengthAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                        const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGLength>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGLengthValue(*parseResult));
+    return true;
+}
+
+bool SetViewBoxAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                         const char* stringValue) {
+    SkSVGViewBoxType viewBox;
+    SkSVGAttributeParser parser(stringValue);
+    if (!parser.parseViewBox(&viewBox)) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGViewBoxValue(viewBox));
+    return true;
+}
+
+bool SetObjectBoundingBoxUnitsAttribute(const sk_sp<SkSVGNode>& node,
+                                        SkSVGAttribute attr,
+                                        const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGObjectBoundingBoxUnitsValue(*parseResult));
+    return true;
+}
+
+bool SetPreserveAspectRatioAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                                     const char* stringValue) {
+    SkSVGPreserveAspectRatio par;
+    SkSVGAttributeParser parser(stringValue);
+    if (!parser.parsePreserveAspectRatio(&par)) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGPreserveAspectRatioValue(par));
+    return true;
+}
+
+SkString TrimmedString(const char* first, const char* last) {
+    SkASSERT(first);
+    SkASSERT(last);
+    SkASSERT(first <= last);
+
+    while (first <= last && *first <= ' ') { first++; }
+    while (first <= last && *last  <= ' ') { last--; }
+
+    SkASSERT(last - first + 1 >= 0);
+    return SkString(first, SkTo<size_t>(last - first + 1));
+}
+
+// Breaks a "foo: bar; baz: ..." string into key:value pairs.
+class StyleIterator {
+public:
+    StyleIterator(const char* str) : fPos(str) { }
+
+    std::tuple<SkString, SkString> next() {
+        SkString name, value;
+
+        if (fPos) {
+            const char* sep = this->nextSeparator();
+            SkASSERT(*sep == ';' || *sep == '\0');
+
+            const char* valueSep = strchr(fPos, ':');
+            if (valueSep && valueSep < sep) {
+                name  = TrimmedString(fPos, valueSep - 1);
+                value = TrimmedString(valueSep + 1, sep - 1);
+            }
+
+            fPos = *sep ? sep + 1 : nullptr;
+        }
+
+        return std::make_tuple(name, value);
+    }
+
+private:
+    const char* nextSeparator() const {
+        const char* sep = fPos;
+        while (*sep != ';' && *sep != '\0') {
+            sep++;
+        }
+        return sep;
+    }
+
+    const char* fPos;
+};
+
+bool set_string_attribute(const sk_sp<SkSVGNode>& node, const char* name, const char* value);
+
+bool SetStyleAttributes(const sk_sp<SkSVGNode>& node, SkSVGAttribute,
+                        const char* stringValue) {
+
+    SkString name, value;
+    StyleIterator iter(stringValue);
+    for (;;) {
+        std::tie(name, value) = iter.next();
+        if (name.isEmpty()) {
+            break;
+        }
+        set_string_attribute(node, name.c_str(), value.c_str());
+    }
+
+    return true;
+}
+
+template<typename T>
+struct SortedDictionaryEntry {
+    const char* fKey;
+    const T     fValue;
+};
+
+struct AttrParseInfo {
+    SkSVGAttribute fAttr;
+    bool (*fSetter)(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr, const char* stringValue);
+};
+
+SortedDictionaryEntry<AttrParseInfo> gAttributeParseInfo[] = {
+    { "cx"                 , { SkSVGAttribute::kCx               , SetLengthAttribute       }},
+    { "cy"                 , { SkSVGAttribute::kCy               , SetLengthAttribute       }},
+    { "filterUnits"        , { SkSVGAttribute::kFilterUnits      ,
+                               SetObjectBoundingBoxUnitsAttribute }},
+    // focal point x & y
+    { "fx"                 , { SkSVGAttribute::kFx               , SetLengthAttribute       }},
+    { "fy"                 , { SkSVGAttribute::kFy               , SetLengthAttribute       }},
+    { "height"             , { SkSVGAttribute::kHeight           , SetLengthAttribute       }},
+    { "preserveAspectRatio", { SkSVGAttribute::kPreserveAspectRatio,
+                               SetPreserveAspectRatioAttribute }},
+    { "r"                  , { SkSVGAttribute::kR                , SetLengthAttribute       }},
+    { "rx"                 , { SkSVGAttribute::kRx               , SetLengthAttribute       }},
+    { "ry"                 , { SkSVGAttribute::kRy               , SetLengthAttribute       }},
+    { "style"              , { SkSVGAttribute::kUnknown          , SetStyleAttributes       }},
+    { "text"               , { SkSVGAttribute::kText             , SetStringAttribute       }},
+    { "transform"          , { SkSVGAttribute::kTransform        , SetTransformAttribute    }},
+    { "viewBox"            , { SkSVGAttribute::kViewBox          , SetViewBoxAttribute      }},
+    { "width"              , { SkSVGAttribute::kWidth            , SetLengthAttribute       }},
+    { "x"                  , { SkSVGAttribute::kX                , SetLengthAttribute       }},
+    { "x1"                 , { SkSVGAttribute::kX1               , SetLengthAttribute       }},
+    { "x2"                 , { SkSVGAttribute::kX2               , SetLengthAttribute       }},
+    { "xlink:href"         , { SkSVGAttribute::kHref             , SetIRIAttribute          }},
+    { "y"                  , { SkSVGAttribute::kY                , SetLengthAttribute       }},
+    { "y1"                 , { SkSVGAttribute::kY1               , SetLengthAttribute       }},
+    { "y2"                 , { SkSVGAttribute::kY2               , SetLengthAttribute       }},
+};
+
+SortedDictionaryEntry<sk_sp<SkSVGNode>(*)()> gTagFactories[] = {
+    { "a"                  , []() -> sk_sp<SkSVGNode> { return SkSVGG::Make();                   }},
+    { "circle"             , []() -> sk_sp<SkSVGNode> { return SkSVGCircle::Make();              }},
+    { "clipPath"           , []() -> sk_sp<SkSVGNode> { return SkSVGClipPath::Make();            }},
+    { "defs"               , []() -> sk_sp<SkSVGNode> { return SkSVGDefs::Make();                }},
+    { "ellipse"            , []() -> sk_sp<SkSVGNode> { return SkSVGEllipse::Make();             }},
+    { "feBlend"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeBlend::Make();             }},
+    { "feColorMatrix"      , []() -> sk_sp<SkSVGNode> { return SkSVGFeColorMatrix::Make();       }},
+    { "feComponentTransfer", []() -> sk_sp<SkSVGNode> { return SkSVGFeComponentTransfer::Make(); }},
+    { "feComposite"        , []() -> sk_sp<SkSVGNode> { return SkSVGFeComposite::Make();         }},
+    { "feDiffuseLighting"  , []() -> sk_sp<SkSVGNode> { return SkSVGFeDiffuseLighting::Make();   }},
+    { "feDisplacementMap"  , []() -> sk_sp<SkSVGNode> { return SkSVGFeDisplacementMap::Make();   }},
+    { "feDistantLight"     , []() -> sk_sp<SkSVGNode> { return SkSVGFeDistantLight::Make();      }},
+    { "feFlood"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFlood::Make();             }},
+    { "feFuncA"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncA();         }},
+    { "feFuncB"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncB();         }},
+    { "feFuncG"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncG();         }},
+    { "feFuncR"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncR();         }},
+    { "feGaussianBlur"     , []() -> sk_sp<SkSVGNode> { return SkSVGFeGaussianBlur::Make();      }},
+    { "feImage"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeImage::Make();             }},
+    { "feMerge"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeMerge::Make();             }},
+    { "feMergeNode"        , []() -> sk_sp<SkSVGNode> { return SkSVGFeMergeNode::Make();         }},
+    { "feMorphology"       , []() -> sk_sp<SkSVGNode> { return SkSVGFeMorphology::Make();        }},
+    { "feOffset"           , []() -> sk_sp<SkSVGNode> { return SkSVGFeOffset::Make();            }},
+    { "fePointLight"       , []() -> sk_sp<SkSVGNode> { return SkSVGFePointLight::Make();        }},
+    { "feSpecularLighting" , []() -> sk_sp<SkSVGNode> { return SkSVGFeSpecularLighting::Make();  }},
+    { "feSpotLight"        , []() -> sk_sp<SkSVGNode> { return SkSVGFeSpotLight::Make();         }},
+    { "feTurbulence"       , []() -> sk_sp<SkSVGNode> { return SkSVGFeTurbulence::Make();        }},
+    { "filter"             , []() -> sk_sp<SkSVGNode> { return SkSVGFilter::Make();              }},
+    { "g"                  , []() -> sk_sp<SkSVGNode> { return SkSVGG::Make();                   }},
+    { "image"              , []() -> sk_sp<SkSVGNode> { return SkSVGImage::Make();               }},
+    { "line"               , []() -> sk_sp<SkSVGNode> { return SkSVGLine::Make();                }},
+    { "linearGradient"     , []() -> sk_sp<SkSVGNode> { return SkSVGLinearGradient::Make();      }},
+    { "mask"               , []() -> sk_sp<SkSVGNode> { return SkSVGMask::Make();                }},
+    { "path"               , []() -> sk_sp<SkSVGNode> { return SkSVGPath::Make();                }},
+    { "pattern"            , []() -> sk_sp<SkSVGNode> { return SkSVGPattern::Make();             }},
+    { "polygon"            , []() -> sk_sp<SkSVGNode> { return SkSVGPoly::MakePolygon();         }},
+    { "polyline"           , []() -> sk_sp<SkSVGNode> { return SkSVGPoly::MakePolyline();        }},
+    { "radialGradient"     , []() -> sk_sp<SkSVGNode> { return SkSVGRadialGradient::Make();      }},
+    { "rect"               , []() -> sk_sp<SkSVGNode> { return SkSVGRect::Make();                }},
+    { "stop"               , []() -> sk_sp<SkSVGNode> { return SkSVGStop::Make();                }},
+//    "svg" handled explicitly
+    { "text"               , []() -> sk_sp<SkSVGNode> { return SkSVGText::Make();                }},
+    { "textPath"           , []() -> sk_sp<SkSVGNode> { return SkSVGTextPath::Make();            }},
+    { "tspan"              , []() -> sk_sp<SkSVGNode> { return SkSVGTSpan::Make();               }},
+    { "use"                , []() -> sk_sp<SkSVGNode> { return SkSVGUse::Make();                 }},
+};
+
+struct ConstructionContext {
+    ConstructionContext(SkSVGIDMapper* mapper) : fParent(nullptr), fIDMapper(mapper) {}
+    ConstructionContext(const ConstructionContext& other, const sk_sp<SkSVGNode>& newParent)
+        : fParent(newParent.get()), fIDMapper(other.fIDMapper) {}
+
+    SkSVGNode*     fParent;
+    SkSVGIDMapper* fIDMapper;
+};
+
+bool set_string_attribute(const sk_sp<SkSVGNode>& node, const char* name, const char* value) {
+    if (node->parseAndSetAttribute(name, value)) {
+        // Handled by new code path
+        return true;
+    }
+
+    const int attrIndex = SkStrSearch(&gAttributeParseInfo[0].fKey,
+                                      SkTo<int>(std::size(gAttributeParseInfo)),
+                                      name, sizeof(gAttributeParseInfo[0]));
+    if (attrIndex < 0) {
+#if defined(SK_VERBOSE_SVG_PARSING)
+        SkDebugf("unhandled attribute: %s\n", name);
+#endif
+        return false;
+    }
+
+    SkASSERT(SkTo<size_t>(attrIndex) < std::size(gAttributeParseInfo));
+    const auto& attrInfo = gAttributeParseInfo[attrIndex].fValue;
+    if (!attrInfo.fSetter(node, attrInfo.fAttr, value)) {
+#if defined(SK_VERBOSE_SVG_PARSING)
+        SkDebugf("could not parse attribute: '%s=\"%s\"'\n", name, value);
+#endif
+        return false;
+    }
+
+    return true;
+}
+
+void parse_node_attributes(const SkDOM& xmlDom, const SkDOM::Node* xmlNode,
+                           const sk_sp<SkSVGNode>& svgNode, SkSVGIDMapper* mapper) {
+    const char* name, *value;
+    SkDOM::AttrIter attrIter(xmlDom, xmlNode);
+    while ((name = attrIter.next(&value))) {
+        // We're handling id attributes out of band for now.
+        if (!strcmp(name, "id")) {
+            mapper->set(SkString(value), svgNode);
+            continue;
+        }
+        set_string_attribute(svgNode, name, value);
+    }
+}
+
+sk_sp<SkSVGNode> construct_svg_node(const SkDOM& dom, const ConstructionContext& ctx,
+                                    const SkDOM::Node* xmlNode) {
+    const char* elem = dom.getName(xmlNode);
+    const SkDOM::Type elemType = dom.getType(xmlNode);
+
+    if (elemType == SkDOM::kText_Type) {
+        // Text literals require special handling.
+        SkASSERT(dom.countChildren(xmlNode) == 0);
+        auto txt = SkSVGTextLiteral::Make();
+        txt->setText(SkString(dom.getName(xmlNode)));
+        ctx.fParent->appendChild(std::move(txt));
+
+        return nullptr;
+    }
+
+    SkASSERT(elemType == SkDOM::kElement_Type);
+
+    auto make_node = [](const ConstructionContext& ctx, const char* elem) -> sk_sp<SkSVGNode> {
+        if (strcmp(elem, "svg") == 0) {
+            // Outermost SVG element must be tagged as such.
+            return SkSVGSVG::Make(ctx.fParent ? SkSVGSVG::Type::kInner
+                                              : SkSVGSVG::Type::kRoot);
+        }
+
+        const int tagIndex = SkStrSearch(&gTagFactories[0].fKey,
+                                         SkTo<int>(std::size(gTagFactories)),
+                                         elem, sizeof(gTagFactories[0]));
+        if (tagIndex < 0) {
+#if defined(SK_VERBOSE_SVG_PARSING)
+            SkDebugf("unhandled element: <%s>\n", elem);
+#endif
+            return nullptr;
+        }
+        SkASSERT(SkTo<size_t>(tagIndex) < std::size(gTagFactories));
+
+        return gTagFactories[tagIndex].fValue();
+    };
+
+    auto node = make_node(ctx, elem);
+    if (!node) {
+        return nullptr;
+    }
+
+    parse_node_attributes(dom, xmlNode, node, ctx.fIDMapper);
+
+    ConstructionContext localCtx(ctx, node);
+    for (auto* child = dom.getFirstChild(xmlNode, nullptr); child;
+         child = dom.getNextSibling(child)) {
+        sk_sp<SkSVGNode> childNode = construct_svg_node(dom, localCtx, child);
+        if (childNode) {
+            node->appendChild(std::move(childNode));
+        }
+    }
+
+    return node;
+}
+
+} // anonymous namespace
+
+SkSVGDOM::Builder& SkSVGDOM::Builder::setFontManager(sk_sp<SkFontMgr> fmgr) {
+    fFontMgr = std::move(fmgr);
+    return *this;
+}
+
+SkSVGDOM::Builder& SkSVGDOM::Builder::setResourceProvider(sk_sp<skresources::ResourceProvider> rp) {
+    fResourceProvider = std::move(rp);
+    return *this;
+}
+
+SkSVGDOM::Builder& SkSVGDOM::Builder::setTextShapingFactory(sk_sp<SkShapers::Factory> f) {
+    fTextShapingFactory = f;
+    return *this;
+}
+
+sk_sp<SkSVGDOM> SkSVGDOM::Builder::make(SkStream& str) const {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+    SkDOM xmlDom;
+    if (!xmlDom.build(str)) {
+        return nullptr;
+    }
+
+    SkSVGIDMapper mapper;
+    ConstructionContext ctx(&mapper);
+
+    auto root = construct_svg_node(xmlDom, ctx, xmlDom.getRootNode());
+    if (!root || root->tag() != SkSVGTag::kSvg) {
+        return nullptr;
+    }
+
+    class NullResourceProvider final : public skresources::ResourceProvider {
+        sk_sp<SkData> load(const char[], const char[]) const override { return nullptr; }
+    };
+
+    auto resource_provider = fResourceProvider ? fResourceProvider
+                                               : sk_make_sp<NullResourceProvider>();
+
+    auto factory = fTextShapingFactory ? fTextShapingFactory : SkShapers::Primitive::Factory();
+
+    return sk_sp<SkSVGDOM>(new SkSVGDOM(sk_sp<SkSVGSVG>(static_cast<SkSVGSVG*>(root.release())),
+                                        std::move(fFontMgr),
+                                        std::move(resource_provider),
+                                        std::move(mapper),
+                                        std::move(factory)));
+}
+
+SkSVGDOM::SkSVGDOM(sk_sp<SkSVGSVG> root,
+                   sk_sp<SkFontMgr> fmgr,
+                   sk_sp<skresources::ResourceProvider> rp,
+                   SkSVGIDMapper&& mapper,
+                   sk_sp<SkShapers::Factory> fact)
+        : fRoot(std::move(root))
+        , fFontMgr(std::move(fmgr))
+        , fTextShapingFactory(std::move(fact))
+        , fResourceProvider(std::move(rp))
+        , fIDMapper(std::move(mapper))
+        , fContainerSize(fRoot->intrinsicSize(SkSVGLengthContext(SkSize::Make(0, 0)))) {
+    SkASSERT(fResourceProvider);
+    SkASSERT(fTextShapingFactory);
+}
+
+void SkSVGDOM::render(SkCanvas* canvas) const {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+    if (fRoot) {
+        SkSVGLengthContext       lctx(fContainerSize);
+        SkSVGPresentationContext pctx;
+        fRoot->render(SkSVGRenderContext(canvas,
+                                         fFontMgr,
+                                         fResourceProvider,
+                                         fIDMapper,
+                                         lctx,
+                                         pctx,
+                                         {nullptr, nullptr},
+                                         fTextShapingFactory));
+    }
+}
+
+void SkSVGDOM::renderNode(SkCanvas* canvas, SkSVGPresentationContext& pctx, const char* id) const {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+
+    if (fRoot) {
+        SkSVGLengthContext lctx(fContainerSize);
+        fRoot->renderNode(SkSVGRenderContext(canvas,
+                                             fFontMgr,
+                                             fResourceProvider,
+                                             fIDMapper,
+                                             lctx,
+                                             pctx,
+                                             {nullptr, nullptr},
+                                             fTextShapingFactory),
+                          SkSVGIRI(SkSVGIRI::Type::kLocal, SkSVGStringType(id)));
+    }
+}
+
+const SkSize& SkSVGDOM::containerSize() const {
+    return fContainerSize;
+}
+
+void SkSVGDOM::setContainerSize(const SkSize& containerSize) {
+    // TODO: inval
+    fContainerSize = containerSize;
+}
+
+sk_sp<SkSVGNode>* SkSVGDOM::findNodeById(const char* id) {
+    SkString idStr(id);
+    return this->fIDMapper.find(idStr);
+}
+
+// TODO(fuego): move this to SkSVGNode or its own CU.
+bool SkSVGNode::setAttribute(const char* attributeName, const char* attributeValue) {
+    return set_string_attribute(sk_ref_sp(this), attributeName, attributeValue);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp
new file mode 100644
index 00000000..33a8f694
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGEllipse.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "modules/svg/src/SkSVGRectPriv.h"
+
+SkSVGEllipse::SkSVGEllipse() : INHERITED(SkSVGTag::kEllipse) {}
+
+bool SkSVGEllipse::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setCx(SkSVGAttributeParser::parse<SkSVGLength>("cx", n, v)) ||
+           this->setCy(SkSVGAttributeParser::parse<SkSVGLength>("cy", n, v)) ||
+           this->setRx(SkSVGAttributeParser::parse<SkSVGLength>("rx", n, v)) ||
+           this->setRy(SkSVGAttributeParser::parse<SkSVGLength>("ry", n, v));
+}
+
+SkRect SkSVGEllipse::resolve(const SkSVGLengthContext& lctx) const {
+    const auto cx = lctx.resolve(fCx, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto cy = lctx.resolve(fCy, SkSVGLengthContext::LengthType::kVertical);
+
+    // https://www.w3.org/TR/SVG2/shapes.html#EllipseElement
+    //
+    // An auto value for either rx or ry is converted to a used value, following the rules given
+    // above for rectangles (but without any clamping based on width or height).
+    const auto [ rx, ry ] = ResolveOptionalRadii(fRx, fRy, lctx);
+
+    // A computed value of zero for either dimension, or a computed value of auto for both
+    // dimensions, disables rendering of the element.
+    return (rx > 0 && ry > 0)
+        ? SkRect::MakeXYWH(cx - rx, cy - ry, rx * 2, ry * 2)
+        : SkRect::MakeEmpty();
+}
+
+void SkSVGEllipse::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                          const SkPaint& paint, SkPathFillType) const {
+    canvas->drawOval(this->resolve(lctx), paint);
+}
+
+SkPath SkSVGEllipse::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = SkPath::Oval(this->resolve(ctx.lengthContext()));
+    this->mapToParent(&path);
+
+    return path;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp
new file mode 100644
index 00000000..46a89be5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+sk_sp<SkImageFilter> SkSVGFe::makeImageFilter(const SkSVGRenderContext& ctx,
+                                              const SkSVGFilterContext& fctx) const {
+    return this->onMakeImageFilter(ctx, fctx);
+}
+
+SkRect SkSVGFe::resolveBoundaries(const SkSVGRenderContext& ctx,
+                                  const SkSVGFilterContext& fctx) const {
+    const auto x = fX.isValid() ? *fX : SkSVGLength(0, SkSVGLength::Unit::kPercentage);
+    const auto y = fY.isValid() ? *fY : SkSVGLength(0, SkSVGLength::Unit::kPercentage);
+    const auto w = fWidth.isValid() ? *fWidth : SkSVGLength(100, SkSVGLength::Unit::kPercentage);
+    const auto h = fHeight.isValid() ? *fHeight : SkSVGLength(100, SkSVGLength::Unit::kPercentage);
+
+    return ctx.resolveOBBRect(x, y, w, h, fctx.primitiveUnits());
+}
+
+static bool AnyIsStandardInput(const SkSVGFilterContext& fctx,
+                               const std::vector<SkSVGFeInputType>& inputs) {
+    for (const auto& in : inputs) {
+        switch (in.type()) {
+            case SkSVGFeInputType::Type::kFilterPrimitiveReference:
+                break;
+            case SkSVGFeInputType::Type::kSourceGraphic:
+            case SkSVGFeInputType::Type::kSourceAlpha:
+            case SkSVGFeInputType::Type::kBackgroundImage:
+            case SkSVGFeInputType::Type::kBackgroundAlpha:
+            case SkSVGFeInputType::Type::kFillPaint:
+            case SkSVGFeInputType::Type::kStrokePaint:
+                return true;
+            case SkSVGFeInputType::Type::kUnspecified:
+                // Unspecified means previous result (which may be SourceGraphic).
+                if (fctx.previousResultIsSourceGraphic()) {
+                    return true;
+                }
+                break;
+        }
+    }
+
+    return false;
+}
+
+SkRect SkSVGFe::resolveFilterSubregion(const SkSVGRenderContext& ctx,
+                                       const SkSVGFilterContext& fctx) const {
+    // From https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveSubRegion,
+    // the default filter effect subregion is equal to the union of the subregions defined
+    // for all "referenced nodes" (filter effect inputs). If there are no inputs, the
+    // default subregion is equal to the filter effects region
+    // (https://www.w3.org/TR/SVG11/filters.html#FilterEffectsRegion).
+    const std::vector<SkSVGFeInputType> inputs = this->getInputs();
+    SkRect defaultSubregion;
+    if (inputs.empty() || AnyIsStandardInput(fctx, inputs)) {
+        defaultSubregion = fctx.filterEffectsRegion();
+    } else {
+        defaultSubregion = fctx.filterPrimitiveSubregion(inputs[0]);
+        for (size_t i = 1; i < inputs.size(); i++) {
+            defaultSubregion.join(fctx.filterPrimitiveSubregion(inputs[i]));
+        }
+    }
+
+    // Next resolve the rect specified by the x, y, width, height attributes on this filter effect.
+    // If those attributes were given, they override the corresponding attribute of the default
+    // filter effect subregion calculated above.
+    const SkRect boundaries = this->resolveBoundaries(ctx, fctx);
+
+    // Compute and return the fully resolved subregion.
+    return SkRect::MakeXYWH(fX.isValid() ? boundaries.fLeft : defaultSubregion.fLeft,
+                            fY.isValid() ? boundaries.fTop : defaultSubregion.fTop,
+                            fWidth.isValid() ? boundaries.width() : defaultSubregion.width(),
+                            fHeight.isValid() ? boundaries.height() : defaultSubregion.height());
+}
+
+SkSVGColorspace SkSVGFe::resolveColorspace(const SkSVGRenderContext& ctx,
+                                           const SkSVGFilterContext&) const {
+    constexpr SkSVGColorspace kDefaultCS = SkSVGColorspace::kSRGB;
+    const SkSVGColorspace cs = *ctx.presentationContext().fInherited.fColorInterpolationFilters;
+    return cs == SkSVGColorspace::kAuto ? kDefaultCS : cs;
+}
+
+void SkSVGFe::applyProperties(SkSVGRenderContext* ctx) const { this->onPrepareToRender(ctx); }
+
+bool SkSVGFe::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn(SkSVGAttributeParser::parse<SkSVGFeInputType>("in", name, value)) ||
+           this->setResult(SkSVGAttributeParser::parse<SkSVGStringType>("result", name, value)) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", name, value)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", name, value)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", name, value));
+}
+
+template <> bool SkSVGAttributeParser::parse(SkSVGFeInputType* type) {
+    static constexpr std::tuple<const char*, SkSVGFeInputType::Type> gTypeMap[] = {
+            {"SourceGraphic", SkSVGFeInputType::Type::kSourceGraphic},
+            {"SourceAlpha", SkSVGFeInputType::Type::kSourceAlpha},
+            {"BackgroundImage", SkSVGFeInputType::Type::kBackgroundImage},
+            {"BackgroundAlpha", SkSVGFeInputType::Type::kBackgroundAlpha},
+            {"FillPaint", SkSVGFeInputType::Type::kFillPaint},
+            {"StrokePaint", SkSVGFeInputType::Type::kStrokePaint},
+    };
+
+    SkSVGStringType resultId;
+    SkSVGFeInputType::Type t;
+    bool parsedValue = false;
+    if (this->parseEnumMap(gTypeMap, &t)) {
+        *type = SkSVGFeInputType(t);
+        parsedValue = true;
+    } else if (parse(&resultId)) {
+        *type = SkSVGFeInputType(resultId);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp
new file mode 100644
index 00000000..eef899c6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkBlendMode.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeBlend.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeBlend::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn2(SkSVGAttributeParser::parse<SkSVGFeInputType>("in2", name, value)) ||
+           this->setMode(SkSVGAttributeParser::parse<SkSVGFeBlend::Mode>("mode", name, value));
+}
+
+static SkBlendMode GetBlendMode(SkSVGFeBlend::Mode mode) {
+    switch (mode) {
+        case SkSVGFeBlend::Mode::kNormal:
+            return SkBlendMode::kSrcOver;
+        case SkSVGFeBlend::Mode::kMultiply:
+            return SkBlendMode::kMultiply;
+        case SkSVGFeBlend::Mode::kScreen:
+            return SkBlendMode::kScreen;
+        case SkSVGFeBlend::Mode::kDarken:
+            return SkBlendMode::kDarken;
+        case SkSVGFeBlend::Mode::kLighten:
+            return SkBlendMode::kLighten;
+    }
+
+    SkUNREACHABLE;
+}
+
+sk_sp<SkImageFilter> SkSVGFeBlend::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkBlendMode blendMode = GetBlendMode(this->getMode());
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+    const sk_sp<SkImageFilter> background = fctx.resolveInput(ctx, fIn2, colorspace);
+    const sk_sp<SkImageFilter> foreground = fctx.resolveInput(ctx, this->getIn(), colorspace);
+    return SkImageFilters::Blend(blendMode, background, foreground, cropRect);
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeBlend::Mode>(
+        SkSVGFeBlend::Mode* mode) {
+    static constexpr std::tuple<const char*, SkSVGFeBlend::Mode> gMap[] = {
+        { "normal"  , SkSVGFeBlend::Mode::kNormal   },
+        { "multiply", SkSVGFeBlend::Mode::kMultiply },
+        { "screen"  , SkSVGFeBlend::Mode::kScreen   },
+        { "darken"  , SkSVGFeBlend::Mode::kDarken   },
+        { "lighten" , SkSVGFeBlend::Mode::kLighten  },
+    };
+
+    return this->parseEnumMap(gMap, mode) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp
new file mode 100644
index 00000000..4c8b34ab
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "include/private/SkColorData.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeColorMatrix.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeColorMatrix::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setType(
+                   SkSVGAttributeParser::parse<SkSVGFeColorMatrixType>("type", name, value)) ||
+           this->setValues(
+                   SkSVGAttributeParser::parse<SkSVGFeColorMatrixValues>("values", name, value));
+}
+
+SkColorMatrix SkSVGFeColorMatrix::makeMatrixForType() const {
+    if (fValues.empty() && fType != SkSVGFeColorMatrixType::kLuminanceToAlpha) {
+        return SkColorMatrix();
+    }
+
+    switch (fType) {
+        case SkSVGFeColorMatrixType::kMatrix: {
+            if (fValues.size() < 20) {
+                return SkColorMatrix();
+            }
+            SkColorMatrix m;
+            m.setRowMajor(fValues.data());
+            return m;
+        }
+        case SkSVGFeColorMatrixType::kSaturate:
+            return MakeSaturate(!fValues.empty() ? fValues[0] : 1);
+        case SkSVGFeColorMatrixType::kHueRotate:
+            return MakeHueRotate(!fValues.empty() ? fValues[0] : 0);
+        case SkSVGFeColorMatrixType::kLuminanceToAlpha:
+            return MakeLuminanceToAlpha();
+    }
+
+    SkUNREACHABLE;
+}
+
+SkColorMatrix SkSVGFeColorMatrix::MakeSaturate(SkSVGNumberType s) {
+    SkColorMatrix m;
+    m.setSaturation(s);
+    return m;
+}
+
+SkColorMatrix SkSVGFeColorMatrix::MakeHueRotate(SkSVGNumberType degrees) {
+    const SkScalar theta = SkDegreesToRadians(degrees);
+    const SkSVGNumberType c = SkScalarCos(theta);
+    const SkSVGNumberType s = SkScalarSin(theta);
+    return SkColorMatrix(
+        0.213f + c* 0.787f + s*-0.213f,
+        0.715f + c*-0.715f + s*-0.715f,
+        0.072f + c*-0.072f + s* 0.928f,
+        0,
+        0,
+
+        0.213f + c*-0.213f + s* 0.143f,
+        0.715f + c* 0.285f + s* 0.140f,
+        0.072f + c*-0.072f + s*-0.283f,
+        0,
+        0,
+
+        0.213f + c*-0.213f + s*-0.787f,
+        0.715f + c*-0.715f + s* 0.715f,
+        0.072f + c* 0.928f + s* 0.072f,
+        0,
+        0,
+
+        0,0,0,1,0
+    );
+}
+
+SkColorMatrix SkSVGFeColorMatrix::MakeLuminanceToAlpha() {
+    return SkColorMatrix(
+        0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0,
+        SK_LUM_COEFF_R, SK_LUM_COEFF_G, SK_LUM_COEFF_B, 0, 0
+    );
+}
+
+sk_sp<SkImageFilter> SkSVGFeColorMatrix::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                           const SkSVGFilterContext& fctx) const {
+    return SkImageFilters::ColorFilter(
+            SkColorFilters::Matrix(makeMatrixForType()),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+template <> bool SkSVGAttributeParser::parse(SkSVGFeColorMatrixType* type) {
+    static constexpr std::tuple<const char*, SkSVGFeColorMatrixType> gTypeMap[] = {
+            {"matrix", SkSVGFeColorMatrixType::kMatrix},
+            {"saturate", SkSVGFeColorMatrixType::kSaturate},
+            {"hueRotate", SkSVGFeColorMatrixType::kHueRotate},
+            {"luminanceToAlpha", SkSVGFeColorMatrixType::kLuminanceToAlpha},
+    };
+
+    return this->parseEnumMap(gTypeMap, type) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp
new file mode 100644
index 00000000..cb227117
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGFeComponentTransfer.h"
+
+#include "include/core/SkColorFilter.h"
+#include "include/core/SkImageFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "include/private/base/SkAssert.h"
+#include "include/private/base/SkFloatingPoint.h"
+#include "include/private/base/SkTPin.h"
+#include "include/private/base/SkTo.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+#include <cmath>
+#include <cstdint>
+
+sk_sp<SkImageFilter> SkSVGFeComponentTransfer::onMakeImageFilter(
+        const SkSVGRenderContext& ctx,
+        const SkSVGFilterContext& fctx) const {
+    std::vector<uint8_t> a_tbl, b_tbl, g_tbl, r_tbl;
+
+    for (const auto& child : fChildren) {
+        switch (child->tag()) {
+            case SkSVGTag::kFeFuncA:
+                a_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            case SkSVGTag::kFeFuncB:
+                b_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            case SkSVGTag::kFeFuncG:
+                g_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            case SkSVGTag::kFeFuncR:
+                r_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            default:
+                break;
+        }
+    }
+    SkASSERT(a_tbl.empty() || a_tbl.size() == 256);
+    SkASSERT(b_tbl.empty() || b_tbl.size() == 256);
+    SkASSERT(g_tbl.empty() || g_tbl.size() == 256);
+    SkASSERT(r_tbl.empty() || r_tbl.size() == 256);
+
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const sk_sp<SkImageFilter> input = fctx.resolveInput(ctx,
+                                                         this->getIn(),
+                                                         this->resolveColorspace(ctx, fctx));
+
+    const auto cf =  SkColorFilters::TableARGB(a_tbl.empty() ? nullptr : a_tbl.data(),
+                                               r_tbl.empty() ? nullptr : r_tbl.data(),
+                                               g_tbl.empty() ? nullptr : g_tbl.data(),
+                                               b_tbl.empty() ? nullptr : b_tbl.data());
+
+    return SkImageFilters::ColorFilter(std::move(cf), std::move(input), cropRect);
+}
+
+std::vector<uint8_t> SkSVGFeFunc::getTable() const {
+    // https://www.w3.org/TR/SVG11/filters.html#feComponentTransferTypeAttribute
+    const auto make_linear = [this]() -> std::vector<uint8_t> {
+        std::vector<uint8_t> tbl(256);
+        const float slope = this->getSlope(),
+             intercept255 = this->getIntercept() * 255;
+
+        for (size_t i = 0; i < 256; ++i) {
+            tbl[i] = SkTPin<int>(sk_float_round2int(intercept255 + i * slope), 0, 255);
+        }
+
+        return tbl;
+    };
+
+    const auto make_gamma = [this]() -> std::vector<uint8_t> {
+        std::vector<uint8_t> tbl(256);
+        const float exponent = this->getExponent(),
+                      offset = this->getOffset();
+
+        for (size_t i = 0; i < 256; ++i) {
+            const float component = offset + std::pow(i * (1 / 255.f), exponent);
+            tbl[i] = SkTPin<int>(sk_float_round2int(component * 255), 0, 255);
+        }
+
+        return tbl;
+    };
+
+    const auto lerp_from_table_values = [this](auto lerp_func) -> std::vector<uint8_t> {
+        const auto& vals = this->getTableValues();
+        if (vals.size() < 2 || vals.size() > 255) {
+            return {};
+        }
+
+        // number of interpolation intervals
+        const size_t n = vals.size() - 1;
+
+        std::vector<uint8_t> tbl(256);
+        for (size_t k = 0; k < n; ++k) {
+            // interpolation values
+            const SkSVGNumberType v0 = SkTPin(vals[k + 0], 0.f, 1.f),
+                                  v1 = SkTPin(vals[k + 1], 0.f, 1.f);
+
+            // start/end component table indices
+            const size_t c_start = k * 255 / n,
+                         c_end   = (k + 1) * 255 / n;
+            SkASSERT(c_end <= 255);
+
+            for (size_t ci = c_start; ci < c_end; ++ci) {
+                const float lerp_t = static_cast<float>(ci - c_start) / (c_end - c_start),
+                         component = lerp_func(v0, v1, lerp_t);
+                SkASSERT(component >= 0 && component <= 1);
+
+                tbl[ci] = SkToU8(sk_float_round2int(component * 255));
+            }
+        }
+
+        tbl.back() = SkToU8(sk_float_round2int(255 * SkTPin(vals.back(), 0.f, 1.f)));
+
+        return tbl;
+    };
+
+    const auto make_table = [&]() -> std::vector<uint8_t> {
+        return lerp_from_table_values([](float v0, float v1, float t) {
+            return v0 + (v1 - v0) * t;
+        });
+    };
+
+    const auto make_discrete = [&]() -> std::vector<uint8_t> {
+        return lerp_from_table_values([](float v0, float v1, float t) {
+            return v0;
+        });
+    };
+
+    switch (this->getType()) {
+        case SkSVGFeFuncType::kIdentity: return {};
+        case SkSVGFeFuncType::kTable:    return make_table();
+        case SkSVGFeFuncType::kDiscrete: return make_discrete();
+        case SkSVGFeFuncType::kLinear:   return make_linear();
+        case SkSVGFeFuncType::kGamma:    return make_gamma();
+    }
+
+    SkUNREACHABLE;
+}
+
+bool SkSVGFeFunc::parseAndSetAttribute(const char* name, const char* val) {
+    return INHERITED::parseAndSetAttribute(name, val) ||
+      this->setAmplitude(SkSVGAttributeParser::parse<SkSVGNumberType>("amplitude", name, val)) ||
+      this->setExponent(SkSVGAttributeParser::parse<SkSVGNumberType>("exponent", name, val)) ||
+      this->setIntercept(SkSVGAttributeParser::parse<SkSVGNumberType>("intercept", name, val)) ||
+      this->setOffset(SkSVGAttributeParser::parse<SkSVGNumberType>("offset", name, val)) ||
+      this->setSlope(SkSVGAttributeParser::parse<SkSVGNumberType>("slope", name, val)) ||
+      this->setTableValues(SkSVGAttributeParser::parse<std::vector<SkSVGNumberType>>("tableValues",
+                                                                                     name, val)) ||
+      this->setType(SkSVGAttributeParser::parse<SkSVGFeFuncType>("type", name, val));
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFeFuncType* type) {
+    static constexpr std::tuple<const char*, SkSVGFeFuncType> gTypeMap[] = {
+            { "identity", SkSVGFeFuncType::kIdentity },
+            { "table"   , SkSVGFeFuncType::kTable    },
+            { "discrete", SkSVGFeFuncType::kDiscrete },
+            { "linear"  , SkSVGFeFuncType::kLinear   },
+            { "gamma"   , SkSVGFeFuncType::kGamma    },
+    };
+
+    return this->parseEnumMap(gTypeMap, type) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp
new file mode 100644
index 00000000..3ae12d9f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeComposite.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+bool SkSVGFeComposite::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           // SkSVGFeInputType parsing defined in SkSVGFe.cpp:
+           this->setIn2(SkSVGAttributeParser::parse<SkSVGFeInputType>("in2", name, value)) ||
+           this->setK1(SkSVGAttributeParser::parse<SkSVGNumberType>("k1", name, value)) ||
+           this->setK2(SkSVGAttributeParser::parse<SkSVGNumberType>("k2", name, value)) ||
+           this->setK3(SkSVGAttributeParser::parse<SkSVGNumberType>("k3", name, value)) ||
+           this->setK4(SkSVGAttributeParser::parse<SkSVGNumberType>("k4", name, value)) ||
+           this->setOperator(
+                   SkSVGAttributeParser::parse<SkSVGFeCompositeOperator>("operator", name, value));
+}
+
+SkBlendMode SkSVGFeComposite::BlendModeForOperator(SkSVGFeCompositeOperator op) {
+    switch (op) {
+        case SkSVGFeCompositeOperator::kOver:
+            return SkBlendMode::kSrcOver;
+        case SkSVGFeCompositeOperator::kIn:
+            return SkBlendMode::kSrcIn;
+        case SkSVGFeCompositeOperator::kOut:
+            return SkBlendMode::kSrcOut;
+        case SkSVGFeCompositeOperator::kAtop:
+            return SkBlendMode::kSrcATop;
+        case SkSVGFeCompositeOperator::kXor:
+            return SkBlendMode::kXor;
+        case SkSVGFeCompositeOperator::kArithmetic:
+            // Arithmetic is not handled with a blend
+            SkASSERT(false);
+            return SkBlendMode::kSrcOver;
+    }
+
+    SkUNREACHABLE;
+}
+
+sk_sp<SkImageFilter> SkSVGFeComposite::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                         const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+    const sk_sp<SkImageFilter> background = fctx.resolveInput(ctx, fIn2, colorspace);
+    const sk_sp<SkImageFilter> foreground = fctx.resolveInput(ctx, this->getIn(), colorspace);
+    if (fOperator == SkSVGFeCompositeOperator::kArithmetic) {
+        constexpr bool enforcePMColor = true;
+        return SkImageFilters::Arithmetic(
+                fK1, fK2, fK3, fK4, enforcePMColor, background, foreground, cropRect);
+    } else {
+        return SkImageFilters::Blend(
+                BlendModeForOperator(fOperator), background, foreground, cropRect);
+    }
+}
+
+template <> bool SkSVGAttributeParser::parse(SkSVGFeCompositeOperator* op) {
+    static constexpr std::tuple<const char*, SkSVGFeCompositeOperator> gOpMap[] = {
+            {"over", SkSVGFeCompositeOperator::kOver},
+            {"in", SkSVGFeCompositeOperator::kIn},
+            {"out", SkSVGFeCompositeOperator::kOut},
+            {"atop", SkSVGFeCompositeOperator::kAtop},
+            {"xor", SkSVGFeCompositeOperator::kXor},
+            {"arithmetic", SkSVGFeCompositeOperator::kArithmetic},
+    };
+
+    return this->parseEnumMap(gOpMap, op) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp
new file mode 100644
index 00000000..9698a55c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeDisplacementMap.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeDisplacementMap::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn2(SkSVGAttributeParser::parse<SkSVGFeInputType>("in2", name, value)) ||
+           this->setXChannelSelector(
+                   SkSVGAttributeParser::parse<SkSVGFeDisplacementMap::ChannelSelector>(
+                           "xChannelSelector", name, value)) ||
+           this->setYChannelSelector(
+                   SkSVGAttributeParser::parse<SkSVGFeDisplacementMap::ChannelSelector>(
+                           "yChannelSelector", name, value)) ||
+           this->setScale(SkSVGAttributeParser::parse<SkSVGNumberType>("scale", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDisplacementMap::onMakeImageFilter(
+        const SkSVGRenderContext& ctx, const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+
+    // According to spec https://www.w3.org/TR/SVG11/filters.html#feDisplacementMapElement,
+    // the 'in' source image must remain in its current colorspace.
+    sk_sp<SkImageFilter> in = fctx.resolveInput(ctx, this->getIn());
+    sk_sp<SkImageFilter> in2 = fctx.resolveInput(ctx, this->getIn2(), colorspace);
+
+    SkScalar scale = fScale;
+    if (fctx.primitiveUnits().type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox) {
+        const auto obbt = ctx.transformForCurrentOBB(fctx.primitiveUnits());
+        scale = SkSVGLengthContext({obbt.scale.x, obbt.scale.y})
+                    .resolve(SkSVGLength(scale, SkSVGLength::Unit::kPercentage),
+                             SkSVGLengthContext::LengthType::kOther);
+    }
+
+    return SkImageFilters::DisplacementMap(
+            fXChannelSelector, fYChannelSelector, scale, in2, in, cropRect);
+}
+
+SkSVGColorspace SkSVGFeDisplacementMap::resolveColorspace(const SkSVGRenderContext& ctx,
+                                                          const SkSVGFilterContext& fctx) const {
+    // According to spec https://www.w3.org/TR/SVG11/filters.html#feDisplacementMapElement,
+    // the 'in' source image must remain in its current colorspace, which means the colorspace of
+    // this FE node is the same as the input.
+    return fctx.resolveInputColorspace(ctx, this->getIn());
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeDisplacementMap::ChannelSelector>(
+        SkSVGFeDisplacementMap::ChannelSelector* channel) {
+    static constexpr std::tuple<const char*, SkSVGFeDisplacementMap::ChannelSelector> gMap[] = {
+            { "R", SkSVGFeDisplacementMap::ChannelSelector::kR },
+            { "G", SkSVGFeDisplacementMap::ChannelSelector::kG },
+            { "B", SkSVGFeDisplacementMap::ChannelSelector::kB },
+            { "A", SkSVGFeDisplacementMap::ChannelSelector::kA },
+    };
+
+    return this->parseEnumMap(gMap, channel) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp
new file mode 100644
index 00000000..7dccc235
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGFeFlood.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkColor SkSVGFeFlood::resolveFloodColor(const SkSVGRenderContext& ctx) const {
+    const auto floodColor = this->getFloodColor();
+    const auto floodOpacity = this->getFloodOpacity();
+    // Uninherited presentation attributes should have a concrete value by now.
+    if (!floodColor.isValue() || !floodOpacity.isValue()) {
+        SkDebugf("unhandled: flood-color or flood-opacity has no value\n");
+        return SK_ColorBLACK;
+    }
+
+    const SkColor color = ctx.resolveSvgColor(*floodColor);
+    return SkColorSetA(color, SkScalarRoundToInt(*floodOpacity * 255));
+}
+
+sk_sp<SkImageFilter> SkSVGFeFlood::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    return SkImageFilters::Shader(SkShaders::Color(resolveFloodColor(ctx)),
+                                  this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp
new file mode 100644
index 00000000..1443845a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeGaussianBlur.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeGaussianBlur::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setStdDeviation(SkSVGAttributeParser::parse<SkSVGFeGaussianBlur::StdDeviation>(
+                   "stdDeviation", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeGaussianBlur::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                            const SkSVGFilterContext& fctx) const {
+    const auto sigma = SkV2{fStdDeviation.fX, fStdDeviation.fY}
+                     * ctx.transformForCurrentOBB(fctx.primitiveUnits()).scale;
+
+    return SkImageFilters::Blur(
+            sigma.x, sigma.y,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeGaussianBlur::StdDeviation>(
+        SkSVGFeGaussianBlur::StdDeviation* stdDeviation) {
+    std::vector<SkSVGNumberType> values;
+    if (!this->parse(&values)) {
+        return false;
+    }
+
+    stdDeviation->fX = values[0];
+    stdDeviation->fY = values.size() > 1 ? values[1] : values[0];
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp
new file mode 100644
index 00000000..9767b371
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkSamplingOptions.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGFeImage.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGImage.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeImage::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", n, v)) ||
+           this->setPreserveAspectRatio(SkSVGAttributeParser::parse<SkSVGPreserveAspectRatio>(
+                   "preserveAspectRatio", n, v));
+}
+
+sk_sp<SkImageFilter> SkSVGFeImage::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    // Load image and map viewbox (image bounds) to viewport (filter effects subregion).
+    const SkRect viewport = this->resolveFilterSubregion(ctx, fctx);
+    const auto imgInfo =
+            SkSVGImage::LoadImage(ctx.resourceProvider(), fHref, viewport, fPreserveAspectRatio);
+    if (!imgInfo.fImage) {
+        return nullptr;
+    }
+
+    // Create the image filter mapped according to aspect ratio
+    const SkRect srcRect = SkRect::Make(imgInfo.fImage->bounds());
+    const SkRect& dstRect = imgInfo.fDst;
+    // TODO: image-rendering property
+    auto imgfilt = SkImageFilters::Image(imgInfo.fImage, srcRect, dstRect,
+                                         SkSamplingOptions(SkFilterMode::kLinear,
+                                                           SkMipmapMode::kNearest));
+
+    // Aspect ratio mapping may end up drawing content outside of the filter effects region,
+    // so perform an explicit crop.
+    return SkImageFilters::Merge(&imgfilt, 1, fctx.filterEffectsRegion());
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp
new file mode 100644
index 00000000..2f059570
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeLightSource.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkPoint3 SkSVGFeDistantLight::computeDirection() const {
+    // Computing direction from azimuth+elevation is two 3D rotations:
+    //  - Rotate [1,0,0] about y axis first (elevation)
+    //  - Rotate result about z axis (azimuth)
+    // Which is just the first column vector in the 3x3 matrix Rz*Ry.
+    const float azimuthRad = SkDegreesToRadians(fAzimuth);
+    const float elevationRad = SkDegreesToRadians(fElevation);
+    const float sinAzimuth = sinf(azimuthRad), cosAzimuth = cosf(azimuthRad);
+    const float sinElevation = sinf(elevationRad), cosElevation = cosf(elevationRad);
+    return SkPoint3::Make(cosAzimuth * cosElevation, sinAzimuth * cosElevation, sinElevation);
+}
+
+bool SkSVGFeDistantLight::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setAzimuth(SkSVGAttributeParser::parse<SkSVGNumberType>("azimuth", n, v)) ||
+           this->setElevation(SkSVGAttributeParser::parse<SkSVGNumberType>("elevation", n, v));
+}
+
+bool SkSVGFePointLight::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGNumberType>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGNumberType>("y", n, v)) ||
+           this->setZ(SkSVGAttributeParser::parse<SkSVGNumberType>("z", n, v));
+}
+
+bool SkSVGFeSpotLight::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGNumberType>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGNumberType>("y", n, v)) ||
+           this->setZ(SkSVGAttributeParser::parse<SkSVGNumberType>("z", n, v)) ||
+           this->setPointsAtX(SkSVGAttributeParser::parse<SkSVGNumberType>("pointsAtX", n, v)) ||
+           this->setPointsAtY(SkSVGAttributeParser::parse<SkSVGNumberType>("pointsAtY", n, v)) ||
+           this->setPointsAtZ(SkSVGAttributeParser::parse<SkSVGNumberType>("pointsAtZ", n, v)) ||
+           this->setSpecularExponent(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("specularExponent", n, v)) ||
+           this->setLimitingConeAngle(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("limitingConeAngle", n, v));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp
new file mode 100644
index 00000000..61816b97
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkPoint3.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeLightSource.h"
+#include "modules/svg/include/SkSVGFeLighting.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeLighting::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setSurfaceScale(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("surfaceScale", n, v)) ||
+           this->setKernelUnitLength(SkSVGAttributeParser::parse<SkSVGFeLighting::KernelUnitLength>(
+                   "kernelUnitLength", n, v));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeLighting::KernelUnitLength>(
+        SkSVGFeLighting::KernelUnitLength* kernelUnitLength) {
+    std::vector<SkSVGNumberType> values;
+    if (!this->parse(&values)) {
+        return false;
+    }
+
+    kernelUnitLength->fDx = values[0];
+    kernelUnitLength->fDy = values.size() > 1 ? values[1] : values[0];
+    return true;
+}
+
+sk_sp<SkImageFilter> SkSVGFeLighting::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                        const SkSVGFilterContext& fctx) const {
+    for (const auto& child : fChildren) {
+        switch (child->tag()) {
+            case SkSVGTag::kFeDistantLight:
+                return this->makeDistantLight(
+                        ctx, fctx, static_cast<const SkSVGFeDistantLight*>(child.get()));
+            case SkSVGTag::kFePointLight:
+                return this->makePointLight(
+                        ctx, fctx, static_cast<const SkSVGFePointLight*>(child.get()));
+            case SkSVGTag::kFeSpotLight:
+                return this->makeSpotLight(
+                        ctx, fctx, static_cast<const SkSVGFeSpotLight*>(child.get()));
+            default:
+                // Ignore unknown children, such as <desc> elements
+                break;
+        }
+    }
+
+    SkDebugf("lighting filter effect needs exactly one light source\n");
+    return nullptr;
+}
+
+SkColor SkSVGFeLighting::resolveLightingColor(const SkSVGRenderContext& ctx) const {
+    const auto color = this->getLightingColor();
+    if (!color.isValue()) {
+        // Uninherited presentation attributes should have a concrete value by now.
+        SkDebugf("unhandled: lighting-color has no value\n");
+        return SK_ColorWHITE;
+    }
+
+    return ctx.resolveSvgColor(*color);
+}
+
+SkPoint3 SkSVGFeLighting::resolveXYZ(const SkSVGRenderContext& ctx,
+                                     const SkSVGFilterContext& fctx,
+                                     SkSVGNumberType x,
+                                     SkSVGNumberType y,
+                                     SkSVGNumberType z) const {
+    const auto obbt = ctx.transformForCurrentOBB(fctx.primitiveUnits());
+    const auto xy = SkV2{x,y} * obbt.scale + obbt.offset;
+    z = SkSVGLengthContext({obbt.scale.x, obbt.scale.y})
+            .resolve(SkSVGLength(z * 100.f, SkSVGLength::Unit::kPercentage),
+                     SkSVGLengthContext::LengthType::kOther);
+    return SkPoint3::Make(xy.x, xy.y, z);
+}
+
+bool SkSVGFeSpecularLighting::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setSpecularConstant(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("specularConstant", n, v)) ||
+           this->setSpecularExponent(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("specularExponent", n, v));
+}
+
+sk_sp<SkImageFilter> SkSVGFeSpecularLighting::makeDistantLight(
+        const SkSVGRenderContext& ctx,
+        const SkSVGFilterContext& fctx,
+        const SkSVGFeDistantLight* light) const {
+    const SkPoint3 dir = light->computeDirection();
+    return SkImageFilters::DistantLitSpecular(
+            this->resolveXYZ(ctx, fctx, dir.fX, dir.fY, dir.fZ),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            fSpecularConstant,
+            fSpecularExponent,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeSpecularLighting::makePointLight(const SkSVGRenderContext& ctx,
+                                                             const SkSVGFilterContext& fctx,
+                                                             const SkSVGFePointLight* light) const {
+    return SkImageFilters::PointLitSpecular(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            fSpecularConstant,
+            fSpecularExponent,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeSpecularLighting::makeSpotLight(const SkSVGRenderContext& ctx,
+                                                            const SkSVGFilterContext& fctx,
+                                                            const SkSVGFeSpotLight* light) const {
+    const auto& limitingConeAngle = light->getLimitingConeAngle();
+    const float cutoffAngle = limitingConeAngle.isValid() ? *limitingConeAngle : 180.f;
+
+    return SkImageFilters::SpotLitSpecular(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveXYZ(
+                    ctx, fctx, light->getPointsAtX(), light->getPointsAtY(), light->getPointsAtZ()),
+            light->getSpecularExponent(),
+            cutoffAngle,
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            fSpecularConstant,
+            fSpecularExponent,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+bool SkSVGFeDiffuseLighting::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setDiffuseConstant(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("diffuseConstant", n, v));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDiffuseLighting::makeDistantLight(
+        const SkSVGRenderContext& ctx,
+        const SkSVGFilterContext& fctx,
+        const SkSVGFeDistantLight* light) const {
+    const SkPoint3 dir = light->computeDirection();
+    return SkImageFilters::DistantLitDiffuse(
+            this->resolveXYZ(ctx, fctx, dir.fX, dir.fY, dir.fZ),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            this->getDiffuseConstant(),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDiffuseLighting::makePointLight(const SkSVGRenderContext& ctx,
+                                                            const SkSVGFilterContext& fctx,
+                                                            const SkSVGFePointLight* light) const {
+    return SkImageFilters::PointLitDiffuse(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            this->getDiffuseConstant(),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDiffuseLighting::makeSpotLight(const SkSVGRenderContext& ctx,
+                                                           const SkSVGFilterContext& fctx,
+                                                           const SkSVGFeSpotLight* light) const {
+    const auto& limitingConeAngle = light->getLimitingConeAngle();
+    const float cutoffAngle = limitingConeAngle.isValid() ? *limitingConeAngle : 180.f;
+
+    return SkImageFilters::SpotLitDiffuse(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveXYZ(
+                    ctx, fctx, light->getPointsAtX(), light->getPointsAtY(), light->getPointsAtZ()),
+            light->getSpecularExponent(),
+            cutoffAngle,
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            this->getDiffuseConstant(),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp
new file mode 100644
index 00000000..6d476b34
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGFeMerge.h"
+
+#include "include/core/SkImageFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "include/private/base/SkTArray.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGNode.h"
+
+bool SkSVGFeMergeNode::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn(SkSVGAttributeParser::parse<SkSVGFeInputType>("in", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeMerge::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+
+    skia_private::STArray<8, sk_sp<SkImageFilter>> merge_node_filters;
+    merge_node_filters.reserve(fChildren.size());
+
+    this->forEachChild<SkSVGFeMergeNode>([&](const SkSVGFeMergeNode* child) {
+        merge_node_filters.push_back(fctx.resolveInput(ctx, child->getIn(), colorspace));
+    });
+
+    return SkImageFilters::Merge(merge_node_filters.data(),
+                                 merge_node_filters.size(),
+                                 this->resolveFilterSubregion(ctx, fctx));
+}
+
+std::vector<SkSVGFeInputType> SkSVGFeMerge::getInputs() const {
+    std::vector<SkSVGFeInputType> inputs;
+    inputs.reserve(fChildren.size());
+
+    this->forEachChild<SkSVGFeMergeNode>([&](const SkSVGFeMergeNode* child) {
+        inputs.push_back(child->getIn());
+    });
+
+    return inputs;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp
new file mode 100644
index 00000000..77b834bc
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeMorphology.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeMorphology::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setOperator(SkSVGAttributeParser::parse<SkSVGFeMorphology::Operator>(
+                   "operator", name, value)) ||
+           this->setRadius(SkSVGAttributeParser::parse<SkSVGFeMorphology::Radius>(
+                   "radius", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeMorphology::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                          const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+    sk_sp<SkImageFilter> input = fctx.resolveInput(ctx, this->getIn(), colorspace);
+
+    const auto r = SkV2{fRadius.fX, fRadius.fY}
+                 * ctx.transformForCurrentOBB(fctx.primitiveUnits()).scale;
+    switch (fOperator) {
+        case Operator::kErode:
+            return SkImageFilters::Erode(r.x, r.y, input, cropRect);
+        case Operator::kDilate:
+            return SkImageFilters::Dilate(r.x, r.y, input, cropRect);
+    }
+
+    SkUNREACHABLE;
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeMorphology::Operator>(SkSVGFeMorphology::Operator* op) {
+    static constexpr std::tuple<const char*, SkSVGFeMorphology::Operator> gMap[] = {
+            { "dilate", SkSVGFeMorphology::Operator::kDilate },
+            { "erode" , SkSVGFeMorphology::Operator::kErode  },
+    };
+
+    return this->parseEnumMap(gMap, op) && this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeMorphology::Radius>(SkSVGFeMorphology::Radius* radius) {
+    std::vector<SkSVGNumberType> values;
+    if (!this->parse(&values)) {
+        return false;
+    }
+
+    radius->fX = values[0];
+    radius->fY = values.size() > 1 ? values[1] : values[0];
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp
new file mode 100644
index 00000000..057a4048
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeOffset.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeOffset::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setDx(SkSVGAttributeParser::parse<SkSVGNumberType>("dx", name, value)) ||
+           this->setDy(SkSVGAttributeParser::parse<SkSVGNumberType>("dy", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeOffset::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                      const SkSVGFilterContext& fctx) const {
+    const auto d = SkV2{this->getDx(), this->getDy()}
+                 * ctx.transformForCurrentOBB(fctx.primitiveUnits()).scale;
+
+    sk_sp<SkImageFilter> in =
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx));
+    return SkImageFilters::Offset(d.x, d.y, std::move(in), this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp
new file mode 100644
index 00000000..8357e6e5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "include/effects/SkPerlinNoiseShader.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeTurbulence.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeTurbulence::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setNumOctaves(
+                   SkSVGAttributeParser::parse<SkSVGIntegerType>("numOctaves", name, value)) ||
+           this->setSeed(SkSVGAttributeParser::parse<SkSVGNumberType>("seed", name, value)) ||
+           this->setBaseFrequency(SkSVGAttributeParser::parse<SkSVGFeTurbulenceBaseFrequency>(
+                   "baseFrequency", name, value)) ||
+           this->setTurbulenceType(SkSVGAttributeParser::parse<SkSVGFeTurbulenceType>(
+                   "type", name, value));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeTurbulenceBaseFrequency>(
+        SkSVGFeTurbulenceBaseFrequency* freq) {
+    SkSVGNumberType freqX;
+    if (!this->parse(&freqX)) {
+        return false;
+    }
+
+    SkSVGNumberType freqY;
+    this->parseCommaWspToken();
+    if (this->parse(&freqY)) {
+        *freq = SkSVGFeTurbulenceBaseFrequency(freqX, freqY);
+    } else {
+        *freq = SkSVGFeTurbulenceBaseFrequency(freqX, freqX);
+    }
+
+    return this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeTurbulenceType>(SkSVGFeTurbulenceType* type) {
+    bool parsedValue = false;
+
+    if (this->parseExpectedStringToken("fractalNoise")) {
+        *type = SkSVGFeTurbulenceType(SkSVGFeTurbulenceType::kFractalNoise);
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("turbulence")) {
+        *type = SkSVGFeTurbulenceType(SkSVGFeTurbulenceType::kTurbulence);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+sk_sp<SkImageFilter> SkSVGFeTurbulence::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                          const SkSVGFilterContext& fctx) const {
+    const SkISize* tileSize = nullptr;  // TODO: needs filter element subregion properties
+
+    sk_sp<SkShader> shader;
+    switch (fTurbulenceType.fType) {
+        case SkSVGFeTurbulenceType::Type::kTurbulence:
+            shader = SkShaders::MakeTurbulence(
+                    fBaseFrequency.freqX(), fBaseFrequency.freqY(), fNumOctaves, fSeed, tileSize);
+            break;
+        case SkSVGFeTurbulenceType::Type::kFractalNoise:
+            shader = SkShaders::MakeFractalNoise(
+                    fBaseFrequency.freqX(), fBaseFrequency.freqY(), fNumOctaves, fSeed, tileSize);
+            break;
+    }
+
+    return SkImageFilters::Shader(shader, this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp
new file mode 100644
index 00000000..0258c3d2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGFilter.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFilter::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", name, value)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", name, value)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", name, value)) ||
+           this->setFilterUnits(SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(
+                   "filterUnits", name, value)) ||
+           this->setPrimitiveUnits(SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(
+                   "primitiveUnits", name, value));
+}
+
+void SkSVGFilter::applyProperties(SkSVGRenderContext* ctx) const { this->onPrepareToRender(ctx); }
+
+sk_sp<SkImageFilter> SkSVGFilter::buildFilterDAG(const SkSVGRenderContext& ctx) const {
+    sk_sp<SkImageFilter> filter;
+    SkSVGFilterContext fctx(ctx.resolveOBBRect(fX, fY, fWidth, fHeight, fFilterUnits),
+                            fPrimitiveUnits);
+    SkSVGRenderContext localCtx(ctx);
+    this->applyProperties(&localCtx);
+    SkSVGColorspace cs = SkSVGColorspace::kSRGB;
+    for (const auto& child : fChildren) {
+        if (!SkSVGFe::IsFilterEffect(child)) {
+            continue;
+        }
+
+        const auto& feNode = static_cast<const SkSVGFe&>(*child);
+        const auto& feResultType = feNode.getResult();
+
+        // Propagate any inherited properties that may impact filter effect behavior (e.g.
+        // color-interpolation-filters). We call this explicitly here because the SkSVGFe
+        // nodes do not participate in the normal onRender path, which is when property
+        // propagation currently occurs.
+        SkSVGRenderContext localChildCtx(localCtx);
+        feNode.applyProperties(&localChildCtx);
+
+        const SkRect filterSubregion = feNode.resolveFilterSubregion(localChildCtx, fctx);
+        cs = feNode.resolveColorspace(localChildCtx, fctx);
+        filter = feNode.makeImageFilter(localChildCtx, fctx);
+
+        if (!feResultType.isEmpty()) {
+            fctx.registerResult(feResultType, filter, filterSubregion, cs);
+        }
+
+        // Unspecified 'in' and 'in2' inputs implicitly resolve to the previous filter's result.
+        fctx.setPreviousResult(filter, filterSubregion, cs);
+    }
+
+    // Convert to final destination colorspace
+    if (cs != SkSVGColorspace::kSRGB) {
+        filter = SkImageFilters::ColorFilter(SkColorFilters::LinearToSRGBGamma(), filter);
+    }
+
+    return filter;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp
new file mode 100644
index 00000000..61b97091
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/svg/include/SkSVGFilterContext.h"
+
+#include "include/core/SkBlendMode.h"
+#include "include/core/SkColorFilter.h"
+#include "include/core/SkColorSpace.h"
+#include "include/effects/SkColorMatrix.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+namespace {
+
+sk_sp<SkImageFilter> ConvertFilterColorspace(sk_sp<SkImageFilter>&& input,
+                                             SkSVGColorspace src,
+                                             SkSVGColorspace dst) {
+    if (src == dst) {
+        return std::move(input);
+    } else if (src == SkSVGColorspace::kSRGB && dst == SkSVGColorspace::kLinearRGB) {
+        return SkImageFilters::ColorFilter(SkColorFilters::SRGBToLinearGamma(), input);
+    } else {
+        SkASSERT(src == SkSVGColorspace::kLinearRGB && dst == SkSVGColorspace::kSRGB);
+        return SkImageFilters::ColorFilter(SkColorFilters::LinearToSRGBGamma(), input);
+    }
+}
+
+sk_sp<SkShader> paint_as_shader(const SkPaint& paint) {
+    sk_sp<SkShader> shader = paint.refShader();
+    auto color = paint.getColor4f();
+    if (shader && color.fA < 1.f) {
+        // Multiply by paint alpha
+        shader = shader->makeWithColorFilter(
+                SkColorFilters::Blend(color, /*colorSpace=*/nullptr, SkBlendMode::kDstIn));
+    } else if (!shader) {
+        shader = SkShaders::Color(color, /*colorSpace=*/nullptr);
+    }
+    if (paint.getColorFilter()) {
+        shader = shader->makeWithColorFilter(paint.refColorFilter());
+    }
+    return shader;
+}
+
+}  // namespace
+
+const SkSVGFilterContext::Result* SkSVGFilterContext::findResultById(
+        const SkSVGStringType& id) const {
+    return fResults.find(id);
+}
+
+const SkRect& SkSVGFilterContext::filterPrimitiveSubregion(const SkSVGFeInputType& input) const {
+    const Result* res = nullptr;
+    if (input.type() == SkSVGFeInputType::Type::kFilterPrimitiveReference) {
+        res = fResults.find(input.id());
+    } else if (input.type() == SkSVGFeInputType::Type::kUnspecified) {
+        res = &fPreviousResult;
+    }
+    return res ? res->fFilterSubregion : fFilterEffectsRegion;
+}
+
+void SkSVGFilterContext::registerResult(const SkSVGStringType& id,
+                                        const sk_sp<SkImageFilter>& result,
+                                        const SkRect& subregion,
+                                        SkSVGColorspace resultColorspace) {
+    SkASSERT(!id.isEmpty());
+    fResults[id] = {result, subregion, resultColorspace};
+}
+
+void SkSVGFilterContext::setPreviousResult(const sk_sp<SkImageFilter>& result,
+                                           const SkRect& subregion,
+                                           SkSVGColorspace resultColorspace) {
+    fPreviousResult = {result, subregion, resultColorspace};
+}
+
+bool SkSVGFilterContext::previousResultIsSourceGraphic() const {
+    return fPreviousResult.fImageFilter == nullptr;
+}
+
+// https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveInAttribute
+std::tuple<sk_sp<SkImageFilter>, SkSVGColorspace> SkSVGFilterContext::getInput(
+        const SkSVGRenderContext& ctx, const SkSVGFeInputType& inputType) const {
+    SkSVGColorspace inputCS = SkSVGColorspace::kSRGB;
+    sk_sp<SkImageFilter> result;
+    switch (inputType.type()) {
+        case SkSVGFeInputType::Type::kSourceAlpha: {
+            SkColorMatrix m;
+            m.setScale(0, 0, 0, 1.0f);
+            result = SkImageFilters::ColorFilter(SkColorFilters::Matrix(m), nullptr);
+            break;
+        }
+        case SkSVGFeInputType::Type::kSourceGraphic:
+            // Do nothing.
+            break;
+        case SkSVGFeInputType::Type::kFillPaint: {
+            const auto& fillPaint = ctx.fillPaint();
+            if (fillPaint.isValid()) {
+                auto dither = fillPaint->isDither() ? SkImageFilters::Dither::kYes
+                                                    : SkImageFilters::Dither::kNo;
+                result = SkImageFilters::Shader(paint_as_shader(*fillPaint), dither);
+            }
+            break;
+        }
+        case SkSVGFeInputType::Type::kStrokePaint: {
+            // The paint filter doesn't apply fill/stroke styling, but use the paint settings
+            // defined for strokes.
+            const auto& strokePaint = ctx.strokePaint();
+            if (strokePaint.isValid()) {
+                auto dither = strokePaint->isDither() ? SkImageFilters::Dither::kYes
+                                                      : SkImageFilters::Dither::kNo;
+                result = SkImageFilters::Shader(paint_as_shader(*strokePaint), dither);
+            }
+            break;
+        }
+        case SkSVGFeInputType::Type::kFilterPrimitiveReference: {
+            const Result* res = findResultById(inputType.id());
+            if (res) {
+                result = res->fImageFilter;
+                inputCS = res->fColorspace;
+            }
+            break;
+        }
+        case SkSVGFeInputType::Type::kUnspecified: {
+            result = fPreviousResult.fImageFilter;
+            inputCS = fPreviousResult.fColorspace;
+            break;
+        }
+        default:
+            SkDebugf("unhandled filter input type %d\n", (int)inputType.type());
+            break;
+    }
+
+    return {result, inputCS};
+}
+
+SkSVGColorspace SkSVGFilterContext::resolveInputColorspace(
+        const SkSVGRenderContext& ctx, const SkSVGFeInputType& inputType) const {
+    return std::get<1>(this->getInput(ctx, inputType));
+}
+
+sk_sp<SkImageFilter> SkSVGFilterContext::resolveInput(const SkSVGRenderContext& ctx,
+                                                      const SkSVGFeInputType& inputType) const {
+    return std::get<0>(this->getInput(ctx, inputType));
+}
+
+sk_sp<SkImageFilter> SkSVGFilterContext::resolveInput(const SkSVGRenderContext& ctx,
+                                                      const SkSVGFeInputType& inputType,
+                                                      SkSVGColorspace colorspace) const {
+    auto [result, inputCS] = this->getInput(ctx, inputType);
+    return ConvertFilterColorspace(std::move(result), inputCS, colorspace);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp
new file mode 100644
index 00000000..9f302a7c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/svg/include/SkSVGGradient.h"
+
+#include "include/core/SkTileMode.h"
+#include "include/private/base/SkTPin.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGStop.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGGradient::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setGradientTransform(SkSVGAttributeParser::parse<SkSVGTransformType>(
+                   "gradientTransform", name, value)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", name, value)) ||
+           this->setSpreadMethod(
+                   SkSVGAttributeParser::parse<SkSVGSpreadMethod>("spreadMethod", name, value)) ||
+           this->setGradientUnits(SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(
+                   "gradientUnits", name, value));
+}
+
+// https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementHrefAttribute
+void SkSVGGradient::collectColorStops(const SkSVGRenderContext& ctx,
+                                      StopPositionArray* pos,
+                                      StopColorArray* colors) const {
+    // Used to resolve percentage offsets.
+    const SkSVGLengthContext ltx(SkSize::Make(1, 1));
+
+    this->forEachChild<SkSVGStop>([&](const SkSVGStop* stop) {
+        colors->push_back(this->resolveStopColor(ctx, *stop));
+        pos->push_back(
+            SkTPin(ltx.resolve(stop->getOffset(), SkSVGLengthContext::LengthType::kOther),
+                   0.f, 1.f));
+    });
+
+    SkASSERT(colors->size() == pos->size());
+
+    if (pos->empty() && !fHref.iri().isEmpty()) {
+        const auto ref = ctx.findNodeById(fHref);
+        if (ref && (ref->tag() == SkSVGTag::kLinearGradient ||
+                    ref->tag() == SkSVGTag::kRadialGradient)) {
+            static_cast<const SkSVGGradient*>(ref.get())->collectColorStops(ctx, pos, colors);
+        }
+    }
+}
+
+SkColor4f SkSVGGradient::resolveStopColor(const SkSVGRenderContext& ctx,
+                                          const SkSVGStop& stop) const {
+    const auto& stopColor = stop.getStopColor();
+    const auto& stopOpacity = stop.getStopOpacity();
+    // Uninherited presentation attrs should have a concrete value at this point.
+    if (!stopColor.isValue() || !stopOpacity.isValue()) {
+        SkDebugf("unhandled: stop-color or stop-opacity has no value\n");
+        return SkColors::kBlack;
+    }
+
+    const auto color = SkColor4f::FromColor(ctx.resolveSvgColor(*stopColor));
+
+    return { color.fR, color.fG, color.fB, *stopOpacity * color.fA };
+}
+
+bool SkSVGGradient::onAsPaint(const SkSVGRenderContext& ctx, SkPaint* paint) const {
+    StopColorArray colors;
+    StopPositionArray pos;
+
+    this->collectColorStops(ctx, &pos, &colors);
+
+    // TODO:
+    //       * stop (lazy?) sorting
+    //       * href loop detection
+    //       * href attribute inheritance (not just color stops)
+    //       * objectBoundingBox units support
+
+    static_assert(static_cast<SkTileMode>(SkSVGSpreadMethod::Type::kPad) ==
+                  SkTileMode::kClamp, "SkSVGSpreadMethod::Type is out of sync");
+    static_assert(static_cast<SkTileMode>(SkSVGSpreadMethod::Type::kRepeat) ==
+                  SkTileMode::kRepeat, "SkSVGSpreadMethod::Type is out of sync");
+    static_assert(static_cast<SkTileMode>(SkSVGSpreadMethod::Type::kReflect) ==
+                  SkTileMode::kMirror, "SkSVGSpreadMethod::Type is out of sync");
+    const auto tileMode = static_cast<SkTileMode>(fSpreadMethod.type());
+
+    const auto obbt = ctx.transformForCurrentOBB(fGradientUnits);
+    const auto localMatrix = SkMatrix::Translate(obbt.offset.x, obbt.offset.y)
+                           * SkMatrix::Scale(obbt.scale.x, obbt.scale.y)
+                           * fGradientTransform;
+
+    paint->setShader(this->onMakeShader(ctx, colors.begin(), pos.begin(), colors.size(), tileMode,
+                                        localMatrix));
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementSpreadMethodAttribute
+template <>
+bool SkSVGAttributeParser::parse(SkSVGSpreadMethod* spread) {
+    static const struct {
+        SkSVGSpreadMethod::Type fType;
+        const char*             fName;
+    } gSpreadInfo[] = {
+        { SkSVGSpreadMethod::Type::kPad    , "pad"     },
+        { SkSVGSpreadMethod::Type::kReflect, "reflect" },
+        { SkSVGSpreadMethod::Type::kRepeat , "repeat"  },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gSpreadInfo); ++i) {
+        if (this->parseExpectedStringToken(gSpreadInfo[i].fName)) {
+            *spread = SkSVGSpreadMethod(gSpreadInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp
new file mode 100644
index 00000000..083d3820
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkImage.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGImage.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/utils/SkOSPath.h"
+
+bool SkSVGImage::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", n, v)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", n, v)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", n, v)) ||
+           this->setPreserveAspectRatio(SkSVGAttributeParser::parse<SkSVGPreserveAspectRatio>(
+                   "preserveAspectRatio", n, v));
+}
+
+bool SkSVGImage::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    // Width or height of 0 disables rendering per spec:
+    // https://www.w3.org/TR/SVG11/struct.html#ImageElement
+    return !fHref.iri().isEmpty() && fWidth.value() > 0 && fHeight.value() > 0 &&
+           INHERITED::onPrepareToRender(ctx);
+}
+
+static sk_sp<SkImage> LoadImage(const sk_sp<skresources::ResourceProvider>& rp,
+                                const SkSVGIRI& href) {
+    // TODO: It may be better to use the SVG 'id' attribute as the asset id, to allow
+    // clients to perform asset substitution based on element id.
+    sk_sp<skresources::ImageAsset> imageAsset;
+    switch (href.type()) {
+        case SkSVGIRI::Type::kDataURI:
+            imageAsset = rp->loadImageAsset("", href.iri().c_str(), "");
+            break;
+        case SkSVGIRI::Type::kNonlocal: {
+            const auto path = SkOSPath::Dirname(href.iri().c_str());
+            const auto name = SkOSPath::Basename(href.iri().c_str());
+            imageAsset = rp->loadImageAsset(path.c_str(), name.c_str(), /* id */ name.c_str());
+            break;
+        }
+        default:
+            SkDebugf("error loading image: unhandled iri type %d\n", (int)href.type());
+            return nullptr;
+    }
+
+    return imageAsset ? imageAsset->getFrameData(0).image : nullptr;
+}
+
+SkSVGImage::ImageInfo SkSVGImage::LoadImage(const sk_sp<skresources::ResourceProvider>& rp,
+                                            const SkSVGIRI& iri,
+                                            const SkRect& viewPort,
+                                            SkSVGPreserveAspectRatio par) {
+    SkASSERT(rp);
+
+    // TODO: svg sources
+    sk_sp<SkImage> image = ::LoadImage(rp, iri);
+    if (!image) {
+        return {};
+    }
+
+    // Per spec: raster content has implicit viewbox of '0 0 width height'.
+    const SkRect viewBox = SkRect::Make(image->bounds());
+
+    // Map and place at x, y specified by viewport
+    const SkMatrix m = ComputeViewboxMatrix(viewBox, viewPort, par);
+    const SkRect dst = m.mapRect(viewBox).makeOffset(viewPort.fLeft, viewPort.fTop);
+
+    return {std::move(image), dst};
+}
+
+void SkSVGImage::onRender(const SkSVGRenderContext& ctx) const {
+    // Per spec: x, w, width, height attributes establish the new viewport.
+    const SkSVGLengthContext& lctx = ctx.lengthContext();
+    const SkRect viewPort = lctx.resolveRect(fX, fY, fWidth, fHeight);
+
+    const auto imgInfo = LoadImage(ctx.resourceProvider(), fHref, viewPort, fPreserveAspectRatio);
+    if (!imgInfo.fImage) {
+        SkDebugf("can't render image: load image failed\n");
+        return;
+    }
+
+    // TODO: image-rendering property
+    ctx.canvas()->drawImageRect(
+            imgInfo.fImage, imgInfo.fDst, SkSamplingOptions(SkFilterMode::kLinear));
+}
+
+SkPath SkSVGImage::onAsPath(const SkSVGRenderContext&) const { return {}; }
+
+SkRect SkSVGImage::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    const SkSVGLengthContext& lctx = ctx.lengthContext();
+    return lctx.resolveRect(fX, fY, fWidth, fHeight);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp
new file mode 100644
index 00000000..3166d018
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGLine.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGLine::SkSVGLine() : INHERITED(SkSVGTag::kLine) {}
+
+bool SkSVGLine::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX1(SkSVGAttributeParser::parse<SkSVGLength>("x1", n, v)) ||
+           this->setY1(SkSVGAttributeParser::parse<SkSVGLength>("y1", n, v)) ||
+           this->setX2(SkSVGAttributeParser::parse<SkSVGLength>("x2", n, v)) ||
+           this->setY2(SkSVGAttributeParser::parse<SkSVGLength>("y2", n, v));
+}
+
+std::tuple<SkPoint, SkPoint> SkSVGLine::resolve(const SkSVGLengthContext& lctx) const {
+    return std::make_tuple(
+        SkPoint::Make(lctx.resolve(fX1, SkSVGLengthContext::LengthType::kHorizontal),
+                      lctx.resolve(fY1, SkSVGLengthContext::LengthType::kVertical)),
+        SkPoint::Make(lctx.resolve(fX2, SkSVGLengthContext::LengthType::kHorizontal),
+                      lctx.resolve(fY2, SkSVGLengthContext::LengthType::kVertical)));
+}
+
+void SkSVGLine::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                       const SkPaint& paint, SkPathFillType) const {
+    SkPoint p0, p1;
+    std::tie(p0, p1) = this->resolve(lctx);
+
+    canvas->drawLine(p0, p1, paint);
+}
+
+SkPath SkSVGLine::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPoint p0, p1;
+    std::tie(p0, p1) = this->resolve(ctx.lengthContext());
+
+    SkPath path = SkPath::Line(p0, p1);
+    this->mapToParent(&path);
+
+    return path;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp
new file mode 100644
index 00000000..f7833b1d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorSpace.h"
+#include "include/effects/SkGradientShader.h"
+#include "modules/svg/include/SkSVGLinearGradient.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGLinearGradient::SkSVGLinearGradient() : INHERITED(SkSVGTag::kLinearGradient) {}
+
+bool SkSVGLinearGradient::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX1(SkSVGAttributeParser::parse<SkSVGLength>("x1", name, value)) ||
+           this->setY1(SkSVGAttributeParser::parse<SkSVGLength>("y1", name, value)) ||
+           this->setX2(SkSVGAttributeParser::parse<SkSVGLength>("x2", name, value)) ||
+           this->setY2(SkSVGAttributeParser::parse<SkSVGLength>("y2", name, value));
+}
+
+sk_sp<SkShader> SkSVGLinearGradient::onMakeShader(const SkSVGRenderContext& ctx,
+                                                  const SkColor4f* colors, const SkScalar* pos,
+                                                  int count, SkTileMode tm,
+                                                  const SkMatrix& localMatrix) const {
+    const SkSVGLengthContext lctx =
+            this->getGradientUnits().type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox
+                    ? SkSVGLengthContext({1, 1})
+                    : ctx.lengthContext();
+
+    const auto x1 = lctx.resolve(fX1, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto y1 = lctx.resolve(fY1, SkSVGLengthContext::LengthType::kVertical);
+    const auto x2 = lctx.resolve(fX2, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto y2 = lctx.resolve(fY2, SkSVGLengthContext::LengthType::kVertical);
+
+    const SkPoint pts[2] = { {x1, y1}, {x2, y2}};
+
+    return SkGradientShader::MakeLinear(pts, colors, nullptr, pos, count, tm, 0, &localMatrix);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp
new file mode 100644
index 00000000..849ecc3f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGMask.h"
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkColorFilter.h"
+#include "include/effects/SkLumaColorFilter.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+bool SkSVGMask::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", n, v)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", n, v)) ||
+           this->setMaskUnits(
+                SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>("maskUnits", n, v)) ||
+           this->setMaskContentUnits(
+                SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>("maskContentUnits", n, v));
+}
+
+SkRect SkSVGMask::bounds(const SkSVGRenderContext& ctx) const {
+    return ctx.resolveOBBRect(fX, fY, fWidth, fHeight, fMaskUnits);
+}
+
+void SkSVGMask::renderMask(const SkSVGRenderContext& ctx) const {
+    // https://www.w3.org/TR/SVG11/masking.html#Masking
+
+    // Propagate any inherited properties that may impact mask effect behavior (e.g.
+    // color-interpolation). We call this explicitly here because the SkSVGMask
+    // nodes do not participate in the normal onRender path, which is when property
+    // propagation currently occurs.
+    // The local context also restores the filter layer created below on scope exit.
+    SkSVGRenderContext lctx(ctx);
+    this->onPrepareToRender(&lctx);
+
+    const auto ci = *lctx.presentationContext().fInherited.fColorInterpolation;
+    auto ci_filter = (ci == SkSVGColorspace::kLinearRGB)
+            ? SkColorFilters::SRGBToLinearGamma()
+            : nullptr;
+
+    SkPaint mask_filter;
+    mask_filter.setColorFilter(
+                SkColorFilters::Compose(SkLumaColorFilter::Make(), std::move(ci_filter)));
+
+    // Mask color filter layer.
+    // Note: We could avoid this extra layer if we invert the stacking order
+    // (mask/content -> content/mask, kSrcIn -> kDstIn) and apply the filter
+    // via the top (mask) layer paint.  That requires deferring mask rendering
+    // until after node content, which introduces extra state/complexity.
+    // Something to consider if masking performance ever becomes an issue.
+    lctx.canvas()->saveLayer(nullptr, &mask_filter);
+
+    const auto obbt = ctx.transformForCurrentOBB(fMaskContentUnits);
+    lctx.canvas()->translate(obbt.offset.x, obbt.offset.y);
+    lctx.canvas()->scale(obbt.scale.x, obbt.scale.y);
+
+    for (const auto& child : fChildren) {
+        child->render(lctx);
+    }
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp
new file mode 100644
index 00000000..596b22ea
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkMatrix.h"
+#include "include/pathops/SkPathOps.h"
+#include "include/private/base/SkTPin.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/base/SkTLazy.h"
+
+SkSVGNode::SkSVGNode(SkSVGTag t) : fTag(t) {
+    // Uninherited presentation attributes need a non-null default value.
+    fPresentationAttributes.fStopColor.set(SkSVGColor(SK_ColorBLACK));
+    fPresentationAttributes.fStopOpacity.set(SkSVGNumberType(1.0f));
+    fPresentationAttributes.fFloodColor.set(SkSVGColor(SK_ColorBLACK));
+    fPresentationAttributes.fFloodOpacity.set(SkSVGNumberType(1.0f));
+    fPresentationAttributes.fLightingColor.set(SkSVGColor(SK_ColorWHITE));
+}
+
+SkSVGNode::~SkSVGNode() { }
+
+void SkSVGNode::render(const SkSVGRenderContext& ctx) const {
+    SkSVGRenderContext localContext(ctx, this);
+
+    if (this->onPrepareToRender(&localContext)) {
+        this->onRender(localContext);
+    }
+}
+
+bool SkSVGNode::asPaint(const SkSVGRenderContext& ctx, SkPaint* paint) const {
+    SkSVGRenderContext localContext(ctx);
+
+    return this->onPrepareToRender(&localContext) && this->onAsPaint(localContext, paint);
+}
+
+SkPath SkSVGNode::asPath(const SkSVGRenderContext& ctx) const {
+    SkSVGRenderContext localContext(ctx);
+    if (!this->onPrepareToRender(&localContext)) {
+        return SkPath();
+    }
+
+    SkPath path = this->onAsPath(localContext);
+
+    if (const auto* clipPath = localContext.clipPath()) {
+        // There is a clip-path present on the current node.
+        Op(path, *clipPath, kIntersect_SkPathOp, &path);
+    }
+
+    return path;
+}
+
+SkRect SkSVGNode::objectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return this->onObjectBoundingBox(ctx);
+}
+
+bool SkSVGNode::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    ctx->applyPresentationAttributes(fPresentationAttributes,
+                                     this->hasChildren() ? 0 : SkSVGRenderContext::kLeaf);
+
+    // visibility:hidden and display:none disable rendering.
+    // TODO: if display is not a value (true when display="inherit"), we currently
+    //   ignore it. Eventually we should be able to add SkASSERT(display.isValue()).
+    const auto visibility = ctx->presentationContext().fInherited.fVisibility->type();
+    const auto display = fPresentationAttributes.fDisplay;  // display is uninherited
+    return visibility != SkSVGVisibility::Type::kHidden &&
+           (!display.isValue() || *display != SkSVGDisplay::kNone);
+}
+
+void SkSVGNode::setAttribute(SkSVGAttribute attr, const SkSVGValue& v) {
+    this->onSetAttribute(attr, v);
+}
+
+template <typename T>
+void SetInheritedByDefault(SkTLazy<T>& presentation_attribute, const T& value) {
+    if (value.type() != T::Type::kInherit) {
+        presentation_attribute.set(value);
+    } else {
+        // kInherited values are semantically equivalent to
+        // the absence of a local presentation attribute.
+        presentation_attribute.reset();
+    }
+}
+
+bool SkSVGNode::parseAndSetAttribute(const char* n, const char* v) {
+#define PARSE_AND_SET(svgName, attrName)                                                        \
+    this->set##attrName(                                                                        \
+            SkSVGAttributeParser::parseProperty<decltype(fPresentationAttributes.f##attrName)>( \
+                    svgName, n, v))
+
+    return PARSE_AND_SET(   "clip-path"                  , ClipPath)
+           || PARSE_AND_SET("clip-rule"                  , ClipRule)
+           || PARSE_AND_SET("color"                      , Color)
+           || PARSE_AND_SET("color-interpolation"        , ColorInterpolation)
+           || PARSE_AND_SET("color-interpolation-filters", ColorInterpolationFilters)
+           || PARSE_AND_SET("display"                    , Display)
+           || PARSE_AND_SET("fill"                       , Fill)
+           || PARSE_AND_SET("fill-opacity"               , FillOpacity)
+           || PARSE_AND_SET("fill-rule"                  , FillRule)
+           || PARSE_AND_SET("filter"                     , Filter)
+           || PARSE_AND_SET("flood-color"                , FloodColor)
+           || PARSE_AND_SET("flood-opacity"              , FloodOpacity)
+           || PARSE_AND_SET("font-family"                , FontFamily)
+           || PARSE_AND_SET("font-size"                  , FontSize)
+           || PARSE_AND_SET("font-style"                 , FontStyle)
+           || PARSE_AND_SET("font-weight"                , FontWeight)
+           || PARSE_AND_SET("lighting-color"             , LightingColor)
+           || PARSE_AND_SET("mask"                       , Mask)
+           || PARSE_AND_SET("opacity"                    , Opacity)
+           || PARSE_AND_SET("stop-color"                 , StopColor)
+           || PARSE_AND_SET("stop-opacity"               , StopOpacity)
+           || PARSE_AND_SET("stroke"                     , Stroke)
+           || PARSE_AND_SET("stroke-dasharray"           , StrokeDashArray)
+           || PARSE_AND_SET("stroke-dashoffset"          , StrokeDashOffset)
+           || PARSE_AND_SET("stroke-linecap"             , StrokeLineCap)
+           || PARSE_AND_SET("stroke-linejoin"            , StrokeLineJoin)
+           || PARSE_AND_SET("stroke-miterlimit"          , StrokeMiterLimit)
+           || PARSE_AND_SET("stroke-opacity"             , StrokeOpacity)
+           || PARSE_AND_SET("stroke-width"               , StrokeWidth)
+           || PARSE_AND_SET("text-anchor"                , TextAnchor)
+           || PARSE_AND_SET("visibility"                 , Visibility);
+
+#undef PARSE_AND_SET
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#PreserveAspectRatioAttribute
+SkMatrix SkSVGNode::ComputeViewboxMatrix(const SkRect& viewBox,
+                                         const SkRect& viewPort,
+                                         SkSVGPreserveAspectRatio par) {
+    if (viewBox.isEmpty() || viewPort.isEmpty()) {
+        return SkMatrix::Scale(0, 0);
+    }
+
+    auto compute_scale = [&]() -> SkV2 {
+        const auto sx = viewPort.width()  / viewBox.width(),
+                   sy = viewPort.height() / viewBox.height();
+
+        if (par.fAlign == SkSVGPreserveAspectRatio::kNone) {
+            // none -> anisotropic scaling, regardless of fScale
+            return {sx, sy};
+        }
+
+        // isotropic scaling
+        const auto s = par.fScale == SkSVGPreserveAspectRatio::kMeet
+                            ? std::min(sx, sy)
+                            : std::max(sx, sy);
+        return {s, s};
+    };
+
+    auto compute_trans = [&](const SkV2& scale) -> SkV2 {
+        static constexpr float gAlignCoeffs[] = {
+                0.0f, // Min
+                0.5f, // Mid
+                1.0f  // Max
+        };
+
+        const size_t x_coeff = par.fAlign >> 0 & 0x03,
+                     y_coeff = par.fAlign >> 2 & 0x03;
+
+        SkASSERT(x_coeff < std::size(gAlignCoeffs) &&
+                 y_coeff < std::size(gAlignCoeffs));
+
+        const auto tx = -viewBox.x() * scale.x,
+                   ty = -viewBox.y() * scale.y,
+                   dx = viewPort.width()  - viewBox.width() * scale.x,
+                   dy = viewPort.height() - viewBox.height() * scale.y;
+
+        return {
+            tx + dx * gAlignCoeffs[x_coeff],
+            ty + dy * gAlignCoeffs[y_coeff]
+        };
+    };
+
+    const auto s = compute_scale(),
+               t = compute_trans(s);
+
+    return SkMatrix::Translate(t.x, t.y) *
+           SkMatrix::Scale(s.x, s.y);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp
new file mode 100644
index 00000000..69ad97d3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2022 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/codec/SkCodec.h"
+#include "include/codec/SkJpegDecoder.h"
+#include "include/codec/SkPngDecoder.h"
+#include "include/core/SkColor.h"
+#include "include/core/SkOpenTypeSVGDecoder.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkTypes.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/svg/include/SkSVGDOM.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGOpenTypeSVGDecoder.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGSVG.h"
+#include "modules/svg/include/SkSVGUse.h"
+#include "src/base/SkBase64.h"
+#include "src/core/SkEnumerate.h"
+
+#include <memory>
+
+using namespace skia_private;
+
+namespace {
+class DataResourceProvider final : public skresources::ResourceProvider {
+public:
+    static sk_sp<skresources::ResourceProvider> Make() {
+        return sk_sp<skresources::ResourceProvider>(new DataResourceProvider());
+    }
+
+    sk_sp<skresources::ImageAsset> loadImageAsset(const char rpath[],
+                                                  const char rname[],
+                                                  const char rid[]) const override {
+        if (auto data = decode_datauri("data:image/", rname)) {
+            std::unique_ptr<SkCodec> codec = nullptr;
+            if (SkPngDecoder::IsPng(data->bytes(), data->size())) {
+                codec = SkPngDecoder::Decode(data, nullptr);
+            } else if (SkJpegDecoder::IsJpeg(data->bytes(), data->size())) {
+                codec = SkJpegDecoder::Decode(data, nullptr);
+            } else {
+                // The spec says only JPEG or PNG should be used to encode the embedded data.
+                // https://learn.microsoft.com/en-us/typography/opentype/spec/svg#svg-capability-requirements-and-restrictions
+                SkDEBUGFAIL("Unsupported codec");
+                return nullptr;
+            }
+            if (!codec) {
+                return nullptr;
+            }
+            return skresources::MultiFrameImageAsset::Make(std::move(codec));
+        }
+        return nullptr;
+    }
+
+private:
+    DataResourceProvider() = default;
+
+    static sk_sp<SkData> decode_datauri(const char prefix[], const char uri[]) {
+        // We only handle B64 encoded image dataURIs: data:image/<type>;base64,<data>
+        // (https://en.wikipedia.org/wiki/Data_URI_scheme)
+        static constexpr char kDataURIEncodingStr[] = ";base64,";
+
+        const size_t prefixLen = strlen(prefix);
+        if (strncmp(uri, prefix, prefixLen) != 0) {
+            return nullptr;
+        }
+
+        const char* encoding = strstr(uri + prefixLen, kDataURIEncodingStr);
+        if (!encoding) {
+            return nullptr;
+        }
+
+        const char* b64Data = encoding + std::size(kDataURIEncodingStr) - 1;
+        size_t b64DataLen = strlen(b64Data);
+        size_t dataLen;
+        if (SkBase64::Decode(b64Data, b64DataLen, nullptr, &dataLen) != SkBase64::kNoError) {
+            return nullptr;
+        }
+
+        sk_sp<SkData> data = SkData::MakeUninitialized(dataLen);
+        void* rawData = data->writable_data();
+        if (SkBase64::Decode(b64Data, b64DataLen, rawData, &dataLen) != SkBase64::kNoError) {
+            return nullptr;
+        }
+
+        return data;
+    }
+
+    using INHERITED = ResourceProvider;
+};
+}  // namespace
+
+SkSVGOpenTypeSVGDecoder::SkSVGOpenTypeSVGDecoder(sk_sp<SkSVGDOM> skSvg, size_t approximateSize)
+    : fSkSvg(std::move(skSvg))
+    , fApproximateSize(approximateSize)
+{}
+
+SkSVGOpenTypeSVGDecoder::~SkSVGOpenTypeSVGDecoder() = default;
+
+std::unique_ptr<SkOpenTypeSVGDecoder> SkSVGOpenTypeSVGDecoder::Make(const uint8_t* svg,
+                                                                    size_t svgLength) {
+    std::unique_ptr<SkStreamAsset> stream = SkMemoryStream::MakeDirect(svg, svgLength);
+    if (!stream) {
+        return nullptr;
+    }
+    SkSVGDOM::Builder builder;
+    builder.setResourceProvider(DataResourceProvider::Make());
+    // We shouldn't need to set this builder's font manager or shaping utils because hopefully
+    // the SVG we are decoding doesn't itself have <text> tags.
+    sk_sp<SkSVGDOM> skSvg = builder.make(*stream);
+    if (!skSvg) {
+        return nullptr;
+    }
+    return std::unique_ptr<SkOpenTypeSVGDecoder>(
+        new SkSVGOpenTypeSVGDecoder(std::move(skSvg), svgLength));
+}
+
+size_t SkSVGOpenTypeSVGDecoder::approximateSize() {
+    // TODO
+    return fApproximateSize;
+}
+
+bool SkSVGOpenTypeSVGDecoder::render(SkCanvas& canvas, int upem, SkGlyphID glyphId,
+                                     SkColor foregroundColor, SkSpan<SkColor> palette) {
+    SkSize emSize = SkSize::Make(SkScalar(upem), SkScalar(upem));
+    fSkSvg->setContainerSize(emSize);
+
+    SkSVGPresentationContext pctx;
+    pctx.fInherited.fColor.set(foregroundColor);
+
+    THashMap<SkString, SkSVGColorType> namedColors;
+    if (!palette.empty()) {
+        for (auto&& [i, color] : SkMakeEnumerate(palette)) {
+            constexpr const size_t colorStringLen = sizeof("color") - 1;
+            char colorIdString[colorStringLen + kSkStrAppendU32_MaxSize + 1] = "color";
+            *SkStrAppendU32(colorIdString + colorStringLen, i) = 0;
+
+            namedColors.set(SkString(colorIdString), color);
+        }
+        pctx.fNamedColors = &namedColors;
+    }
+
+    constexpr const size_t glyphStringLen = sizeof("glyph") - 1;
+    char glyphIdString[glyphStringLen + kSkStrAppendU32_MaxSize + 1] = "glyph";
+    *SkStrAppendU32(glyphIdString + glyphStringLen, glyphId) = 0;
+
+    fSkSvg->renderNode(&canvas, pctx, glyphIdString);
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp
new file mode 100644
index 00000000..a250ceaf
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkPaint.h"
+#include "include/utils/SkParsePath.h"
+#include "modules/svg/include/SkSVGPath.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGPath::SkSVGPath() : INHERITED(SkSVGTag::kPath) { }
+
+bool SkSVGPath::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setPath(SkSVGAttributeParser::parse<SkPath>("d", n, v));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkPath>(SkPath* path) {
+    return SkParsePath::FromSVGString(fCurPos, path);
+}
+
+void SkSVGPath::onDraw(SkCanvas* canvas, const SkSVGLengthContext&, const SkPaint& paint,
+                       SkPathFillType fillType) const {
+    // the passed fillType follows inheritance rules and needs to be applied at draw time.
+    SkPath path = fPath;  // Note: point and verb data are CoW
+    path.setFillType(fillType);
+    canvas->drawPath(path, paint);
+}
+
+SkPath SkSVGPath::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = fPath;
+    // clip-rule can be inherited and needs to be applied at clip time.
+    path.setFillType(ctx.presentationContext().fInherited.fClipRule->asFillType());
+    this->mapToParent(&path);
+    return path;
+}
+
+SkRect SkSVGPath::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return fPath.computeTightBounds();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp
new file mode 100644
index 00000000..d2fc2685
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGPattern.h"
+
+#include "include/core/SkPicture.h"
+#include "include/core/SkPictureRecorder.h"
+#include "include/core/SkShader.h"
+#include "include/core/SkTileMode.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGPattern::SkSVGPattern() : INHERITED(SkSVGTag::kPattern) {}
+
+bool SkSVGPattern::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", name, value)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", name, value)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", name, value)) ||
+           this->setPatternTransform(SkSVGAttributeParser::parse<SkSVGTransformType>(
+                   "patternTransform", name, value)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", name, value));
+}
+
+const SkSVGPattern* SkSVGPattern::hrefTarget(const SkSVGRenderContext& ctx) const {
+    if (fHref.iri().isEmpty()) {
+        return nullptr;
+    }
+
+    const auto href = ctx.findNodeById(fHref);
+    if (!href || href->tag() != SkSVGTag::kPattern) {
+        return nullptr;
+    }
+
+    return static_cast<const SkSVGPattern*>(href.get());
+}
+
+template <typename T>
+int inherit_if_needed(const SkTLazy<T>& src, SkTLazy<T>& dst) {
+    if (!dst.isValid()) {
+        dst = src;
+        return 1;
+    }
+
+    return 0;
+}
+
+/* https://www.w3.org/TR/SVG11/pservers.html#PatternElementHrefAttribute
+ *
+ * Any attributes which are defined on the referenced element which are not defined on this element
+ * are inherited by this element. If this element has no children, and the referenced element does
+ * (possibly due to its own ‘xlink:href’ attribute), then this element inherits the children from
+ * the referenced element. Inheritance can be indirect to an arbitrary level; thus, if the
+ * referenced element inherits attributes or children due to its own ‘xlink:href’ attribute, then
+ * the current element can inherit those attributes or children.
+ */
+const SkSVGPattern* SkSVGPattern::resolveHref(const SkSVGRenderContext& ctx,
+                                              PatternAttributes* attrs) const {
+    const SkSVGPattern *currentNode = this,
+                       *contentNode = this;
+    do {
+        // Bitwise OR to avoid short-circuiting.
+        const bool didInherit =
+            inherit_if_needed(currentNode->fX               , attrs->fX)      |
+            inherit_if_needed(currentNode->fY               , attrs->fY)      |
+            inherit_if_needed(currentNode->fWidth           , attrs->fWidth)  |
+            inherit_if_needed(currentNode->fHeight          , attrs->fHeight) |
+            inherit_if_needed(currentNode->fPatternTransform, attrs->fPatternTransform);
+
+        if (!contentNode->hasChildren()) {
+            contentNode = currentNode;
+        }
+
+        if (contentNode->hasChildren() && !didInherit) {
+            // All attributes have been resolved, and a valid content node has been found.
+            // We can terminate the href chain early.
+            break;
+        }
+
+        // TODO: reference loop mitigation.
+        currentNode = currentNode->hrefTarget(ctx);
+    } while (currentNode);
+
+    return contentNode;
+}
+
+bool SkSVGPattern::onAsPaint(const SkSVGRenderContext& ctx, SkPaint* paint) const {
+    PatternAttributes attrs;
+    const auto* contentNode = this->resolveHref(ctx, &attrs);
+
+    const auto tile = ctx.lengthContext().resolveRect(
+            attrs.fX.isValid()      ? *attrs.fX      : SkSVGLength(0),
+            attrs.fY.isValid()      ? *attrs.fY      : SkSVGLength(0),
+            attrs.fWidth.isValid()  ? *attrs.fWidth  : SkSVGLength(0),
+            attrs.fHeight.isValid() ? *attrs.fHeight : SkSVGLength(0));
+
+    if (tile.isEmpty()) {
+        return false;
+    }
+
+    const SkMatrix* patternTransform = attrs.fPatternTransform.isValid()
+            ? attrs.fPatternTransform.get()
+            : nullptr;
+
+    SkPictureRecorder recorder;
+    SkSVGRenderContext recordingContext(ctx, recorder.beginRecording(tile));
+
+    // Cannot call into INHERITED:: because SkSVGHiddenContainer skips rendering.
+    contentNode->SkSVGContainer::onRender(recordingContext);
+
+    paint->setShader(recorder.finishRecordingAsPicture()->makeShader(
+                                                 SkTileMode::kRepeat,
+                                                 SkTileMode::kRepeat,
+                                                 SkFilterMode::kLinear,
+                                                 patternTransform,
+                                                 &tile));
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp
new file mode 100644
index 00000000..0d63339a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGPoly.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/base/SkTLazy.h"
+
+SkSVGPoly::SkSVGPoly(SkSVGTag t) : INHERITED(t) {}
+
+bool SkSVGPoly::parseAndSetAttribute(const char* n, const char* v) {
+    if (INHERITED::parseAndSetAttribute(n, v)) {
+        return true;
+    }
+
+    if (this->setPoints(SkSVGAttributeParser::parse<SkSVGPointsType>("points", n, v))) {
+        // TODO: we can likely just keep the points array and create the SkPath when needed.
+        fPath = SkPath::Polygon(
+                fPoints.data(), fPoints.size(),
+                this->tag() == SkSVGTag::kPolygon);  // only polygons are auto-closed
+    }
+
+    // No other attributes on this node
+    return false;
+}
+
+void SkSVGPoly::onDraw(SkCanvas* canvas, const SkSVGLengthContext&, const SkPaint& paint,
+                       SkPathFillType fillType) const {
+    // the passed fillType follows inheritance rules and needs to be applied at draw time.
+    fPath.setFillType(fillType);
+    canvas->drawPath(fPath, paint);
+}
+
+SkPath SkSVGPoly::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = fPath;
+
+    // clip-rule can be inherited and needs to be applied at clip time.
+    path.setFillType(ctx.presentationContext().fInherited.fClipRule->asFillType());
+
+    this->mapToParent(&path);
+    return path;
+}
+
+SkRect SkSVGPoly::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return fPath.getBounds();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp
new file mode 100644
index 00000000..9a341176
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorSpace.h"
+#include "include/effects/SkGradientShader.h"
+#include "modules/svg/include/SkSVGRadialGradient.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGRadialGradient::SkSVGRadialGradient() : INHERITED(SkSVGTag::kRadialGradient) {}
+
+bool SkSVGRadialGradient::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setCx(SkSVGAttributeParser::parse<SkSVGLength>("cx", name, value)) ||
+           this->setCy(SkSVGAttributeParser::parse<SkSVGLength>("cy", name, value)) ||
+           this->setR(SkSVGAttributeParser::parse<SkSVGLength>("r", name, value)) ||
+           this->setFx(SkSVGAttributeParser::parse<SkSVGLength>("fx", name, value)) ||
+           this->setFy(SkSVGAttributeParser::parse<SkSVGLength>("fy", name, value));
+}
+
+sk_sp<SkShader> SkSVGRadialGradient::onMakeShader(const SkSVGRenderContext& ctx,
+                                                  const SkColor4f* colors, const SkScalar* pos,
+                                                  int count, SkTileMode tm,
+                                                  const SkMatrix& m) const {
+    const SkSVGLengthContext lctx =
+            this->getGradientUnits().type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox
+                    ? SkSVGLengthContext({1, 1})
+                    : ctx.lengthContext();
+
+    const auto      r = lctx.resolve(fR , SkSVGLengthContext::LengthType::kOther);
+    const auto center = SkPoint::Make(
+            lctx.resolve(fCx, SkSVGLengthContext::LengthType::kHorizontal),
+            lctx.resolve(fCy, SkSVGLengthContext::LengthType::kVertical));
+    const auto  focal = SkPoint::Make(
+        fFx.isValid() ? lctx.resolve(*fFx, SkSVGLengthContext::LengthType::kHorizontal)
+                      : center.x(),
+        fFy.isValid() ? lctx.resolve(*fFy, SkSVGLengthContext::LengthType::kVertical)
+                      : center.y());
+
+    if (r == 0) {
+        const auto last_color = count > 0 ? colors[count - 1] : SkColors::kBlack;
+        return SkShaders::Color(last_color, nullptr);
+    }
+
+    return center == focal
+        ? SkGradientShader::MakeRadial(center, r, colors, nullptr, pos, count, tm, 0, &m)
+        : SkGradientShader::MakeTwoPointConical(focal, 0, center, r, colors, nullptr, pos,
+                                                count, tm, 0, &m);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp
new file mode 100644
index 00000000..46f3d9c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <tuple>
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkRRect.h"
+#include "include/core/SkRect.h"
+#include "modules/svg/include/SkSVGRect.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/src/SkSVGRectPriv.h"
+
+std::tuple<float, float> ResolveOptionalRadii(const SkTLazy<SkSVGLength>& opt_rx,
+                                              const SkTLazy<SkSVGLength>& opt_ry,
+                                              const SkSVGLengthContext& lctx) {
+    // https://www.w3.org/TR/SVG2/shapes.html#RectElement
+    //
+    // The used values for rx and ry are determined from the computed values by following these
+    // steps in order:
+    //
+    // 1. If both rx and ry have a computed value of auto (since auto is the initial value for both
+    //    properties, this will also occur if neither are specified by the author or if all
+    //    author-supplied values are invalid), then the used value of both rx and ry is 0.
+    //    (This will result in square corners.)
+    // 2. Otherwise, convert specified values to absolute values as follows:
+    //     1. If rx is set to a length value or a percentage, but ry is auto, calculate an absolute
+    //        length equivalent for rx, resolving percentages against the used width of the
+    //        rectangle; the absolute value for ry is the same.
+    //     2. If ry is set to a length value or a percentage, but rx is auto, calculate the absolute
+    //        length equivalent for ry, resolving percentages against the used height of the
+    //        rectangle; the absolute value for rx is the same.
+    //     3. If both rx and ry were set to lengths or percentages, absolute values are generated
+    //        individually, resolving rx percentages against the used width, and resolving ry
+    //        percentages against the used height.
+    const float rx = opt_rx.isValid()
+        ? lctx.resolve(*opt_rx, SkSVGLengthContext::LengthType::kHorizontal)
+        : 0;
+    const float ry = opt_ry.isValid()
+        ? lctx.resolve(*opt_ry, SkSVGLengthContext::LengthType::kVertical)
+        : 0;
+
+    return std::make_tuple(opt_rx.isValid() ? rx : ry,
+                           opt_ry.isValid() ? ry : rx);
+}
+
+SkSVGRect::SkSVGRect() : INHERITED(SkSVGTag::kRect) {}
+
+bool SkSVGRect::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", n, v)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", n, v)) ||
+           this->setRx(SkSVGAttributeParser::parse<SkSVGLength>("rx", n, v)) ||
+           this->setRy(SkSVGAttributeParser::parse<SkSVGLength>("ry", n, v));
+}
+
+SkRRect SkSVGRect::resolve(const SkSVGLengthContext& lctx) const {
+    const auto rect = lctx.resolveRect(fX, fY, fWidth, fHeight);
+    const auto [ rx, ry ] = ResolveOptionalRadii(fRx, fRy, lctx);
+
+    // https://www.w3.org/TR/SVG2/shapes.html#RectElement
+    // ...
+    // 3. Finally, apply clamping to generate the used values:
+    //     1. If the absolute rx (after the above steps) is greater than half of the used width,
+    //        then the used value of rx is half of the used width.
+    //     2. If the absolute ry (after the above steps) is greater than half of the used height,
+    //        then the used value of ry is half of the used height.
+    //     3. Otherwise, the used values of rx and ry are the absolute values computed previously.
+
+    return SkRRect::MakeRectXY(rect,
+                               std::min(rx, rect.width() / 2),
+                               std::min(ry, rect.height() / 2));
+}
+
+void SkSVGRect::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                       const SkPaint& paint, SkPathFillType) const {
+    canvas->drawRRect(this->resolve(lctx), paint);
+}
+
+SkPath SkSVGRect::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = SkPath::RRect(this->resolve(ctx.lengthContext()));
+
+    this->mapToParent(&path);
+
+    return path;
+}
+
+SkRect SkSVGRect::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return ctx.lengthContext().resolveRect(fX, fY, fWidth, fHeight);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h b/Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h
new file mode 100644
index 00000000..93263117
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRectPriv_DEFINED
+#define SkSVGRectPriv_DEFINED
+
+#include <tuple>
+
+#include "src/base/SkTLazy.h"
+
+class SkSVGLength;
+class SkSVGLengthContext;
+
+std::tuple<float, float> ResolveOptionalRadii(const SkTLazy<SkSVGLength>& rx,
+                                              const SkTLazy<SkSVGLength>& ry,
+                                              const SkSVGLengthContext&);
+
+#endif // SkSVGRectPriv_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp
new file mode 100644
index 00000000..be6d89c5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp
@@ -0,0 +1,519 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkImageFilter.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkPathEffect.h"
+#include "include/effects/SkDashPathEffect.h"
+#include "include/private/base/SkTo.h"
+#include "modules/svg/include/SkSVGAttribute.h"
+#include "modules/svg/include/SkSVGClipPath.h"
+#include "modules/svg/include/SkSVGFilter.h"
+#include "modules/svg/include/SkSVGMask.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+using namespace skia_private;
+
+namespace {
+
+SkScalar length_size_for_type(const SkSize& viewport, SkSVGLengthContext::LengthType t) {
+    switch (t) {
+    case SkSVGLengthContext::LengthType::kHorizontal:
+        return viewport.width();
+    case SkSVGLengthContext::LengthType::kVertical:
+        return viewport.height();
+    case SkSVGLengthContext::LengthType::kOther: {
+        // https://www.w3.org/TR/SVG11/coords.html#Units_viewport_percentage
+        constexpr SkScalar rsqrt2 = 1.0f / SK_ScalarSqrt2;
+        const SkScalar w = viewport.width(), h = viewport.height();
+        return rsqrt2 * SkScalarSqrt(w * w + h * h);
+    }
+    }
+
+    SkASSERT(false);  // Not reached.
+    return 0;
+}
+
+// Multipliers for DPI-relative units.
+constexpr SkScalar kINMultiplier = 1.00f;
+constexpr SkScalar kPTMultiplier = kINMultiplier / 72.272f;
+constexpr SkScalar kPCMultiplier = kPTMultiplier * 12;
+constexpr SkScalar kMMMultiplier = kINMultiplier / 25.4f;
+constexpr SkScalar kCMMultiplier = kMMMultiplier * 10;
+
+}  // namespace
+
+SkScalar SkSVGLengthContext::resolve(const SkSVGLength& l, LengthType t) const {
+    switch (l.unit()) {
+    case SkSVGLength::Unit::kNumber:
+        // Fall through.
+    case SkSVGLength::Unit::kPX:
+        return l.value();
+    case SkSVGLength::Unit::kPercentage:
+        return l.value() * length_size_for_type(fViewport, t) / 100;
+    case SkSVGLength::Unit::kCM:
+        return l.value() * fDPI * kCMMultiplier;
+    case SkSVGLength::Unit::kMM:
+        return l.value() * fDPI * kMMMultiplier;
+    case SkSVGLength::Unit::kIN:
+        return l.value() * fDPI * kINMultiplier;
+    case SkSVGLength::Unit::kPT:
+        return l.value() * fDPI * kPTMultiplier;
+    case SkSVGLength::Unit::kPC:
+        return l.value() * fDPI * kPCMultiplier;
+    default:
+        SkDebugf("unsupported unit type: <%d>\n", (int)l.unit());
+        return 0;
+    }
+}
+
+SkRect SkSVGLengthContext::resolveRect(const SkSVGLength& x, const SkSVGLength& y,
+                                       const SkSVGLength& w, const SkSVGLength& h) const {
+    return SkRect::MakeXYWH(
+        this->resolve(x, SkSVGLengthContext::LengthType::kHorizontal),
+        this->resolve(y, SkSVGLengthContext::LengthType::kVertical),
+        this->resolve(w, SkSVGLengthContext::LengthType::kHorizontal),
+        this->resolve(h, SkSVGLengthContext::LengthType::kVertical));
+}
+
+namespace {
+
+SkPaint::Cap toSkCap(const SkSVGLineCap& cap) {
+    switch (cap) {
+    case SkSVGLineCap::kButt:
+        return SkPaint::kButt_Cap;
+    case SkSVGLineCap::kRound:
+        return SkPaint::kRound_Cap;
+    case SkSVGLineCap::kSquare:
+        return SkPaint::kSquare_Cap;
+    }
+    SkUNREACHABLE;
+}
+
+SkPaint::Join toSkJoin(const SkSVGLineJoin& join) {
+    switch (join.type()) {
+    case SkSVGLineJoin::Type::kMiter:
+        return SkPaint::kMiter_Join;
+    case SkSVGLineJoin::Type::kRound:
+        return SkPaint::kRound_Join;
+    case SkSVGLineJoin::Type::kBevel:
+        return SkPaint::kBevel_Join;
+    default:
+        SkASSERT(false);
+        return SkPaint::kMiter_Join;
+    }
+}
+
+static sk_sp<SkPathEffect> dash_effect(const SkSVGPresentationAttributes& props,
+                                       const SkSVGLengthContext& lctx) {
+    if (props.fStrokeDashArray->type() != SkSVGDashArray::Type::kDashArray) {
+        return nullptr;
+    }
+
+    const auto& da = *props.fStrokeDashArray;
+    const auto count = da.dashArray().size();
+    STArray<128, SkScalar, true> intervals(count);
+    for (const auto& dash : da.dashArray()) {
+        intervals.push_back(lctx.resolve(dash, SkSVGLengthContext::LengthType::kOther));
+    }
+
+    if (count & 1) {
+        // If an odd number of values is provided, then the list of values
+        // is repeated to yield an even number of values.
+        intervals.push_back_n(count);
+        memcpy(intervals.begin() + count, intervals.begin(), count * sizeof(SkScalar));
+    }
+
+    SkASSERT((intervals.size() & 1) == 0);
+
+    const auto phase = lctx.resolve(*props.fStrokeDashOffset,
+                                    SkSVGLengthContext::LengthType::kOther);
+
+    return SkDashPathEffect::Make(intervals.begin(), intervals.size(), phase);
+}
+
+}  // namespace
+
+SkSVGPresentationContext::SkSVGPresentationContext()
+    : fInherited(SkSVGPresentationAttributes::MakeInitial())
+{}
+
+SkSVGRenderContext::SkSVGRenderContext(SkCanvas* canvas,
+                                       const sk_sp<SkFontMgr>& fmgr,
+                                       const sk_sp<skresources::ResourceProvider>& rp,
+                                       const SkSVGIDMapper& mapper,
+                                       const SkSVGLengthContext& lctx,
+                                       const SkSVGPresentationContext& pctx,
+                                       const OBBScope& obbs,
+                                       const sk_sp<SkShapers::Factory>& fact)
+        : fFontMgr(fmgr)
+        , fTextShapingFactory(fact)
+        , fResourceProvider(rp)
+        , fIDMapper(mapper)
+        , fLengthContext(lctx)
+        , fPresentationContext(pctx)
+        , fCanvas(canvas)
+        , fCanvasSaveCount(canvas->getSaveCount())
+        , fOBBScope(obbs) {}
+
+SkSVGRenderContext::SkSVGRenderContext(const SkSVGRenderContext& other)
+        : SkSVGRenderContext(other.fCanvas,
+                             other.fFontMgr,
+                             other.fResourceProvider,
+                             other.fIDMapper,
+                             *other.fLengthContext,
+                             *other.fPresentationContext,
+                             other.fOBBScope,
+                             other.fTextShapingFactory) {}
+
+SkSVGRenderContext::SkSVGRenderContext(const SkSVGRenderContext& other, SkCanvas* canvas)
+        : SkSVGRenderContext(canvas,
+                             other.fFontMgr,
+                             other.fResourceProvider,
+                             other.fIDMapper,
+                             *other.fLengthContext,
+                             *other.fPresentationContext,
+                             other.fOBBScope,
+                             other.fTextShapingFactory) {}
+
+SkSVGRenderContext::SkSVGRenderContext(const SkSVGRenderContext& other, const SkSVGNode* node)
+        : SkSVGRenderContext(other.fCanvas,
+                             other.fFontMgr,
+                             other.fResourceProvider,
+                             other.fIDMapper,
+                             *other.fLengthContext,
+                             *other.fPresentationContext,
+                             OBBScope{node, this},
+                             other.fTextShapingFactory) {}
+
+SkSVGRenderContext::~SkSVGRenderContext() {
+    fCanvas->restoreToCount(fCanvasSaveCount);
+}
+
+SkSVGRenderContext::BorrowedNode SkSVGRenderContext::findNodeById(const SkSVGIRI& iri) const {
+    if (iri.type() != SkSVGIRI::Type::kLocal) {
+        SkDebugf("non-local iri references not currently supported");
+        return BorrowedNode(nullptr);
+    }
+    return BorrowedNode(fIDMapper.find(iri.iri()));
+}
+
+void SkSVGRenderContext::applyPresentationAttributes(const SkSVGPresentationAttributes& attrs,
+                                                     uint32_t flags) {
+
+#define ApplyLazyInheritedAttribute(ATTR)                                               \
+    do {                                                                                \
+        /* All attributes should be defined on the inherited context. */                \
+        SkASSERT(fPresentationContext->fInherited.f ## ATTR.isValue());                 \
+        const auto& attr = attrs.f ## ATTR;                                             \
+        if (attr.isValue() && *attr != *fPresentationContext->fInherited.f ## ATTR) {   \
+            /* Update the local attribute value */                                      \
+            fPresentationContext.writable()->fInherited.f ## ATTR.set(*attr);           \
+        }                                                                               \
+    } while (false)
+
+    ApplyLazyInheritedAttribute(Fill);
+    ApplyLazyInheritedAttribute(FillOpacity);
+    ApplyLazyInheritedAttribute(FillRule);
+    ApplyLazyInheritedAttribute(FontFamily);
+    ApplyLazyInheritedAttribute(FontSize);
+    ApplyLazyInheritedAttribute(FontStyle);
+    ApplyLazyInheritedAttribute(FontWeight);
+    ApplyLazyInheritedAttribute(ClipRule);
+    ApplyLazyInheritedAttribute(Stroke);
+    ApplyLazyInheritedAttribute(StrokeDashOffset);
+    ApplyLazyInheritedAttribute(StrokeDashArray);
+    ApplyLazyInheritedAttribute(StrokeLineCap);
+    ApplyLazyInheritedAttribute(StrokeLineJoin);
+    ApplyLazyInheritedAttribute(StrokeMiterLimit);
+    ApplyLazyInheritedAttribute(StrokeOpacity);
+    ApplyLazyInheritedAttribute(StrokeWidth);
+    ApplyLazyInheritedAttribute(TextAnchor);
+    ApplyLazyInheritedAttribute(Visibility);
+    ApplyLazyInheritedAttribute(Color);
+    ApplyLazyInheritedAttribute(ColorInterpolation);
+    ApplyLazyInheritedAttribute(ColorInterpolationFilters);
+
+#undef ApplyLazyInheritedAttribute
+
+    // Uninherited attributes.  Only apply to the current context.
+
+    const bool hasFilter = attrs.fFilter.isValue();
+    if (attrs.fOpacity.isValue()) {
+        this->applyOpacity(*attrs.fOpacity, flags, hasFilter);
+    }
+
+    if (attrs.fClipPath.isValue()) {
+        this->applyClip(*attrs.fClipPath);
+    }
+
+    if (attrs.fMask.isValue()) {
+        this->applyMask(*attrs.fMask);
+    }
+
+    // TODO: when both a filter and opacity are present, we can apply both with a single layer
+    if (hasFilter) {
+        this->applyFilter(*attrs.fFilter);
+    }
+
+    // Remaining uninherited presentation attributes are accessed as SkSVGNode fields, not via
+    // the render context.
+    // TODO: resolve these in a pre-render styling pass and assert here that they are values.
+    // - stop-color
+    // - stop-opacity
+    // - flood-color
+    // - flood-opacity
+    // - lighting-color
+}
+
+void SkSVGRenderContext::applyOpacity(SkScalar opacity, uint32_t flags, bool hasFilter) {
+    if (opacity >= 1) {
+        return;
+    }
+
+    const auto& props = fPresentationContext->fInherited;
+    const bool hasFill   = props.fFill  ->type() != SkSVGPaint::Type::kNone,
+               hasStroke = props.fStroke->type() != SkSVGPaint::Type::kNone;
+
+    // We can apply the opacity as paint alpha if it only affects one atomic draw.
+    // For now, this means all of the following must be true:
+    //   - the target node doesn't have any descendants;
+    //   - it only has a stroke or a fill (but not both);
+    //   - it does not have a filter.
+    // Going forward, we may needto refine this heuristic (e.g. to accommodate markers).
+    if ((flags & kLeaf) && (hasFill ^ hasStroke) && !hasFilter) {
+        fDeferredPaintOpacity *= opacity;
+    } else {
+        // Expensive, layer-based fall back.
+        SkPaint opacityPaint;
+        opacityPaint.setAlphaf(SkTPin(opacity, 0.0f, 1.0f));
+        // Balanced in the destructor, via restoreToCount().
+        fCanvas->saveLayer(nullptr, &opacityPaint);
+    }
+}
+
+void SkSVGRenderContext::applyFilter(const SkSVGFuncIRI& filter) {
+    if (filter.type() != SkSVGFuncIRI::Type::kIRI) {
+        return;
+    }
+
+    const auto node = this->findNodeById(filter.iri());
+    if (!node || node->tag() != SkSVGTag::kFilter) {
+        return;
+    }
+
+    const SkSVGFilter* filterNode = reinterpret_cast<const SkSVGFilter*>(node.get());
+    sk_sp<SkImageFilter> imageFilter = filterNode->buildFilterDAG(*this);
+    if (imageFilter) {
+        SkPaint filterPaint;
+        filterPaint.setImageFilter(imageFilter);
+        // Balanced in the destructor, via restoreToCount().
+        fCanvas->saveLayer(nullptr, &filterPaint);
+    }
+}
+
+void SkSVGRenderContext::saveOnce() {
+    // The canvas only needs to be saved once, per local SkSVGRenderContext.
+    if (fCanvas->getSaveCount() == fCanvasSaveCount) {
+        fCanvas->save();
+    }
+
+    SkASSERT(fCanvas->getSaveCount() > fCanvasSaveCount);
+}
+
+void SkSVGRenderContext::applyClip(const SkSVGFuncIRI& clip) {
+    if (clip.type() != SkSVGFuncIRI::Type::kIRI) {
+        return;
+    }
+
+    const auto clipNode = this->findNodeById(clip.iri());
+    if (!clipNode || clipNode->tag() != SkSVGTag::kClipPath) {
+        return;
+    }
+
+    const SkPath clipPath = static_cast<const SkSVGClipPath*>(clipNode.get())->resolveClip(*this);
+
+    // We use the computed clip path in two ways:
+    //
+    //   - apply to the current canvas, for drawing
+    //   - track in the presentation context, for asPath() composition
+    //
+    // TODO: the two uses are exclusive, avoid canvas churn when non needed.
+
+    this->saveOnce();
+
+    fCanvas->clipPath(clipPath, true);
+    fClipPath.set(clipPath);
+}
+
+void SkSVGRenderContext::applyMask(const SkSVGFuncIRI& mask) {
+    if (mask.type() != SkSVGFuncIRI::Type::kIRI) {
+        return;
+    }
+
+    const auto node = this->findNodeById(mask.iri());
+    if (!node || node->tag() != SkSVGTag::kMask) {
+        return;
+    }
+
+    const auto* mask_node = static_cast<const SkSVGMask*>(node.get());
+    const auto mask_bounds = mask_node->bounds(*this);
+
+    // Isolation/mask layer.
+    fCanvas->saveLayer(mask_bounds, nullptr);
+
+    // Render and filter mask content.
+    mask_node->renderMask(*this);
+
+    // Content layer
+    SkPaint masking_paint;
+    masking_paint.setBlendMode(SkBlendMode::kSrcIn);
+    fCanvas->saveLayer(mask_bounds, &masking_paint);
+
+    // Content is also clipped to the specified mask bounds.
+    fCanvas->clipRect(mask_bounds, true);
+
+    // At this point we're set up for content rendering.
+    // The pending layers are restored in the destructor (render context scope exit).
+    // Restoring triggers srcIn-compositing the content against the mask.
+}
+
+SkTLazy<SkPaint> SkSVGRenderContext::commonPaint(const SkSVGPaint& paint_selector,
+                                                 float paint_opacity) const {
+    if (paint_selector.type() == SkSVGPaint::Type::kNone) {
+        return SkTLazy<SkPaint>();
+    }
+
+    SkTLazy<SkPaint> p;
+    p.init();
+
+    switch (paint_selector.type()) {
+    case SkSVGPaint::Type::kColor:
+        p->setColor(this->resolveSvgColor(paint_selector.color()));
+        break;
+    case SkSVGPaint::Type::kIRI: {
+        // Our property inheritance is borked as it follows the render path and not the tree
+        // hierarchy.  To avoid gross transgressions like leaf node presentation attributes
+        // leaking into the paint server context, use a pristine presentation context when
+        // following hrefs.
+        //
+        // Preserve the OBB scope because some paints use object bounding box coords
+        // (e.g. gradient control points), which requires access to the render context
+        // and node being rendered.
+        SkSVGPresentationContext pctx;
+        pctx.fNamedColors = fPresentationContext->fNamedColors;
+        SkSVGRenderContext local_ctx(fCanvas,
+                                     fFontMgr,
+                                     fResourceProvider,
+                                     fIDMapper,
+                                     *fLengthContext,
+                                     pctx,
+                                     fOBBScope,
+                                     fTextShapingFactory);
+
+        const auto node = this->findNodeById(paint_selector.iri());
+        if (!node || !node->asPaint(local_ctx, p.get())) {
+            // Use the fallback color.
+            p->setColor(this->resolveSvgColor(paint_selector.color()));
+        }
+    } break;
+    default:
+        SkUNREACHABLE;
+    }
+
+    p->setAntiAlias(true); // TODO: shape-rendering support
+
+    // We observe 3 opacity components:
+    //   - initial paint server opacity (e.g. color stop opacity)
+    //   - paint-specific opacity (e.g. 'fill-opacity', 'stroke-opacity')
+    //   - deferred opacity override (optimization for leaf nodes 'opacity')
+    p->setAlphaf(SkTPin(p->getAlphaf() * paint_opacity * fDeferredPaintOpacity, 0.0f, 1.0f));
+
+    return p;
+}
+
+SkTLazy<SkPaint> SkSVGRenderContext::fillPaint() const {
+    const auto& props = fPresentationContext->fInherited;
+    auto p = this->commonPaint(*props.fFill, *props.fFillOpacity);
+
+    if (p.isValid()) {
+        p->setStyle(SkPaint::kFill_Style);
+    }
+
+    return p;
+}
+
+SkTLazy<SkPaint> SkSVGRenderContext::strokePaint() const {
+    const auto& props = fPresentationContext->fInherited;
+    auto p = this->commonPaint(*props.fStroke, *props.fStrokeOpacity);
+
+    if (p.isValid()) {
+        p->setStyle(SkPaint::kStroke_Style);
+        p->setStrokeWidth(fLengthContext->resolve(*props.fStrokeWidth,
+                                                  SkSVGLengthContext::LengthType::kOther));
+        p->setStrokeCap(toSkCap(*props.fStrokeLineCap));
+        p->setStrokeJoin(toSkJoin(*props.fStrokeLineJoin));
+        p->setStrokeMiter(*props.fStrokeMiterLimit);
+        p->setPathEffect(dash_effect(props, *fLengthContext));
+    }
+
+    return p;
+}
+
+SkSVGColorType SkSVGRenderContext::resolveSvgColor(const SkSVGColor& color) const {
+    if (fPresentationContext->fNamedColors) {
+        for (auto&& ident : color.vars()) {
+            SkSVGColorType* c = fPresentationContext->fNamedColors->find(ident);
+            if (c) {
+                return *c;
+            }
+        }
+    }
+    switch (color.type()) {
+        case SkSVGColor::Type::kColor:
+            return color.color();
+        case SkSVGColor::Type::kCurrentColor:
+            return *fPresentationContext->fInherited.fColor;
+        case SkSVGColor::Type::kICCColor:
+            SkDebugf("ICC color unimplemented");
+            return SK_ColorBLACK;
+    }
+    SkUNREACHABLE;
+}
+
+SkSVGRenderContext::OBBTransform
+SkSVGRenderContext::transformForCurrentOBB(SkSVGObjectBoundingBoxUnits u) const {
+    if (!fOBBScope.fNode || u.type() == SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse) {
+        return {{0,0},{1,1}};
+    }
+    SkASSERT(fOBBScope.fCtx);
+
+    const auto obb = fOBBScope.fNode->objectBoundingBox(*fOBBScope.fCtx);
+    return {{obb.x(), obb.y()}, {obb.width(), obb.height()}};
+}
+
+SkRect SkSVGRenderContext::resolveOBBRect(const SkSVGLength& x, const SkSVGLength& y,
+                                          const SkSVGLength& w, const SkSVGLength& h,
+                                          SkSVGObjectBoundingBoxUnits obbu) const {
+    SkTCopyOnFirstWrite<SkSVGLengthContext> lctx(fLengthContext);
+
+    if (obbu.type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox) {
+        *lctx.writable() = SkSVGLengthContext({1,1});
+    }
+
+    auto r = lctx->resolveRect(x, y, w, h);
+    const auto obbt = this->transformForCurrentOBB(obbu);
+
+    return SkRect::MakeXYWH(obbt.scale.x * r.x() + obbt.offset.x,
+                            obbt.scale.y * r.y() + obbt.offset.y,
+                            obbt.scale.x * r.width(),
+                            obbt.scale.y * r.height());
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp
new file mode 100644
index 00000000..389ac2a7
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGSVG.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+void SkSVGSVG::renderNode(const SkSVGRenderContext& ctx, const SkSVGIRI& iri) const {
+    SkSVGRenderContext localContext(ctx, this);
+    SkSVGRenderContext::BorrowedNode node = localContext.findNodeById(iri);
+    if (!node) {
+        return;
+    }
+
+    if (this->onPrepareToRender(&localContext)) {
+        if (this == node.get()) {
+            this->onRender(ctx);
+        } else {
+            node->render(localContext);
+        }
+    }
+}
+
+bool SkSVGSVG::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    // x/y are ignored for outermost svg elements
+    const auto x = fType == Type::kInner ? fX : SkSVGLength(0);
+    const auto y = fType == Type::kInner ? fY : SkSVGLength(0);
+
+    auto viewPortRect  = ctx->lengthContext().resolveRect(x, y, fWidth, fHeight);
+    auto contentMatrix = SkMatrix::Translate(viewPortRect.x(), viewPortRect.y());
+    auto viewPort      = SkSize::Make(viewPortRect.width(), viewPortRect.height());
+
+    if (fViewBox.isValid()) {
+        const SkRect& viewBox = *fViewBox;
+
+        // An empty viewbox disables rendering.
+        if (viewBox.isEmpty()) {
+            return false;
+        }
+
+        // A viewBox overrides the intrinsic viewport.
+        viewPort = SkSize::Make(viewBox.width(), viewBox.height());
+
+        contentMatrix.preConcat(ComputeViewboxMatrix(viewBox, viewPortRect, fPreserveAspectRatio));
+    }
+
+    if (!contentMatrix.isIdentity()) {
+        ctx->saveOnce();
+        ctx->canvas()->concat(contentMatrix);
+    }
+
+    if (viewPort != ctx->lengthContext().viewPort()) {
+        ctx->writableLengthContext()->setViewPort(viewPort);
+    }
+
+    return this->INHERITED::onPrepareToRender(ctx);
+}
+
+void SkSVGSVG::onSetAttribute(SkSVGAttribute attr, const SkSVGValue& v) {
+    switch (attr) {
+    case SkSVGAttribute::kX:
+        if (const auto* x = v.as<SkSVGLengthValue>()) {
+            this->setX(*x);
+        }
+        break;
+    case SkSVGAttribute::kY:
+        if (const auto* y = v.as<SkSVGLengthValue>()) {
+            this->setY(*y);
+        }
+        break;
+    case SkSVGAttribute::kWidth:
+        if (const auto* w = v.as<SkSVGLengthValue>()) {
+            this->setWidth(*w);
+        }
+        break;
+    case SkSVGAttribute::kHeight:
+        if (const auto* h = v.as<SkSVGLengthValue>()) {
+            this->setHeight(*h);
+        }
+        break;
+    case SkSVGAttribute::kViewBox:
+        if (const auto* vb = v.as<SkSVGViewBoxValue>()) {
+            this->setViewBox(*vb);
+        }
+        break;
+    case SkSVGAttribute::kPreserveAspectRatio:
+        if (const auto* par = v.as<SkSVGPreserveAspectRatioValue>()) {
+            this->setPreserveAspectRatio(*par);
+        }
+        break;
+    default:
+        this->INHERITED::onSetAttribute(attr, v);
+    }
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#IntrinsicSizing
+SkSize SkSVGSVG::intrinsicSize(const SkSVGLengthContext& lctx) const {
+    // Percentage values do not provide an intrinsic size.
+    if (fWidth.unit() == SkSVGLength::Unit::kPercentage ||
+        fHeight.unit() == SkSVGLength::Unit::kPercentage) {
+        return SkSize::Make(0, 0);
+    }
+
+    return SkSize::Make(lctx.resolve(fWidth, SkSVGLengthContext::LengthType::kHorizontal),
+                        lctx.resolve(fHeight, SkSVGLengthContext::LengthType::kVertical));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp
new file mode 100644
index 00000000..617d8f7d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGShape.h"
+
+SkSVGShape::SkSVGShape(SkSVGTag t) : INHERITED(t) {}
+
+void SkSVGShape::onRender(const SkSVGRenderContext& ctx) const {
+    const auto fillType = ctx.presentationContext().fInherited.fFillRule->asFillType();
+
+    const auto fillPaint = ctx.fillPaint(),
+             strokePaint = ctx.strokePaint();
+
+    // TODO: this approach forces duplicate geometry resolution in onDraw(); refactor to avoid.
+    if (fillPaint.isValid()) {
+        this->onDraw(ctx.canvas(), ctx.lengthContext(), *fillPaint, fillType);
+    }
+
+    if (strokePaint.isValid()) {
+        this->onDraw(ctx.canvas(), ctx.lengthContext(), *strokePaint, fillType);
+    }
+}
+
+void SkSVGShape::appendChild(sk_sp<SkSVGNode>) {
+    SkDebugf("cannot append child nodes to an SVG shape.\n");
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp
new file mode 100644
index 00000000..672ab253
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/private/base/SkTPin.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGStop.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGStop::SkSVGStop() : INHERITED(SkSVGTag::kStop) {}
+
+bool SkSVGStop::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setOffset(SkSVGAttributeParser::parse<SkSVGLength>("offset", n, v));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp
new file mode 100644
index 00000000..752c3e3d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp
@@ -0,0 +1,715 @@
+/*
+ * Copyright 2019 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGText.h"
+
+#include <limits>
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkContourMeasure.h"
+#include "include/core/SkFont.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkFontStyle.h"
+#include "include/core/SkPathBuilder.h"
+#include "include/core/SkRSXform.h"
+#include "include/core/SkString.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "modules/svg/src/SkSVGTextPriv.h"
+#include "src/base/SkUTF.h"
+#include "src/core/SkTextBlobPriv.h"
+
+using namespace skia_private;
+
+namespace {
+
+static SkFont ResolveFont(const SkSVGRenderContext& ctx) {
+    auto weight = [](const SkSVGFontWeight& w) {
+        switch (w.type()) {
+            case SkSVGFontWeight::Type::k100:     return SkFontStyle::kThin_Weight;
+            case SkSVGFontWeight::Type::k200:     return SkFontStyle::kExtraLight_Weight;
+            case SkSVGFontWeight::Type::k300:     return SkFontStyle::kLight_Weight;
+            case SkSVGFontWeight::Type::k400:     return SkFontStyle::kNormal_Weight;
+            case SkSVGFontWeight::Type::k500:     return SkFontStyle::kMedium_Weight;
+            case SkSVGFontWeight::Type::k600:     return SkFontStyle::kSemiBold_Weight;
+            case SkSVGFontWeight::Type::k700:     return SkFontStyle::kBold_Weight;
+            case SkSVGFontWeight::Type::k800:     return SkFontStyle::kExtraBold_Weight;
+            case SkSVGFontWeight::Type::k900:     return SkFontStyle::kBlack_Weight;
+            case SkSVGFontWeight::Type::kNormal:  return SkFontStyle::kNormal_Weight;
+            case SkSVGFontWeight::Type::kBold:    return SkFontStyle::kBold_Weight;
+            case SkSVGFontWeight::Type::kBolder:  return SkFontStyle::kExtraBold_Weight;
+            case SkSVGFontWeight::Type::kLighter: return SkFontStyle::kLight_Weight;
+            case SkSVGFontWeight::Type::kInherit: {
+                SkASSERT(false);
+                return SkFontStyle::kNormal_Weight;
+            }
+        }
+        SkUNREACHABLE;
+    };
+
+    auto slant = [](const SkSVGFontStyle& s) {
+        switch (s.type()) {
+            case SkSVGFontStyle::Type::kNormal:  return SkFontStyle::kUpright_Slant;
+            case SkSVGFontStyle::Type::kItalic:  return SkFontStyle::kItalic_Slant;
+            case SkSVGFontStyle::Type::kOblique: return SkFontStyle::kOblique_Slant;
+            case SkSVGFontStyle::Type::kInherit: {
+                SkASSERT(false);
+                return SkFontStyle::kUpright_Slant;
+            }
+        }
+        SkUNREACHABLE;
+    };
+
+    const auto& family = ctx.presentationContext().fInherited.fFontFamily->family();
+    const SkFontStyle style(weight(*ctx.presentationContext().fInherited.fFontWeight),
+                            SkFontStyle::kNormal_Width,
+                            slant(*ctx.presentationContext().fInherited.fFontStyle));
+
+    const auto size =
+            ctx.lengthContext().resolve(ctx.presentationContext().fInherited.fFontSize->size(),
+                                        SkSVGLengthContext::LengthType::kVertical);
+
+    // TODO: we likely want matchFamilyStyle here, but switching away from legacyMakeTypeface
+    // changes all the results when using the default fontmgr.
+    auto tf = ctx.fontMgr()->legacyMakeTypeface(family.c_str(), style);
+    if (!tf) {
+        tf = ctx.fontMgr()->legacyMakeTypeface(nullptr, style);
+    }
+    SkASSERT(tf);
+    SkFont font(std::move(tf), size);
+    font.setHinting(SkFontHinting::kNone);
+    font.setSubpixel(true);
+    font.setLinearMetrics(true);
+    font.setBaselineSnap(false);
+    font.setEdging(SkFont::Edging::kAntiAlias);
+
+    return font;
+}
+
+static std::vector<float> ResolveLengths(const SkSVGLengthContext& lctx,
+                                         const std::vector<SkSVGLength>& lengths,
+                                         SkSVGLengthContext::LengthType lt) {
+    std::vector<float> resolved;
+    resolved.reserve(lengths.size());
+
+    for (const auto& l : lengths) {
+        resolved.push_back(lctx.resolve(l, lt));
+    }
+
+    return resolved;
+}
+
+static float ComputeAlignmentFactor(const SkSVGPresentationContext& pctx) {
+    switch (pctx.fInherited.fTextAnchor->type()) {
+    case SkSVGTextAnchor::Type::kStart : return  0.0f;
+    case SkSVGTextAnchor::Type::kMiddle: return -0.5f;
+    case SkSVGTextAnchor::Type::kEnd   : return -1.0f;
+    case SkSVGTextAnchor::Type::kInherit:
+        SkASSERT(false);
+        return 0.0f;
+    }
+    SkUNREACHABLE;
+}
+
+} // namespace
+
+SkSVGTextContext::ScopedPosResolver::ScopedPosResolver(const SkSVGTextContainer& txt,
+                                                       const SkSVGLengthContext& lctx,
+                                                       SkSVGTextContext* tctx,
+                                                       size_t charIndexOffset)
+    : fTextContext(tctx)
+    , fParent(tctx->fPosResolver)
+    , fCharIndexOffset(charIndexOffset)
+    , fX(ResolveLengths(lctx, txt.getX(), SkSVGLengthContext::LengthType::kHorizontal))
+    , fY(ResolveLengths(lctx, txt.getY(), SkSVGLengthContext::LengthType::kVertical))
+    , fDx(ResolveLengths(lctx, txt.getDx(), SkSVGLengthContext::LengthType::kHorizontal))
+    , fDy(ResolveLengths(lctx, txt.getDy(), SkSVGLengthContext::LengthType::kVertical))
+    , fRotate(txt.getRotate())
+{
+    fTextContext->fPosResolver = this;
+}
+
+SkSVGTextContext::ScopedPosResolver::ScopedPosResolver(const SkSVGTextContainer& txt,
+                                                       const SkSVGLengthContext& lctx,
+                                                       SkSVGTextContext* tctx)
+    : ScopedPosResolver(txt, lctx, tctx, tctx->fCurrentCharIndex) {}
+
+SkSVGTextContext::ScopedPosResolver::~ScopedPosResolver() {
+    fTextContext->fPosResolver = fParent;
+}
+
+SkSVGTextContext::PosAttrs SkSVGTextContext::ScopedPosResolver::resolve(size_t charIndex) const {
+    PosAttrs attrs;
+
+    if (charIndex < fLastPosIndex) {
+        SkASSERT(charIndex >= fCharIndexOffset);
+        const auto localCharIndex = charIndex - fCharIndexOffset;
+
+        const auto hasAllLocal = localCharIndex < fX.size() &&
+                                 localCharIndex < fY.size() &&
+                                 localCharIndex < fDx.size() &&
+                                 localCharIndex < fDy.size() &&
+                                 localCharIndex < fRotate.size();
+        if (!hasAllLocal && fParent) {
+            attrs = fParent->resolve(charIndex);
+        }
+
+        if (localCharIndex < fX.size()) {
+            attrs[PosAttrs::kX] = fX[localCharIndex];
+        }
+        if (localCharIndex < fY.size()) {
+            attrs[PosAttrs::kY] = fY[localCharIndex];
+        }
+        if (localCharIndex < fDx.size()) {
+            attrs[PosAttrs::kDx] = fDx[localCharIndex];
+        }
+        if (localCharIndex < fDy.size()) {
+            attrs[PosAttrs::kDy] = fDy[localCharIndex];
+        }
+
+        // Rotation semantics are interestingly different [1]:
+        //
+        //   - values are not cumulative
+        //   - if explicit values are present at any level in the ancestor chain, those take
+        //     precedence (closest ancestor)
+        //   - last specified value applies to all remaining chars (closest ancestor)
+        //   - these rules apply at node scope (not chunk scope)
+        //
+        // This means we need to discriminate between explicit rotation (rotate value provided for
+        // current char) and implicit rotation (ancestor has some values - but not for the requested
+        // char - we use the last specified value).
+        //
+        // [1] https://www.w3.org/TR/SVG11/text.html#TSpanElementRotateAttribute
+        if (!fRotate.empty()) {
+            if (localCharIndex < fRotate.size()) {
+                // Explicit rotation value overrides anything in the ancestor chain.
+                attrs[PosAttrs::kRotate] = fRotate[localCharIndex];
+                attrs.setImplicitRotate(false);
+            } else if (!attrs.has(PosAttrs::kRotate) || attrs.isImplicitRotate()){
+                // Local implicit rotation (last specified value) overrides ancestor implicit
+                // rotation.
+                attrs[PosAttrs::kRotate] = fRotate.back();
+                attrs.setImplicitRotate(true);
+            }
+        }
+
+        if (!attrs.hasAny()) {
+            // Once we stop producing explicit position data, there is no reason to
+            // continue trying for higher indices.  We can suppress future lookups.
+            fLastPosIndex = charIndex;
+        }
+    }
+
+    return attrs;
+}
+
+void SkSVGTextContext::ShapeBuffer::append(SkUnichar ch, PositionAdjustment pos) {
+    // relative pos adjustments are cumulative
+    if (!fUtf8PosAdjust.empty()) {
+        pos.offset += fUtf8PosAdjust.back().offset;
+    }
+
+    char utf8_buf[SkUTF::kMaxBytesInUTF8Sequence];
+    const auto utf8_len = SkToInt(SkUTF::ToUTF8(ch, utf8_buf));
+    fUtf8         .push_back_n(utf8_len, utf8_buf);
+    fUtf8PosAdjust.push_back_n(utf8_len, pos);
+}
+
+void SkSVGTextContext::shapePendingBuffer(const SkSVGRenderContext& ctx, const SkFont& font) {
+    const char* utf8 = fShapeBuffer.fUtf8.data();
+    size_t utf8Bytes = fShapeBuffer.fUtf8.size();
+
+    std::unique_ptr<SkShaper::FontRunIterator> font_runs =
+            SkShaper::MakeFontMgrRunIterator(utf8, utf8Bytes, font, ctx.fontMgr());
+    if (!font_runs) {
+        return;
+    }
+    if (!fForcePrimitiveShaping) {
+        // Try to use the passed in shaping callbacks to shape, for example, using harfbuzz and ICU.
+        const uint8_t defaultLTR = 0;
+        std::unique_ptr<SkShaper::BiDiRunIterator> bidi =
+                ctx.makeBidiRunIterator(utf8, utf8Bytes, defaultLTR);
+        std::unique_ptr<SkShaper::LanguageRunIterator> language =
+                SkShaper::MakeStdLanguageRunIterator(utf8, utf8Bytes);
+        std::unique_ptr<SkShaper::ScriptRunIterator> script = ctx.makeScriptRunIterator(utf8, utf8Bytes);
+
+        if (bidi && script && language) {
+            fShaper->shape(utf8,
+                           utf8Bytes,
+                           *font_runs,
+                           *bidi,
+                           *script,
+                           *language,
+                           nullptr,
+                           0,
+                           SK_ScalarMax,
+                           this);
+            fShapeBuffer.reset();
+            return;
+        }  // If any of the callbacks fail, we'll fallback to the primitive shaping.
+    }
+
+    // bidi, script, and lang are all unused so we can construct them with empty data.
+    SkShaper::TrivialBiDiRunIterator trivial_bidi{0, 0};
+    SkShaper::TrivialScriptRunIterator trivial_script{0, 0};
+    SkShaper::TrivialLanguageRunIterator trivial_lang{nullptr, 0};
+    fShaper->shape(utf8,
+                   utf8Bytes,
+                   *font_runs,
+                   trivial_bidi,
+                   trivial_script,
+                   trivial_lang,
+                   nullptr,
+                   0,
+                   SK_ScalarMax,
+                   this);
+    fShapeBuffer.reset();
+}
+
+SkSVGTextContext::SkSVGTextContext(const SkSVGRenderContext& ctx,
+                                   const ShapedTextCallback& cb,
+                                   const SkSVGTextPath* tpath)
+        : fRenderContext(ctx)
+        , fCallback(cb)
+        , fShaper(ctx.makeShaper())
+        , fChunkAlignmentFactor(ComputeAlignmentFactor(ctx.presentationContext())) {
+    // If the shaper callback returns null, fallback to the primitive shaper and
+    // signal that we should not use the other callbacks in shapePendingBuffer
+    if (!fShaper) {
+        fShaper = SkShapers::Primitive::PrimitiveText();
+        fForcePrimitiveShaping = true;
+    }
+    if (tpath) {
+        fPathData = std::make_unique<PathData>(ctx, *tpath);
+
+        // https://www.w3.org/TR/SVG11/text.html#TextPathElementStartOffsetAttribute
+        auto resolve_offset = [this](const SkSVGLength& offset) {
+            if (offset.unit() != SkSVGLength::Unit::kPercentage) {
+                // "If a <length> other than a percentage is given, then the ‘startOffset’
+                // represents a distance along the path measured in the current user coordinate
+                // system."
+                return fRenderContext.lengthContext()
+                                     .resolve(offset, SkSVGLengthContext::LengthType::kHorizontal);
+            }
+
+            // "If a percentage is given, then the ‘startOffset’ represents a percentage distance
+            // along the entire path."
+            return offset.value() * fPathData->length() / 100;
+        };
+
+        // startOffset acts as an initial absolute position
+        fChunkPos.fX = resolve_offset(tpath->getStartOffset());
+    }
+}
+
+SkSVGTextContext::~SkSVGTextContext() {
+    this->flushChunk(fRenderContext);
+}
+
+void SkSVGTextContext::shapeFragment(const SkString& txt, const SkSVGRenderContext& ctx,
+                                     SkSVGXmlSpace xs) {
+    // https://www.w3.org/TR/SVG11/text.html#WhiteSpace
+    // https://www.w3.org/TR/2008/REC-xml-20081126/#NT-S
+    auto filterWSDefault = [this](SkUnichar ch) -> SkUnichar {
+        // Remove all newline chars.
+        if (ch == '\n') {
+            return -1;
+        }
+
+        // Convert tab chars to space.
+        if (ch == '\t') {
+            ch = ' ';
+        }
+
+        // Consolidate contiguous space chars and strip leading spaces (fPrevCharSpace
+        // starts off as true).
+        if (fPrevCharSpace && ch == ' ') {
+            return -1;
+        }
+
+        // TODO: Strip trailing WS?  Doing this across chunks would require another buffering
+        //   layer.  In general, trailing WS should have no rendering side effects. Skipping
+        //   for now.
+        return ch;
+    };
+    auto filterWSPreserve = [](SkUnichar ch) -> SkUnichar {
+        // Convert newline and tab chars to space.
+        if (ch == '\n' || ch == '\t') {
+            ch = ' ';
+        }
+        return ch;
+    };
+
+    // Stash paints for access from SkShaper callbacks.
+    fCurrentFill   = ctx.fillPaint();
+    fCurrentStroke = ctx.strokePaint();
+
+    const auto font = ResolveFont(ctx);
+    fShapeBuffer.reserve(txt.size());
+
+    const char* ch_ptr = txt.c_str();
+    const char* ch_end = ch_ptr + txt.size();
+
+    while (ch_ptr < ch_end) {
+        auto ch = SkUTF::NextUTF8(&ch_ptr, ch_end);
+        ch = (xs == SkSVGXmlSpace::kDefault)
+                ? filterWSDefault(ch)
+                : filterWSPreserve(ch);
+
+        if (ch < 0) {
+            // invalid utf or char filtered out
+            continue;
+        }
+
+        SkASSERT(fPosResolver);
+        const auto pos = fPosResolver->resolve(fCurrentCharIndex++);
+
+        // Absolute position adjustments define a new chunk.
+        // (https://www.w3.org/TR/SVG11/text.html#TextLayoutIntroduction)
+        if (pos.has(PosAttrs::kX) || pos.has(PosAttrs::kY)) {
+            this->shapePendingBuffer(ctx, font);
+            this->flushChunk(ctx);
+
+            // New chunk position.
+            if (pos.has(PosAttrs::kX)) {
+                fChunkPos.fX = pos[PosAttrs::kX];
+            }
+            if (pos.has(PosAttrs::kY)) {
+                fChunkPos.fY = pos[PosAttrs::kY];
+            }
+        }
+
+        fShapeBuffer.append(ch, {
+            {
+                pos.has(PosAttrs::kDx) ? pos[PosAttrs::kDx] : 0,
+                pos.has(PosAttrs::kDy) ? pos[PosAttrs::kDy] : 0,
+            },
+            pos.has(PosAttrs::kRotate) ? SkDegreesToRadians(pos[PosAttrs::kRotate]) : 0,
+        });
+
+        fPrevCharSpace = (ch == ' ');
+    }
+
+    this->shapePendingBuffer(ctx, font);
+
+    // Note: at this point we have shaped and buffered RunRecs for the current fragment.
+    // The active text chunk continues until an explicit or implicit flush.
+}
+
+SkSVGTextContext::PathData::PathData(const SkSVGRenderContext& ctx, const SkSVGTextPath& tpath)
+{
+    const auto ref = ctx.findNodeById(tpath.getHref());
+    if (!ref) {
+        return;
+    }
+
+    SkContourMeasureIter cmi(ref->asPath(ctx), false);
+    while (sk_sp<SkContourMeasure> contour = cmi.next()) {
+        fLength += contour->length();
+        fContours.push_back(std::move(contour));
+    }
+}
+
+SkMatrix SkSVGTextContext::PathData::getMatrixAt(float offset) const {
+    if (offset >= 0) {
+        for (const auto& contour : fContours) {
+            const auto contour_len = contour->length();
+            if (offset < contour_len) {
+                SkMatrix m;
+                return contour->getMatrix(offset, &m) ? m : SkMatrix::I();
+            }
+            offset -= contour_len;
+        }
+    }
+
+    // Quick & dirty way to "skip" rendering of glyphs off path.
+    return SkMatrix::Translate(std::numeric_limits<float>::infinity(),
+                               std::numeric_limits<float>::infinity());
+}
+
+SkRSXform SkSVGTextContext::computeGlyphXform(SkGlyphID glyph, const SkFont& font,
+                                              const SkPoint& glyph_pos,
+                                              const PositionAdjustment& pos_adjust) const {
+    SkPoint pos = fChunkPos + glyph_pos + pos_adjust.offset + fChunkAdvance * fChunkAlignmentFactor;
+    if (!fPathData) {
+        return SkRSXform::MakeFromRadians(/*scale=*/ 1, pos_adjust.rotation, pos.fX, pos.fY, 0, 0);
+    }
+
+    // We're in a textPath scope, reposition the glyph on path.
+    // (https://www.w3.org/TR/SVG11/text.html#TextpathLayoutRules)
+
+    // Path positioning is based on the glyph center (horizontal component).
+    float glyph_width;
+    font.getWidths(&glyph, 1, &glyph_width);
+    auto path_offset = pos.fX + glyph_width * .5f;
+
+    // In addition to the path matrix, the final glyph matrix also includes:
+    //
+    //   -- vertical position adjustment "dy" ("dx" is factored into path_offset)
+    //   -- glyph origin adjustment (undoing the glyph center offset above)
+    //   -- explicit rotation adjustment (composing with the path glyph rotation)
+    const auto m = fPathData->getMatrixAt(path_offset) *
+            SkMatrix::Translate(-glyph_width * .5f, pos_adjust.offset.fY) *
+            SkMatrix::RotateRad(pos_adjust.rotation);
+
+    return SkRSXform::Make(m.getScaleX(), m.getSkewY(), m.getTranslateX(), m.getTranslateY());
+}
+
+void SkSVGTextContext::flushChunk(const SkSVGRenderContext& ctx) {
+    SkTextBlobBuilder blobBuilder;
+
+    for (const auto& run : fRuns) {
+        const auto& buf = blobBuilder.allocRunRSXform(run.font, SkToInt(run.glyphCount));
+        std::copy(run.glyphs.get(), run.glyphs.get() + run.glyphCount, buf.glyphs);
+        for (size_t i = 0; i < run.glyphCount; ++i) {
+            buf.xforms()[i] = this->computeGlyphXform(run.glyphs[i],
+                                                      run.font,
+                                                      run.glyphPos[i],
+                                                      run.glyhPosAdjust[i]);
+        }
+
+        fCallback(ctx, blobBuilder.make(), run.fillPaint.get(), run.strokePaint.get());
+    }
+
+    fChunkPos += fChunkAdvance;
+    fChunkAdvance = {0,0};
+    fChunkAlignmentFactor = ComputeAlignmentFactor(ctx.presentationContext());
+
+    fRuns.clear();
+}
+
+SkShaper::RunHandler::Buffer SkSVGTextContext::runBuffer(const RunInfo& ri) {
+    SkASSERT(ri.glyphCount);
+
+    fRuns.push_back({
+        ri.fFont,
+        fCurrentFill.isValid()   ? std::make_unique<SkPaint>(*fCurrentFill)   : nullptr,
+        fCurrentStroke.isValid() ? std::make_unique<SkPaint>(*fCurrentStroke) : nullptr,
+        std::make_unique<SkGlyphID[]         >(ri.glyphCount),
+        std::make_unique<SkPoint[]           >(ri.glyphCount),
+        std::make_unique<PositionAdjustment[]>(ri.glyphCount),
+        ri.glyphCount,
+        ri.fAdvance,
+    });
+
+    // Ensure sufficient space to temporarily fetch cluster information.
+    fShapeClusterBuffer.resize(std::max(fShapeClusterBuffer.size(), ri.glyphCount));
+
+    return {
+        fRuns.back().glyphs.get(),
+        fRuns.back().glyphPos.get(),
+        nullptr,
+        fShapeClusterBuffer.data(),
+        fChunkAdvance,
+    };
+}
+
+void SkSVGTextContext::commitRunBuffer(const RunInfo& ri) {
+    const auto& current_run = fRuns.back();
+
+    // stash position adjustments
+    for (size_t i = 0; i < ri.glyphCount; ++i) {
+        const auto utf8_index = fShapeClusterBuffer[i];
+        current_run.glyhPosAdjust[i] = fShapeBuffer.fUtf8PosAdjust[SkToInt(utf8_index)];
+    }
+
+    fChunkAdvance += ri.fAdvance;
+}
+
+void SkSVGTextContext::commitLine() {
+    if (!fShapeBuffer.fUtf8PosAdjust.empty()) {
+        // Offset adjustments are cumulative - only advance the current chunk with the last value.
+        fChunkAdvance += fShapeBuffer.fUtf8PosAdjust.back().offset;
+    }
+}
+
+void SkSVGTextFragment::renderText(const SkSVGRenderContext& ctx, SkSVGTextContext* tctx,
+                                   SkSVGXmlSpace xs) const {
+    // N.B.: unlike regular elements, text fragments do not establish a new OBB scope -- they
+    // always defer to the root <text> element for OBB resolution.
+    SkSVGRenderContext localContext(ctx);
+
+    if (this->onPrepareToRender(&localContext)) {
+        this->onShapeText(localContext, tctx, xs);
+    }
+}
+
+SkPath SkSVGTextFragment::onAsPath(const SkSVGRenderContext&) const {
+    // TODO
+    return SkPath();
+}
+
+void SkSVGTextContainer::appendChild(sk_sp<SkSVGNode> child) {
+    // Only allow text content child nodes.
+    switch (child->tag()) {
+    case SkSVGTag::kTextLiteral:
+    case SkSVGTag::kTextPath:
+    case SkSVGTag::kTSpan:
+        fChildren.push_back(
+            sk_sp<SkSVGTextFragment>(static_cast<SkSVGTextFragment*>(child.release())));
+        break;
+    default:
+        break;
+    }
+}
+
+void SkSVGTextContainer::onShapeText(const SkSVGRenderContext& ctx, SkSVGTextContext* tctx,
+                                     SkSVGXmlSpace) const {
+    SkASSERT(tctx);
+
+    const SkSVGTextContext::ScopedPosResolver resolver(*this, ctx.lengthContext(), tctx);
+
+    for (const auto& frag : fChildren) {
+        // Containers always override xml:space with the local value.
+        frag->renderText(ctx, tctx, this->getXmlSpace());
+    }
+}
+
+// https://www.w3.org/TR/SVG11/text.html#WhiteSpace
+template <>
+bool SkSVGAttributeParser::parse(SkSVGXmlSpace* xs) {
+    static constexpr std::tuple<const char*, SkSVGXmlSpace> gXmlSpaceMap[] = {
+            {"default" , SkSVGXmlSpace::kDefault },
+            {"preserve", SkSVGXmlSpace::kPreserve},
+    };
+
+    return this->parseEnumMap(gXmlSpaceMap, xs) && this->parseEOSToken();
+}
+
+bool SkSVGTextContainer::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("y", name, value)) ||
+           this->setDx(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("dx", name, value)) ||
+           this->setDy(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("dy", name, value)) ||
+           this->setRotate(SkSVGAttributeParser::parse<std::vector<SkSVGNumberType>>("rotate",
+                                                                                     name,
+                                                                                     value)) ||
+           this->setXmlSpace(SkSVGAttributeParser::parse<SkSVGXmlSpace>("xml:space", name, value));
+}
+
+void SkSVGTextLiteral::onShapeText(const SkSVGRenderContext& ctx, SkSVGTextContext* tctx,
+                                   SkSVGXmlSpace xs) const {
+    SkASSERT(tctx);
+
+    tctx->shapeFragment(this->getText(), ctx, xs);
+}
+
+void SkSVGText::onRender(const SkSVGRenderContext& ctx) const {
+    const SkSVGTextContext::ShapedTextCallback render_text = [](const SkSVGRenderContext& ctx,
+                                                                const sk_sp<SkTextBlob>& blob,
+                                                                const SkPaint* fill,
+                                                                const SkPaint* stroke) {
+        if (fill) {
+            ctx.canvas()->drawTextBlob(blob, 0, 0, *fill);
+        }
+        if (stroke) {
+            ctx.canvas()->drawTextBlob(blob, 0, 0, *stroke);
+        }
+    };
+
+    // Root <text> nodes establish a text layout context.
+    SkSVGTextContext tctx(ctx, render_text);
+
+    this->onShapeText(ctx, &tctx, this->getXmlSpace());
+}
+
+SkRect SkSVGText::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    SkRect bounds = SkRect::MakeEmpty();
+
+    const SkSVGTextContext::ShapedTextCallback compute_bounds =
+        [&bounds](const SkSVGRenderContext& ctx, const sk_sp<SkTextBlob>& blob, const SkPaint*,
+                  const SkPaint*) {
+            if (!blob) {
+                return;
+            }
+
+            AutoSTArray<64, SkRect> glyphBounds;
+
+            for (SkTextBlobRunIterator it(blob.get()); !it.done(); it.next()) {
+                glyphBounds.reset(SkToInt(it.glyphCount()));
+                it.font().getBounds(it.glyphs(), it.glyphCount(), glyphBounds.get(), nullptr);
+
+                SkASSERT(it.positioning() == SkTextBlobRunIterator::kRSXform_Positioning);
+                SkMatrix m;
+                for (uint32_t i = 0; i < it.glyphCount(); ++i) {
+                    m.setRSXform(it.xforms()[i]);
+                    bounds.join(m.mapRect(glyphBounds[i]));
+                }
+            }
+        };
+
+    {
+        SkSVGTextContext tctx(ctx, compute_bounds);
+        this->onShapeText(ctx, &tctx, this->getXmlSpace());
+    }
+
+    return bounds;
+}
+
+SkPath SkSVGText::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPathBuilder builder;
+
+    const SkSVGTextContext::ShapedTextCallback as_path =
+        [&builder](const SkSVGRenderContext& ctx, const sk_sp<SkTextBlob>& blob, const SkPaint*,
+                   const SkPaint*) {
+            if (!blob) {
+                return;
+            }
+
+            for (SkTextBlobRunIterator it(blob.get()); !it.done(); it.next()) {
+                struct GetPathsCtx {
+                    SkPathBuilder&   builder;
+                    const SkRSXform* xform;
+                } get_paths_ctx {builder, it.xforms()};
+
+                it.font().getPaths(it.glyphs(), it.glyphCount(), [](const SkPath* path,
+                                                                    const SkMatrix& matrix,
+                                                                    void* raw_ctx) {
+                    auto* get_paths_ctx = static_cast<GetPathsCtx*>(raw_ctx);
+                    const auto& glyph_rsx = *get_paths_ctx->xform++;
+
+                    if (!path) {
+                        return;
+                    }
+
+                    SkMatrix glyph_matrix;
+                    glyph_matrix.setRSXform(glyph_rsx);
+                    glyph_matrix.preConcat(matrix);
+
+                    get_paths_ctx->builder.addPath(path->makeTransform(glyph_matrix));
+                }, &get_paths_ctx);
+            }
+        };
+
+    {
+        SkSVGTextContext tctx(ctx, as_path);
+        this->onShapeText(ctx, &tctx, this->getXmlSpace());
+    }
+
+    auto path = builder.detach();
+    this->mapToParent(&path);
+
+    return path;
+}
+
+void SkSVGTextPath::onShapeText(const SkSVGRenderContext& ctx, SkSVGTextContext* parent_tctx,
+                                 SkSVGXmlSpace xs) const {
+    SkASSERT(parent_tctx);
+
+    // textPath nodes establish a new text layout context.
+    SkSVGTextContext tctx(ctx, parent_tctx->getCallback(), this);
+
+    this->INHERITED::onShapeText(ctx, &tctx, xs);
+}
+
+bool SkSVGTextPath::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+        this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", name, value)) ||
+        this->setStartOffset(SkSVGAttributeParser::parse<SkSVGLength>("startOffset", name, value));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h b/Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h
new file mode 100644
index 00000000..a7d614b2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGTextPriv_DEFINED
+#define SkSVGTextPriv_DEFINED
+
+#include "include/private/base/SkTArray.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGText.h"
+#include "src/base/SkTLazy.h"
+
+#include <functional>
+#include <tuple>
+
+class SkContourMeasure;
+struct SkRSXform;
+
+// SkSVGTextContext is responsible for sequencing input text chars into "chunks".
+// A single text chunk can span multiple structural elements (<text>, <tspan>, etc),
+// and per [1] new chunks are emitted
+//
+//   a) for each top level text element (<text>, <textPath>)
+//   b) whenever a character with an explicit absolute position is encountered
+//
+// The implementation queues shaped run data until a full text chunk is resolved, at which
+// point we have enough information to perform final alignment and rendering.
+//
+// [1] https://www.w3.org/TR/SVG11/text.html#TextLayoutIntroduction
+class SkSVGTextContext final : SkShaper::RunHandler {
+public:
+    using ShapedTextCallback = std::function<void(const SkSVGRenderContext&,
+                                                  const sk_sp<SkTextBlob>&,
+                                                  const SkPaint*,
+                                                  const SkPaint*)>;
+
+    // Helper for encoding optional positional attributes.
+    class PosAttrs {
+    public:
+        // TODO: rotate
+        enum Attr : size_t {
+            kX      = 0,
+            kY      = 1,
+            kDx     = 2,
+            kDy     = 3,
+            kRotate = 4,
+        };
+
+        float  operator[](Attr a) const { return fStorage[a]; }
+        float& operator[](Attr a)       { return fStorage[a]; }
+
+        bool has(Attr a) const { return fStorage[a] != kNone; }
+        bool hasAny()    const {
+            return this->has(kX)
+                || this->has(kY)
+                || this->has(kDx)
+                || this->has(kDy)
+                || this->has(kRotate);
+        }
+
+        void setImplicitRotate(bool imp) { fImplicitRotate = imp; }
+        bool isImplicitRotate() const { return fImplicitRotate; }
+
+    private:
+        inline static constexpr auto kNone = std::numeric_limits<float>::infinity();
+
+        float fStorage[5]     = { kNone, kNone, kNone, kNone, kNone };
+        bool  fImplicitRotate = false;
+    };
+
+    // Helper for cascading position attribute resolution (x, y, dx, dy, rotate) [1]:
+    //   - each text position element can specify an arbitrary-length attribute array
+    //   - for each character, we look up a given attribute first in its local attribute array,
+    //     then in the ancestor chain (cascading/fallback) - and return the first value encountered.
+    //   - the lookup is based on character index relative to the text content subtree
+    //     (i.e. the index crosses chunk boundaries)
+    //
+    // [1] https://www.w3.org/TR/SVG11/text.html#TSpanElementXAttribute
+    class ScopedPosResolver {
+    public:
+        ScopedPosResolver(const SkSVGTextContainer&, const SkSVGLengthContext&, SkSVGTextContext*,
+                          size_t);
+
+        ScopedPosResolver(const SkSVGTextContainer&, const SkSVGLengthContext&, SkSVGTextContext*);
+
+        ~ScopedPosResolver();
+
+        PosAttrs resolve(size_t charIndex) const;
+
+    private:
+        SkSVGTextContext*         fTextContext;
+        const ScopedPosResolver*  fParent;          // parent resolver (fallback)
+        const size_t              fCharIndexOffset; // start index for the current resolver
+        const std::vector<float>  fX,
+                                  fY,
+                                  fDx,
+                                  fDy;
+        const std::vector<float>& fRotate;
+
+        // cache for the last known index with explicit positioning
+        mutable size_t           fLastPosIndex = std::numeric_limits<size_t>::max();
+
+    };
+
+    SkSVGTextContext(const SkSVGRenderContext&,
+                     const ShapedTextCallback&,
+                     const SkSVGTextPath* = nullptr);
+    ~SkSVGTextContext() override;
+
+    // Shape and queue codepoints for final alignment.
+    void shapeFragment(const SkString&, const SkSVGRenderContext&, SkSVGXmlSpace);
+
+    // Perform final adjustments and push shaped blobs to the callback.
+    void flushChunk(const SkSVGRenderContext& ctx);
+
+    const ShapedTextCallback& getCallback() const { return fCallback; }
+
+private:
+    struct PositionAdjustment {
+        SkVector offset;
+        float    rotation;
+    };
+
+    struct ShapeBuffer {
+        skia_private::STArray<128, char              , true> fUtf8;
+        // per-utf8-char cumulative pos adjustments
+        skia_private::STArray<128, PositionAdjustment, true> fUtf8PosAdjust;
+
+        void reserve(size_t size) {
+            fUtf8.reserve_exact(fUtf8.size() + SkToInt(size));
+            fUtf8PosAdjust.reserve_exact(fUtf8PosAdjust.size() + SkToInt(size));
+        }
+
+        void reset() {
+            fUtf8.clear();
+            fUtf8PosAdjust.clear();
+        }
+
+        void append(SkUnichar, PositionAdjustment);
+    };
+
+    struct RunRec {
+        SkFont                                font;
+        std::unique_ptr<SkPaint>              fillPaint,
+                                              strokePaint;
+        std::unique_ptr<SkGlyphID[]>          glyphs;        // filled by SkShaper
+        std::unique_ptr<SkPoint[]>            glyphPos;      // filled by SkShaper
+        std::unique_ptr<PositionAdjustment[]> glyhPosAdjust; // deferred positioning adjustments
+        size_t                                glyphCount;
+        SkVector                              advance;
+    };
+
+    // Caches path information to accelerate position lookups.
+    class PathData {
+    public:
+        PathData(const SkSVGRenderContext&, const SkSVGTextPath&);
+
+        SkMatrix getMatrixAt(float offset) const;
+
+        float length() const { return fLength; }
+
+    private:
+        std::vector<sk_sp<SkContourMeasure>> fContours;
+        float                                fLength = 0; // total path length
+    };
+
+    void shapePendingBuffer(const SkSVGRenderContext&, const SkFont&);
+
+    SkRSXform computeGlyphXform(SkGlyphID, const SkFont&, const SkPoint& glyph_pos,
+                                const PositionAdjustment&) const;
+
+    // SkShaper callbacks
+    void beginLine() override {}
+    void runInfo(const RunInfo&) override {}
+    void commitRunInfo() override {}
+    Buffer runBuffer(const RunInfo& ri) override;
+    void commitRunBuffer(const RunInfo& ri) override;
+    void commitLine() override;
+
+    // http://www.w3.org/TR/SVG11/text.html#TextLayout
+    const SkSVGRenderContext&       fRenderContext; // original render context
+    const ShapedTextCallback&       fCallback;
+    std::unique_ptr<SkShaper>       fShaper;
+    std::vector<RunRec>             fRuns;
+    const ScopedPosResolver*        fPosResolver = nullptr;
+    std::unique_ptr<PathData>       fPathData;
+
+    // shaper state
+    ShapeBuffer                     fShapeBuffer;
+    std::vector<uint32_t>           fShapeClusterBuffer;
+
+    // chunk state
+    SkPoint                         fChunkPos     = {0,0}; // current text chunk position
+    SkVector                        fChunkAdvance = {0,0}; // cumulative advance
+    float                           fChunkAlignmentFactor; // current chunk alignment
+
+    // tracks the global text subtree char index (cross chunks).  Used for position resolution.
+    size_t                          fCurrentCharIndex = 0;
+
+    // cached for access from SkShaper callbacks.
+    SkTLazy<SkPaint>                fCurrentFill;
+    SkTLazy<SkPaint>                fCurrentStroke;
+
+    bool                            fPrevCharSpace = true; // WS filter state
+    bool                            fForcePrimitiveShaping = false;
+};
+
+#endif // SkSVGTextPriv_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp
new file mode 100644
index 00000000..55f7550c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGTransformableNode::SkSVGTransformableNode(SkSVGTag tag)
+    : INHERITED(tag)
+    , fTransform(SkMatrix::I()) { }
+
+
+bool SkSVGTransformableNode::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    if (!fTransform.isIdentity()) {
+        ctx->saveOnce();
+        ctx->canvas()->concat(fTransform);
+    }
+
+    return this->INHERITED::onPrepareToRender(ctx);
+}
+
+void SkSVGTransformableNode::onSetAttribute(SkSVGAttribute attr, const SkSVGValue& v) {
+    switch (attr) {
+    case SkSVGAttribute::kTransform:
+        if (const auto* transform = v.as<SkSVGTransformValue>()) {
+            this->setTransform(*transform);
+        }
+        break;
+    default:
+        this->INHERITED::onSetAttribute(attr, v);
+        break;
+    }
+}
+
+void SkSVGTransformableNode::mapToParent(SkPath* path) const {
+    // transforms the path to parent node coordinates.
+    path->transform(fTransform);
+}
+
+void SkSVGTransformableNode::mapToParent(SkRect* rect) const {
+    *rect = fTransform.mapRect(*rect);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp
new file mode 100644
index 00000000..851cb640
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGUse.h"
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGUse::SkSVGUse() : INHERITED(SkSVGTag::kUse) {}
+
+void SkSVGUse::appendChild(sk_sp<SkSVGNode>) {
+    SkDebugf("cannot append child nodes to this element.\n");
+}
+
+bool SkSVGUse::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", n, v));
+}
+
+bool SkSVGUse::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    if (fHref.iri().isEmpty() || !INHERITED::onPrepareToRender(ctx)) {
+        return false;
+    }
+
+    if (fX.value() || fY.value()) {
+        // Restored when the local SkSVGRenderContext leaves scope.
+        ctx->saveOnce();
+        ctx->canvas()->translate(fX.value(), fY.value());
+    }
+
+    // TODO: width/height override for <svg> targets.
+
+    return true;
+}
+
+void SkSVGUse::onRender(const SkSVGRenderContext& ctx) const {
+    const auto ref = ctx.findNodeById(fHref);
+    if (!ref) {
+        return;
+    }
+
+    ref->render(ctx);
+}
+
+SkPath SkSVGUse::onAsPath(const SkSVGRenderContext& ctx) const {
+    const auto ref = ctx.findNodeById(fHref);
+    if (!ref) {
+        return SkPath();
+    }
+
+    return ref->asPath(ctx);
+}
+
+SkRect SkSVGUse::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    const auto ref = ctx.findNodeById(fHref);
+    if (!ref) {
+        return SkRect::MakeEmpty();
+    }
+
+    const SkSVGLengthContext& lctx = ctx.lengthContext();
+    const SkScalar x = lctx.resolve(fX, SkSVGLengthContext::LengthType::kHorizontal);
+    const SkScalar y = lctx.resolve(fY, SkSVGLengthContext::LengthType::kVertical);
+
+    SkRect bounds = ref->objectBoundingBox(ctx);
+    bounds.offset(x, y);
+
+    return bounds;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp
new file mode 100644
index 00000000..0b9d9c1c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp
@@ -0,0 +1,7 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
diff --git a/Source/ThirdParty/skia/modules/svg/svg.gni b/Source/ThirdParty/skia/modules/svg/svg.gni
new file mode 100644
index 00000000..6d36446b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/svg.gni
@@ -0,0 +1,115 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/svg/include/BUILD.bazel
+#   //modules/svg/src/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# Generated by Bazel rule //modules/svg/include:public_hdrs
+skia_svg_public = [
+  "$_modules/svg/include/SkSVGAttribute.h",
+  "$_modules/svg/include/SkSVGAttributeParser.h",
+  "$_modules/svg/include/SkSVGCircle.h",
+  "$_modules/svg/include/SkSVGClipPath.h",
+  "$_modules/svg/include/SkSVGContainer.h",
+  "$_modules/svg/include/SkSVGDOM.h",
+  "$_modules/svg/include/SkSVGDefs.h",
+  "$_modules/svg/include/SkSVGEllipse.h",
+  "$_modules/svg/include/SkSVGFe.h",
+  "$_modules/svg/include/SkSVGFeBlend.h",
+  "$_modules/svg/include/SkSVGFeColorMatrix.h",
+  "$_modules/svg/include/SkSVGFeComponentTransfer.h",
+  "$_modules/svg/include/SkSVGFeComposite.h",
+  "$_modules/svg/include/SkSVGFeDisplacementMap.h",
+  "$_modules/svg/include/SkSVGFeFlood.h",
+  "$_modules/svg/include/SkSVGFeGaussianBlur.h",
+  "$_modules/svg/include/SkSVGFeImage.h",
+  "$_modules/svg/include/SkSVGFeLightSource.h",
+  "$_modules/svg/include/SkSVGFeLighting.h",
+  "$_modules/svg/include/SkSVGFeMerge.h",
+  "$_modules/svg/include/SkSVGFeMorphology.h",
+  "$_modules/svg/include/SkSVGFeOffset.h",
+  "$_modules/svg/include/SkSVGFeTurbulence.h",
+  "$_modules/svg/include/SkSVGFilter.h",
+  "$_modules/svg/include/SkSVGFilterContext.h",
+  "$_modules/svg/include/SkSVGG.h",
+  "$_modules/svg/include/SkSVGGradient.h",
+  "$_modules/svg/include/SkSVGHiddenContainer.h",
+  "$_modules/svg/include/SkSVGIDMapper.h",
+  "$_modules/svg/include/SkSVGImage.h",
+  "$_modules/svg/include/SkSVGLine.h",
+  "$_modules/svg/include/SkSVGLinearGradient.h",
+  "$_modules/svg/include/SkSVGMask.h",
+  "$_modules/svg/include/SkSVGNode.h",
+  "$_modules/svg/include/SkSVGOpenTypeSVGDecoder.h",
+  "$_modules/svg/include/SkSVGPath.h",
+  "$_modules/svg/include/SkSVGPattern.h",
+  "$_modules/svg/include/SkSVGPoly.h",
+  "$_modules/svg/include/SkSVGRadialGradient.h",
+  "$_modules/svg/include/SkSVGRect.h",
+  "$_modules/svg/include/SkSVGRenderContext.h",
+  "$_modules/svg/include/SkSVGSVG.h",
+  "$_modules/svg/include/SkSVGShape.h",
+  "$_modules/svg/include/SkSVGStop.h",
+  "$_modules/svg/include/SkSVGText.h",
+  "$_modules/svg/include/SkSVGTransformableNode.h",
+  "$_modules/svg/include/SkSVGTypes.h",
+  "$_modules/svg/include/SkSVGUse.h",
+  "$_modules/svg/include/SkSVGValue.h",
+]
+
+# List generated by Bazel rules:
+#  //modules/svg/src:private_hdrs
+#  //modules/svg/src:srcs
+skia_svg_sources = [
+  "$_modules/svg/src/SkSVGAttribute.cpp",
+  "$_modules/svg/src/SkSVGAttributeParser.cpp",
+  "$_modules/svg/src/SkSVGCircle.cpp",
+  "$_modules/svg/src/SkSVGClipPath.cpp",
+  "$_modules/svg/src/SkSVGContainer.cpp",
+  "$_modules/svg/src/SkSVGDOM.cpp",
+  "$_modules/svg/src/SkSVGEllipse.cpp",
+  "$_modules/svg/src/SkSVGFe.cpp",
+  "$_modules/svg/src/SkSVGFeBlend.cpp",
+  "$_modules/svg/src/SkSVGFeColorMatrix.cpp",
+  "$_modules/svg/src/SkSVGFeComponentTransfer.cpp",
+  "$_modules/svg/src/SkSVGFeComposite.cpp",
+  "$_modules/svg/src/SkSVGFeDisplacementMap.cpp",
+  "$_modules/svg/src/SkSVGFeFlood.cpp",
+  "$_modules/svg/src/SkSVGFeGaussianBlur.cpp",
+  "$_modules/svg/src/SkSVGFeImage.cpp",
+  "$_modules/svg/src/SkSVGFeLightSource.cpp",
+  "$_modules/svg/src/SkSVGFeLighting.cpp",
+  "$_modules/svg/src/SkSVGFeMerge.cpp",
+  "$_modules/svg/src/SkSVGFeMorphology.cpp",
+  "$_modules/svg/src/SkSVGFeOffset.cpp",
+  "$_modules/svg/src/SkSVGFeTurbulence.cpp",
+  "$_modules/svg/src/SkSVGFilter.cpp",
+  "$_modules/svg/src/SkSVGFilterContext.cpp",
+  "$_modules/svg/src/SkSVGGradient.cpp",
+  "$_modules/svg/src/SkSVGImage.cpp",
+  "$_modules/svg/src/SkSVGLine.cpp",
+  "$_modules/svg/src/SkSVGLinearGradient.cpp",
+  "$_modules/svg/src/SkSVGMask.cpp",
+  "$_modules/svg/src/SkSVGNode.cpp",
+  "$_modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp",
+  "$_modules/svg/src/SkSVGPath.cpp",
+  "$_modules/svg/src/SkSVGPattern.cpp",
+  "$_modules/svg/src/SkSVGPoly.cpp",
+  "$_modules/svg/src/SkSVGRadialGradient.cpp",
+  "$_modules/svg/src/SkSVGRect.cpp",
+  "$_modules/svg/src/SkSVGRectPriv.h",
+  "$_modules/svg/src/SkSVGRenderContext.cpp",
+  "$_modules/svg/src/SkSVGSVG.cpp",
+  "$_modules/svg/src/SkSVGShape.cpp",
+  "$_modules/svg/src/SkSVGStop.cpp",
+  "$_modules/svg/src/SkSVGText.cpp",
+  "$_modules/svg/src/SkSVGTextPriv.h",
+  "$_modules/svg/src/SkSVGTransformableNode.cpp",
+  "$_modules/svg/src/SkSVGUse.cpp",
+  "$_modules/svg/src/SkSVGValue.cpp",
+]
diff --git a/Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel
new file mode 100644
index 00000000..800b999a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel
@@ -0,0 +1,5 @@
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
diff --git a/Source/ThirdParty/skia/modules/svg/tests/Filters.cpp b/Source/ThirdParty/skia/modules/svg/tests/Filters.cpp
new file mode 100644
index 00000000..b7ee21d4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/tests/Filters.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <string>
+
+#include "include/core/SkStream.h"
+#include "include/utils/SkNoDrawCanvas.h"
+#include "modules/svg/include/SkSVGDOM.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "tests/Test.h"
+
+DEF_TEST(Svg_Filters_NonePaintInputs, r) {
+    const std::string svgText = R"EOF(
+    <svg width="500" height="500" xmlns="http://www.w3.org/2000/svg"
+         xmlns:xlink="http://www.w3.org/1999/xlink">
+        <defs>
+            <filter id="f" x="0" y="0" width="1" height="1">
+                <feComposite operator="arithmetic" in="FillPaint" in2="StrokePaint"
+                             k1="0" k2="10" k3="20" k4="0"/>
+            </filter>
+        </defs>
+        <rect fill="none" stroke="none" filter="url(#f)" x="10" y="10" width="100" height="1,0"/>
+    </svg>
+    )EOF";
+
+    auto str = SkMemoryStream::MakeDirect(svgText.c_str(), svgText.size());
+    auto svg_dom = SkSVGDOM::Builder().make(*str);
+    SkNoDrawCanvas canvas(500, 500);
+    svg_dom->render(&canvas);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/tests/Text.cpp b/Source/ThirdParty/skia/modules/svg/tests/Text.cpp
new file mode 100644
index 00000000..0831101e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/tests/Text.cpp
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <vector>
+
+#include "include/utils/SkNoDrawCanvas.h"
+#include "modules/skshaper/utils/FactoryHelpers.h"
+#include "modules/svg/src/SkSVGTextPriv.h"
+#include "tests/Test.h"
+#include "tools/fonts/FontToolUtils.h"
+
+DEF_TEST(Svg_Text_PosProvider, r) {
+    const auto L = [](float x) { return SkSVGLength(x); };
+    const float N = SkSVGTextContext::PosAttrs()[SkSVGTextContext::PosAttrs::kX];
+
+    static const struct PosTestDesc {
+        size_t                   offseta;
+        std::vector<SkSVGLength> xa, ya;
+
+        size_t                   offsetb;
+        std::vector<SkSVGLength> xb, yb;
+
+        std::vector<SkPoint>     expected;
+    } gTests[] = {
+        {
+            0, {}, {},
+            0, {}, {},
+
+            { {N,N} }
+        },
+
+        {
+            0, { L(1) }, {},
+            0, {      }, {},
+
+            { {1,N}, {N,N} }
+        },
+        {
+            0, {       }, {},
+            0, { L(10) }, {},
+
+            { {10,N}, {N,N} }
+        },
+        {
+            0, { L( 1) }, {},
+            0, { L(10) }, {},
+
+            { {10,N}, {N,N} }
+        },
+        {
+            0, { L( 1), L(2) }, {},
+            0, { L(10)       }, {},
+
+            { {10,N}, {2,N}, {N,N} }
+        },
+        {
+            0, { L(1), L( 2) }, {},
+            1, {       L(20) }, {},
+
+            { {1,N}, {20,N}, {N,N} }
+        },
+        {
+            0, { L(1), L( 2), L(3) }, {},
+            1, {       L(20)       }, {},
+
+            { {1,N}, {20,N}, {3,N}, {N,N} }
+        },
+        {
+            0, { L(1), L(2), L( 3) }, {},
+            2, {             L(30) }, {},
+
+            { {1,N}, {2,N}, {30,N}, {N,N} }
+        },
+        {
+            0, { L(1)              }, {},
+            2, {             L(30) }, {},
+
+            { {1,N}, {N,N}, {30,N}, {N,N} }
+        },
+
+
+        {
+            0, {}, { L(4) },
+            0, {}, {      },
+
+            { {N,4}, {N,N} }
+        },
+        {
+            0, {}, {       },
+            0, {}, { L(40) },
+
+            { {N,40}, {N,N} }
+        },
+        {
+            0, {}, { L( 4) },
+            0, {}, { L(40) },
+
+            { {N,40}, {N,N} }
+        },
+        {
+            0, {}, { L( 4), L(5) },
+            0, {}, { L(40)       },
+
+            { {N,40}, {N,5}, {N,N} }
+        },
+        {
+            0, {}, { L(4), L( 5) },
+            1, {}, {       L(50) },
+
+            { {N,4}, {N,50}, {N,N} }
+        },
+        {
+            0, {}, { L(4), L( 5), L(6) },
+            1, {}, {       L(50)       },
+
+            { {N,4}, {N,50}, {N,6}, {N,N} }
+        },
+        {
+            0, {}, { L(4), L(5), L( 6) },
+            2, {}, {             L(60) },
+
+            { {N,4}, {N,5}, {N,60}, {N,N} }
+        },
+        {
+            0, {}, { L(4)              },
+            2, {}, {             L(60) },
+
+            { {N,4}, {N,N}, {N,60}, {N,N} }
+        },
+
+        {
+            0, { L( 1), L(2)}, { L( 4)        },
+            0, { L(10)      }, { L(40), L(50) },
+
+            { {10,40}, {2,50}, {N,N} }
+        },
+        {
+            0, { L(1), L( 2), L(3) }, { L(4), L( 5)        },
+            1, {       L(20)       }, {       L(50), L(60) },
+
+            { {1,4}, {20,50}, {3,60}, {N,N} }
+        },
+    };
+
+    const SkSVGTextContext::ShapedTextCallback mock_cb =
+        [](const SkSVGRenderContext&, const sk_sp<SkTextBlob>&, const SkPaint*, const SkPaint*) {};
+
+    auto test = [&](const PosTestDesc& tst) {
+        auto a = SkSVGText::Make();
+        auto b = SkSVGTSpan::Make();
+        a->appendChild(b);
+
+        a->setX(tst.xa);
+        a->setY(tst.ya);
+        b->setX(tst.xb);
+        b->setY(tst.yb);
+
+        const SkSVGIDMapper mapper;
+        const SkSVGLengthContext lctx({0,0});
+        const SkSVGPresentationContext pctx;
+        SkNoDrawCanvas canvas(0, 0);
+        sk_sp<SkFontMgr> fmgr = ToolUtils::TestFontMgr();
+        sk_sp<skresources::ResourceProvider> rp;
+        sk_sp<SkShapers::Factory> shaping = SkShapers::BestAvailable();
+        const SkSVGRenderContext ctx(&canvas,
+                                     fmgr,
+                                     rp,
+                                     mapper,
+                                     lctx,
+                                     pctx,
+                                     {nullptr, nullptr},
+                                     shaping);
+
+        SkSVGTextContext tctx(ctx, mock_cb);
+        SkSVGTextContext::ScopedPosResolver pa(*a, lctx, &tctx, tst.offseta);
+        SkSVGTextContext::ScopedPosResolver pb(*b, lctx, &tctx, tst.offsetb);
+
+        for (size_t i = 0; i < tst.expected.size(); ++i) {
+            const auto& exp = tst.expected[i];
+            auto pos = i >= tst.offsetb ? pb.resolve(i) : pa.resolve(i);
+
+            REPORTER_ASSERT(r, pos[SkSVGTextContext::PosAttrs::kX] == exp.fX);
+            REPORTER_ASSERT(r, pos[SkSVGTextContext::PosAttrs::kY] == exp.fY);
+        }
+    };
+
+    for (const auto& tst : gTests) {
+        test(tst);
+    }
+}
diff --git a/Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel
new file mode 100644
index 00000000..800b999a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel
@@ -0,0 +1,5 @@
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
diff --git a/Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp b/Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp
new file mode 100644
index 00000000..11b28173
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <iostream>
+
+#include "include/core/SkMatrix.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkSurface.h"
+#include "include/encode/SkPngEncoder.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/skshaper/utils/FactoryHelpers.h"
+#include "modules/svg/include/SkSVGDOM.h"
+#include "src/utils/SkOSPath.h"
+#include "tools/CodecUtils.h"
+#include "tools/flags/CommandLineFlags.h"
+#include "tools/fonts/FontToolUtils.h"
+
+#if defined(SK_BUILD_FOR_MAC)
+#include "include/ports/SkFontMgr_mac_ct.h"
+#else
+#include "include/ports/SkFontMgr_empty.h"
+#endif
+
+static DEFINE_string2(input , i, nullptr, "Input SVG file.");
+static DEFINE_string2(output, o, nullptr, "Output PNG file.");
+
+static DEFINE_int(width , 1024, "Output width.");
+static DEFINE_int(height, 1024, "Output height.");
+
+int main(int argc, char** argv) {
+    CommandLineFlags::Parse(argc, argv);
+
+    if (FLAGS_input.isEmpty() || FLAGS_output.isEmpty()) {
+        std::cerr << "Missing required 'input' and 'output' args.\n";
+        return 1;
+    }
+
+    if (FLAGS_width <= 0 || FLAGS_height <= 0) {
+        std::cerr << "Invalid width/height.\n";
+        return 1;
+    }
+
+    SkFILEStream in(FLAGS_input[0]);
+    if (!in.isValid()) {
+        std::cerr << "Could not open " << FLAGS_input[0] << "\n";
+        return 1;
+    }
+
+    // If necessary, clients should use a font manager that would load fonts from the system.
+#if defined(SK_BUILD_FOR_MAC)
+    sk_sp<SkFontMgr> fontMgr = SkFontMgr_New_CoreText(nullptr);
+#else
+    sk_sp<SkFontMgr> fontMgr = SkFontMgr_New_Custom_Empty();
+#endif
+
+    CodecUtils::RegisterAllAvailable();
+
+    auto predecode = skresources::ImageDecodeStrategy::kPreDecode;
+    auto rp = skresources::DataURIResourceProviderProxy::Make(
+            skresources::FileResourceProvider::Make(SkOSPath::Dirname(FLAGS_input[0]), predecode),
+            predecode,
+            fontMgr);
+
+    auto svg_dom = SkSVGDOM::Builder()
+                           .setFontManager(fontMgr)
+                           .setResourceProvider(std::move(rp))
+                           .setTextShapingFactory(SkShapers::BestAvailable())
+                           .make(in);
+
+    if (!svg_dom) {
+        std::cerr << "Could not parse " << FLAGS_input[0] << "\n";
+        return 1;
+    }
+
+    auto surface = SkSurfaces::Raster(SkImageInfo::MakeN32Premul(FLAGS_width, FLAGS_height));
+
+    svg_dom->setContainerSize(SkSize::Make(FLAGS_width, FLAGS_height));
+    svg_dom->render(surface->getCanvas());
+
+    SkPixmap pixmap;
+    surface->peekPixels(&pixmap);
+
+    SkFILEWStream out(FLAGS_output[0]);
+    if (!out.isValid()) {
+        std::cerr << "Could not open " << FLAGS_output[0] << " for writing.\n";
+        return 1;
+    }
+
+    // Use default encoding options.
+    SkPngEncoder::Options png_options;
+
+    if (!SkPngEncoder::Encode(&out, pixmap, png_options)) {
+        std::cerr << "PNG encoding failed.\n";
+        return 1;
+    }
+
+    return 0;
+}
-- 
2.47.0

