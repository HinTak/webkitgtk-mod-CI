From a4a6b64b46fd8ec4379b2826d24cb384c408874e Mon Sep 17 00:00:00 2001
From: Hin-Tak Leung <htl10@users.sourceforge.net>
Date: Wed, 20 Nov 2024 22:16:29 +0000
Subject: [PATCH 1/7] skresources, svg, skshaper, skunicode

Signed-off-by: Hin-Tak Leung <htl10@users.sourceforge.net>
---
 .../skia/modules/skresources/BUILD.bazel      |   31 +
 .../skia/modules/skresources/BUILD.gn         |   25 +
 .../modules/skresources/include/BUILD.bazel   |   13 +
 .../modules/skresources/include/SkResources.h |  289 ++++
 .../skia/modules/skresources/skresources.gni  |   20 +
 .../skia/modules/skresources/src/BUILD.bazel  |   17 +
 .../skresources/src/SkAnimCodecPlayer.cpp     |  155 ++
 .../skresources/src/SkAnimCodecPlayer.h       |   67 +
 .../modules/skresources/src/SkResources.cpp   |  337 ++++
 .../skia/modules/skshaper/BUILD.bazel         |  142 ++
 .../ThirdParty/skia/modules/skshaper/BUILD.gn |   82 +
 .../skia/modules/skshaper/include/BUILD.bazel |   52 +
 .../skia/modules/skshaper/include/SkShaper.h  |  315 ++++
 .../skshaper/include/SkShaper_coretext.h      |   19 +
 .../skshaper/include/SkShaper_factory.h       |   40 +
 .../skshaper/include/SkShaper_harfbuzz.h      |   38 +
 .../skshaper/include/SkShaper_skunicode.h     |   28 +
 .../skia/modules/skshaper/skshaper.gni        |   52 +
 .../skia/modules/skshaper/src/BUILD.bazel     |   47 +
 .../skia/modules/skshaper/src/SkShaper.cpp    |  259 +++
 .../skshaper/src/SkShaper_coretext.cpp        |  327 ++++
 .../modules/skshaper/src/SkShaper_factory.cpp |   35 +
 .../skshaper/src/SkShaper_harfbuzz.cpp        | 1538 +++++++++++++++++
 .../skshaper/src/SkShaper_primitive.cpp       |  255 +++
 .../skshaper/src/SkShaper_skunicode.cpp       |  152 ++
 .../skia/modules/skshaper/tests/BUILD.bazel   |   12 +
 .../modules/skshaper/tests/ShaperTest.cpp     |  274 +++
 .../skia/modules/skshaper/utils/BUILD.bazel   |   18 +
 .../modules/skshaper/utils/FactoryHelpers.h   |  116 ++
 .../skia/modules/skunicode/BUILD.bazel        |   68 +
 .../skia/modules/skunicode/BUILD.gn           |  220 +++
 .../modules/skunicode/include/BUILD.bazel     |   35 +
 .../modules/skunicode/include/SkUnicode.h     |  307 ++++
 .../skunicode/include/SkUnicode_client.h      |   25 +
 .../modules/skunicode/include/SkUnicode_icu.h |   18 +
 .../skunicode/include/SkUnicode_icu4x.h       |   19 +
 .../skunicode/include/SkUnicode_libgrapheme.h |   19 +
 .../skia/modules/skunicode/skunicode.gni      |   73 +
 .../skia/modules/skunicode/src/BUILD.bazel    |  103 ++
 .../skunicode/src/SkBidiFactory_icu_full.cpp  |   54 +
 .../skunicode/src/SkBidiFactory_icu_full.h    |   40 +
 .../src/SkBidiFactory_icu_subset.cpp          |   50 +
 .../skunicode/src/SkBidiFactory_icu_subset.h  |   40 +
 .../skia/modules/skunicode/src/SkUnicode.cpp  |   73 +
 .../skunicode/src/SkUnicode_client.cpp        |  263 +++
 .../skunicode/src/SkUnicode_hardcoded.cpp     |  130 ++
 .../skunicode/src/SkUnicode_hardcoded.h       |   29 +
 .../modules/skunicode/src/SkUnicode_icu.cpp   |  700 ++++++++
 .../modules/skunicode/src/SkUnicode_icu4x.cpp |  409 +++++
 .../skunicode/src/SkUnicode_icu_bidi.cpp      |  153 ++
 .../skunicode/src/SkUnicode_icu_bidi.h        |   56 +
 .../skunicode/src/SkUnicode_icu_builtin.cpp   |   67 +
 .../skunicode/src/SkUnicode_icu_runtime.cpp   |   86 +
 .../modules/skunicode/src/SkUnicode_icupriv.h |   73 +
 .../skunicode/src/SkUnicode_libgrapheme.cpp   |  303 ++++
 .../skia/modules/skunicode/tests/BUILD.bazel  |   12 +
 .../modules/skunicode/tests/SkUnicodeTest.cpp |  368 ++++
 .../ThirdParty/skia/modules/svg/BUILD.bazel   |   29 +
 Source/ThirdParty/skia/modules/svg/BUILD.gn   |   70 +
 .../skia/modules/svg/include/BUILD.bazel      |   64 +
 .../skia/modules/svg/include/SkSVGAttribute.h |  113 ++
 .../svg/include/SkSVGAttributeParser.h        |  164 ++
 .../skia/modules/svg/include/SkSVGCircle.h    |   43 +
 .../skia/modules/svg/include/SkSVGClipPath.h  |   35 +
 .../skia/modules/svg/include/SkSVGContainer.h |   45 +
 .../skia/modules/svg/include/SkSVGDOM.h       |  114 ++
 .../skia/modules/svg/include/SkSVGDefs.h      |   23 +
 .../skia/modules/svg/include/SkSVGEllipse.h   |   42 +
 .../skia/modules/svg/include/SkSVGFe.h        |   87 +
 .../skia/modules/svg/include/SkSVGFeBlend.h   |   45 +
 .../modules/svg/include/SkSVGFeColorMatrix.h  |   46 +
 .../svg/include/SkSVGFeComponentTransfer.h    |   75 +
 .../modules/svg/include/SkSVGFeComposite.h    |   46 +
 .../svg/include/SkSVGFeDisplacementMap.h      |   46 +
 .../skia/modules/svg/include/SkSVGFeFlood.h   |   32 +
 .../modules/svg/include/SkSVGFeGaussianBlur.h |   41 +
 .../skia/modules/svg/include/SkSVGFeImage.h   |   35 +
 .../modules/svg/include/SkSVGFeLightSource.h  |   89 +
 .../modules/svg/include/SkSVGFeLighting.h     |  121 ++
 .../skia/modules/svg/include/SkSVGFeMerge.h   |   55 +
 .../modules/svg/include/SkSVGFeMorphology.h   |   47 +
 .../skia/modules/svg/include/SkSVGFeOffset.h  |   35 +
 .../modules/svg/include/SkSVGFeTurbulence.h   |   40 +
 .../skia/modules/svg/include/SkSVGFilter.h    |   42 +
 .../modules/svg/include/SkSVGFilterContext.h  |   69 +
 .../skia/modules/svg/include/SkSVGG.h         |   23 +
 .../skia/modules/svg/include/SkSVGGradient.h  |   48 +
 .../svg/include/SkSVGHiddenContainer.h        |   23 +
 .../skia/modules/svg/include/SkSVGIDMapper.h  |   19 +
 .../skia/modules/svg/include/SkSVGImage.h     |   58 +
 .../skia/modules/svg/include/SkSVGLine.h      |   42 +
 .../modules/svg/include/SkSVGLinearGradient.h |   37 +
 .../skia/modules/svg/include/SkSVGMask.h      |   43 +
 .../skia/modules/svg/include/SkSVGNode.h      |  230 +++
 .../svg/include/SkSVGOpenTypeSVGDecoder.h     |   32 +
 .../skia/modules/svg/include/SkSVGPath.h      |   36 +
 .../skia/modules/svg/include/SkSVGPattern.h   |   55 +
 .../skia/modules/svg/include/SkSVGPoly.h      |   45 +
 .../modules/svg/include/SkSVGRadialGradient.h |   38 +
 .../skia/modules/svg/include/SkSVGRect.h      |   46 +
 .../modules/svg/include/SkSVGRenderContext.h  |  217 +++
 .../skia/modules/svg/include/SkSVGSVG.h       |   54 +
 .../skia/modules/svg/include/SkSVGShape.h     |   33 +
 .../skia/modules/svg/include/SkSVGStop.h      |   35 +
 .../skia/modules/svg/include/SkSVGText.h      |  122 ++
 .../svg/include/SkSVGTransformableNode.h      |   36 +
 .../skia/modules/svg/include/SkSVGTypes.h     |  740 ++++++++
 .../skia/modules/svg/include/SkSVGUse.h       |   42 +
 .../skia/modules/svg/include/SkSVGValue.h     |   85 +
 .../skia/modules/svg/src/BUILD.bazel          |   69 +
 .../skia/modules/svg/src/SkSVGAttribute.cpp   |   48 +
 .../modules/svg/src/SkSVGAttributeParser.cpp  | 1175 +++++++++++++
 .../skia/modules/svg/src/SkSVGCircle.cpp      |   54 +
 .../skia/modules/svg/src/SkSVGClipPath.cpp    |   29 +
 .../skia/modules/svg/src/SkSVGContainer.cpp   |   52 +
 .../skia/modules/svg/src/SkSVGDOM.cpp         |  510 ++++++
 .../skia/modules/svg/src/SkSVGEllipse.cpp     |   51 +
 .../skia/modules/svg/src/SkSVGFe.cpp          |  125 ++
 .../skia/modules/svg/src/SkSVGFeBlend.cpp     |   61 +
 .../modules/svg/src/SkSVGFeColorMatrix.cpp    |  109 ++
 .../svg/src/SkSVGFeComponentTransfer.cpp      |  172 ++
 .../skia/modules/svg/src/SkSVGFeComposite.cpp |   74 +
 .../svg/src/SkSVGFeDisplacementMap.cpp        |   68 +
 .../skia/modules/svg/src/SkSVGFeFlood.cpp     |   31 +
 .../modules/svg/src/SkSVGFeGaussianBlur.cpp   |   43 +
 .../skia/modules/svg/src/SkSVGFeImage.cpp     |   44 +
 .../modules/svg/src/SkSVGFeLightSource.cpp    |   49 +
 .../skia/modules/svg/src/SkSVGFeLighting.cpp  |  190 ++
 .../skia/modules/svg/src/SkSVGFeMerge.cpp     |   46 +
 .../modules/svg/src/SkSVGFeMorphology.cpp     |   61 +
 .../skia/modules/svg/src/SkSVGFeOffset.cpp    |   29 +
 .../modules/svg/src/SkSVGFeTurbulence.cpp     |   78 +
 .../skia/modules/svg/src/SkSVGFilter.cpp      |   70 +
 .../modules/svg/src/SkSVGFilterContext.cpp    |  155 ++
 .../skia/modules/svg/src/SkSVGGradient.cpp    |  118 ++
 .../skia/modules/svg/src/SkSVGImage.cpp       |  100 ++
 .../skia/modules/svg/src/SkSVGLine.cpp        |   47 +
 .../modules/svg/src/SkSVGLinearGradient.cpp   |   41 +
 .../skia/modules/svg/src/SkSVGMask.cpp        |   66 +
 .../skia/modules/svg/src/SkSVGNode.cpp        |  184 ++
 .../svg/src/SkSVGOpenTypeSVGDecoder.cpp       |  154 ++
 .../skia/modules/svg/src/SkSVGPath.cpp        |   45 +
 .../skia/modules/svg/src/SkSVGPattern.cpp     |  123 ++
 .../skia/modules/svg/src/SkSVGPoly.cpp        |   51 +
 .../modules/svg/src/SkSVGRadialGradient.cpp   |   53 +
 .../skia/modules/svg/src/SkSVGRect.cpp        |   95 +
 .../skia/modules/svg/src/SkSVGRectPriv.h      |   22 +
 .../modules/svg/src/SkSVGRenderContext.cpp    |  519 ++++++
 .../skia/modules/svg/src/SkSVGSVG.cpp         |  111 ++
 .../skia/modules/svg/src/SkSVGShape.cpp       |   31 +
 .../skia/modules/svg/src/SkSVGStop.cpp        |   18 +
 .../skia/modules/svg/src/SkSVGText.cpp        |  715 ++++++++
 .../skia/modules/svg/src/SkSVGTextPriv.h      |  212 +++
 .../svg/src/SkSVGTransformableNode.cpp        |   47 +
 .../skia/modules/svg/src/SkSVGUse.cpp         |   75 +
 .../skia/modules/svg/src/SkSVGValue.cpp       |    7 +
 Source/ThirdParty/skia/modules/svg/svg.gni    |  115 ++
 .../skia/modules/svg/tests/BUILD.bazel        |    5 +
 .../skia/modules/svg/tests/Filters.cpp        |   34 +
 .../skia/modules/svg/tests/Text.cpp           |  194 +++
 .../skia/modules/svg/utils/BUILD.bazel        |    5 +
 .../skia/modules/svg/utils/SvgTool.cpp        |  102 ++
 162 files changed, 19062 insertions(+)
 create mode 100644 Source/ThirdParty/skia/modules/skresources/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skresources/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skresources/include/SkResources.h
 create mode 100644 Source/ThirdParty/skia/modules/skresources/skresources.gni
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h
 create mode 100644 Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/include/SkShaper.h
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/include/SkShaper_coretext.h
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/include/SkShaper_factory.h
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/include/SkShaper_harfbuzz.h
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/include/SkShaper_skunicode.h
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/skshaper.gni
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/SkShaper.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/SkShaper_coretext.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/SkShaper_factory.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/SkShaper_harfbuzz.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/SkShaper_primitive.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/src/SkShaper_skunicode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/tests/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/tests/ShaperTest.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/utils/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skshaper/utils/FactoryHelpers.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/skunicode.gni
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/BUILD.gn
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGG.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGText.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/svg.gni
 create mode 100644 Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/tests/Filters.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/tests/Text.cpp
 create mode 100644 Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel
 create mode 100644 Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp

diff --git a/Source/ThirdParty/skia/modules/skresources/BUILD.bazel b/Source/ThirdParty/skia/modules/skresources/BUILD.bazel
new file mode 100644
index 00000000..5cf92fe3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/BUILD.bazel
@@ -0,0 +1,31 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "legacy_skresources",
+    srcs = ["//modules/skresources/src:srcs"],
+    hdrs = ["//modules/skresources/include:hdrs"],
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//:skia_internal",
+    ],
+)
+
+skia_cc_library(
+    name = "skresources",
+    srcs = ["//modules/skresources/src:srcs"],
+    hdrs = ["//modules/skresources/include:hdrs"],
+    features = ["layering_check"],
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//:core",
+        "//src/base",
+        "//src/codec:codec_support_priv",
+        "//src/core:core_priv",
+    ],
+)
diff --git a/Source/ThirdParty/skia/modules/skresources/BUILD.gn b/Source/ThirdParty/skia/modules/skresources/BUILD.gn
new file mode 100644
index 00000000..12b3d5b5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/BUILD.gn
@@ -0,0 +1,25 @@
+# Copyright 2019 Google LLC
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+
+config("public_config") {
+  include_dirs = [ "include" ]
+}
+
+static_library("skresources") {
+  import("skresources.gni")
+  public_configs = [ ":public_config" ]
+  public = skia_skresources_public
+  sources = skia_skresources_sources
+  configs += [
+    "../../:skia_private",
+    "../../:skia_library",
+  ]
+  deps = [
+    "../..:skia",
+    "../../experimental/ffmpeg:video_decoder",
+  ]
+}
diff --git a/Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel b/Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel
new file mode 100644
index 00000000..22c3d7b5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/include/BUILD.bazel
@@ -0,0 +1,13 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "hdrs",
+    srcs = ["SkResources.h"],
+    visibility = ["//modules/skresources:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skresources/include/SkResources.h b/Source/ThirdParty/skia/modules/skresources/include/SkResources.h
new file mode 100644
index 00000000..3a465efb
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/include/SkResources.h
@@ -0,0 +1,289 @@
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkResources_DEFINED
+#define SkResources_DEFINED
+
+#include "include/core/SkData.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSamplingOptions.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypeface.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkMutex.h"
+#include "src/core/SkTHash.h"
+
+#include <memory>
+
+class SkAnimCodecPlayer;
+class SkCodec;
+class SkImage;
+
+namespace skresources {
+
+/**
+ * Image asset proxy interface.
+ */
+class SK_API ImageAsset : public SkRefCnt {
+public:
+    /**
+     * Returns true if the image asset is animated.
+     */
+    virtual bool isMultiFrame() = 0;
+
+    /**
+     * DEPRECATED: override getFrameData() instead.
+     *
+     * Returns the SkImage for a given frame.
+     *
+     * If the image asset is static, getFrame() is only called once, at animation load time.
+     * Otherwise, this gets invoked every time the animation time is adjusted (on every seek).
+     *
+     * Embedders should cache and serve the same SkImage whenever possible, for efficiency.
+     *
+     * @param t   Frame time code, in seconds, relative to the image layer timeline origin
+     *            (in-point).
+     */
+    virtual sk_sp<SkImage> getFrame(float t);
+
+    // Describes how the frame image is to be scaled to the animation-declared asset size.
+    enum class SizeFit {
+        // See SkMatrix::ScaleToFit
+        kFill   = SkMatrix::kFill_ScaleToFit,
+        kStart  = SkMatrix::kStart_ScaleToFit,
+        kCenter = SkMatrix::kCenter_ScaleToFit,
+        kEnd    = SkMatrix::kEnd_ScaleToFit,
+
+        // No scaling.
+        kNone,
+    };
+
+    struct FrameData {
+        // SkImage payload.
+        sk_sp<SkImage>    image;
+        // Resampling parameters.
+        SkSamplingOptions sampling;
+        // Additional image transform to be applied before AE scaling rules.
+        SkMatrix          matrix = SkMatrix::I();
+        // Strategy for image size -> AE asset size scaling.
+        SizeFit           scaling = SizeFit::kCenter;
+    };
+
+    /**
+     * Returns the payload for a given frame.
+     *
+     * If the image asset is static, getFrameData() is only called once, at animation load time.
+     * Otherwise, this gets invoked every time the animation time is adjusted (on every seek).
+     *
+     * Embedders should cache and serve the same SkImage whenever possible, for efficiency.
+     *
+     * @param t   Frame time code, in seconds, relative to the image layer timeline origin
+     *            (in-point).
+     */
+    virtual FrameData getFrameData(float t);
+};
+
+enum class ImageDecodeStrategy {
+    // Images are decoded on-the-fly, at rasterization time.
+    // Large images may cause jank as decoding is expensive (and can thrash internal caches).
+    kLazyDecode,
+    // Force-decode all images upfront, at the cost of potentially more RAM and slower
+    // animation build times.
+    kPreDecode,
+};
+
+class MultiFrameImageAsset final : public ImageAsset {
+public:
+    // Clients must call SkCodec::Register() to load the required decoding image codecs before
+    // calling Make. For example:
+    //     SkCodec::Register(SkPngDecoder::Decoder());
+    static sk_sp<MultiFrameImageAsset> Make(sk_sp<SkData>,
+                                            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode);
+    // If the client has already decoded the data, they can use this constructor.
+    static sk_sp<MultiFrameImageAsset> Make(std::unique_ptr<SkCodec>,
+                                            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode);
+
+
+    bool isMultiFrame() override;
+
+    sk_sp<SkImage> getFrame(float t) override;
+
+private:
+    explicit MultiFrameImageAsset(std::unique_ptr<SkAnimCodecPlayer>, ImageDecodeStrategy);
+
+    sk_sp<SkImage> generateFrame(float t);
+
+    std::unique_ptr<SkAnimCodecPlayer> fPlayer;
+    sk_sp<SkImage>                     fCachedFrame;
+    ImageDecodeStrategy fStrategy;
+
+    using INHERITED = ImageAsset;
+};
+
+/**
+ * External track (e.g. audio playback) interface.
+ *
+ * Used to wrap data payload and playback controllers.
+ */
+class ExternalTrackAsset : public SkRefCnt {
+public:
+    /**
+     * Playback control callback, emitted for each corresponding Animation::seek().
+     *
+     * @param t  Frame time code, in seconds, relative to the layer's timeline origin
+     *           (in-point).
+     *
+     * Negative |t| values are used to signal off state (stop playback outside layer span).
+     */
+    virtual void seek(float t) = 0;
+};
+
+/**
+ * ResourceProvider is an interface that lets rich-content modules defer loading of external
+ * resources (images, fonts, etc.) to embedding clients.
+ */
+class SK_API ResourceProvider : public SkRefCnt {
+public:
+    /**
+     * Load a generic resource (currently only nested animations) specified by |path| + |name|,
+     * and return as an SkData.
+     */
+    virtual sk_sp<SkData> load(const char[] /* resource_path */,
+                               const char[] /* resource_name */) const {
+        return nullptr;
+    }
+
+    /**
+     * Load an image asset specified by |path| + |name|, and returns the corresponding
+     * ImageAsset proxy.
+     */
+    virtual sk_sp<ImageAsset> loadImageAsset(const char[] /* resource_path */,
+                                             const char[] /* resource_name */,
+                                             const char[] /* resource_id   */) const {
+        return nullptr;
+    }
+
+    /**
+     * Load an external audio track specified by |path|/|name|/|id|.
+     */
+    virtual sk_sp<ExternalTrackAsset> loadAudioAsset(const char[] /* resource_path */,
+                                                     const char[] /* resource_name */,
+                                                     const char[] /* resource_id   */) {
+        return nullptr;
+    }
+
+    /**
+     * DEPRECATED: implement loadTypeface() instead.
+     *
+     * Load an external font and return as SkData.
+     *
+     * @param name  font name    ("fName" Lottie property)
+     * @param url   web font URL ("fPath" Lottie property)
+     *
+     * -- Note --
+     *
+     *   This mechanism assumes monolithic fonts (single data blob).  Some web font providers may
+     *   serve multiple font blobs, segmented for various unicode ranges, depending on user agent
+     *   capabilities (woff, woff2).  In that case, the embedder would need to advertise no user
+     *   agent capabilities when fetching the URL, in order to receive full font data.
+     */
+    virtual sk_sp<SkData> loadFont(const char[] /* name */,
+                                   const char[] /* url  */) const {
+        return nullptr;
+    }
+
+    /**
+     * Load an external font and return as SkTypeface.
+     *
+     * @param name  font name
+     * @param url   web font URL
+     */
+    virtual sk_sp<SkTypeface> loadTypeface(const char[] /* name */,
+                                           const char[] /* url  */) const {
+        return nullptr;
+    }
+};
+
+class FileResourceProvider final : public ResourceProvider {
+public:
+    // To decode images, clients must call SkCodecs::Register() before calling Make.
+    static sk_sp<FileResourceProvider> Make(SkString base_dir,
+                                            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode);
+
+    sk_sp<SkData> load(const char resource_path[], const char resource_name[]) const override;
+
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+
+private:
+    FileResourceProvider(SkString, ImageDecodeStrategy);
+
+    const SkString fDir;
+    const ImageDecodeStrategy fStrategy;
+
+    using INHERITED = ResourceProvider;
+};
+
+class ResourceProviderProxyBase : public ResourceProvider {
+protected:
+    explicit ResourceProviderProxyBase(sk_sp<ResourceProvider>);
+
+    sk_sp<SkData> load(const char[], const char[]) const override;
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+    sk_sp<SkTypeface> loadTypeface(const char[], const char[]) const override;
+    sk_sp<SkData> loadFont(const char[], const char[]) const override;
+    sk_sp<ExternalTrackAsset> loadAudioAsset(const char[], const char[], const char[]) override;
+
+protected:
+    const sk_sp<ResourceProvider> fProxy;
+};
+
+class SK_API CachingResourceProvider final : public ResourceProviderProxyBase {
+public:
+    static sk_sp<CachingResourceProvider> Make(sk_sp<ResourceProvider> rp) {
+        return rp ? sk_sp<CachingResourceProvider>(new CachingResourceProvider(std::move(rp)))
+                  : nullptr;
+    }
+
+private:
+    explicit CachingResourceProvider(sk_sp<ResourceProvider>);
+
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+
+    mutable SkMutex                                             fMutex;
+    mutable skia_private::THashMap<SkString, sk_sp<ImageAsset>> fImageCache;
+
+    using INHERITED = ResourceProviderProxyBase;
+};
+
+class SK_API DataURIResourceProviderProxy final : public ResourceProviderProxyBase {
+public:
+    // If font data is supplied via base64 encoding, this needs a provided SkFontMgr to process
+    // that font data into an SkTypeface. To decode images, clients must call SkCodecs::Register()
+    // before calling Make.
+    static sk_sp<DataURIResourceProviderProxy> Make(
+            sk_sp<ResourceProvider> rp,
+            ImageDecodeStrategy = ImageDecodeStrategy::kLazyDecode,
+            sk_sp<const SkFontMgr> fontMgr = nullptr);
+
+private:
+    DataURIResourceProviderProxy(sk_sp<ResourceProvider>,
+                                 ImageDecodeStrategy,
+                                 sk_sp<const SkFontMgr> fontMgr);
+
+    sk_sp<ImageAsset> loadImageAsset(const char[], const char[], const char[]) const override;
+    sk_sp<SkTypeface> loadTypeface(const char[], const char[]) const override;
+
+    const ImageDecodeStrategy fStrategy;
+    sk_sp<const SkFontMgr> fFontMgr;
+
+    using INHERITED = ResourceProviderProxyBase;
+};
+
+} // namespace skresources
+
+#endif // SkResources_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skresources/skresources.gni b/Source/ThirdParty/skia/modules/skresources/skresources.gni
new file mode 100644
index 00000000..e0ffe26e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/skresources.gni
@@ -0,0 +1,20 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/skresources/include/BUILD.bazel
+#   //modules/skresources/src/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# Generated by Bazel rule //modules/skresources/include:hdrs
+skia_skresources_public = [ "$_modules/skresources/include/SkResources.h" ]
+
+# Generated by Bazel rule //modules/skresources/src:srcs
+skia_skresources_sources = [
+  "$_modules/skresources/src/SkAnimCodecPlayer.cpp",
+  "$_modules/skresources/src/SkAnimCodecPlayer.h",
+  "$_modules/skresources/src/SkResources.cpp",
+]
diff --git a/Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel b/Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel
new file mode 100644
index 00000000..0ce58dc6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/BUILD.bazel
@@ -0,0 +1,17 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "srcs",
+    srcs = [
+        "SkAnimCodecPlayer.cpp",
+        "SkAnimCodecPlayer.h",
+        "SkResources.cpp",
+    ],
+    visibility = ["//modules/skresources:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp
new file mode 100644
index 00000000..f562caaf
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2018 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/skresources/src/SkAnimCodecPlayer.h"
+
+#include "include/codec/SkCodec.h"
+#include "include/codec/SkEncodedOrigin.h"
+#include "include/core/SkAlphaType.h"
+#include "include/core/SkBlendMode.h"
+#include "include/core/SkCanvas.h"
+#include "include/core/SkData.h"
+#include "include/core/SkImage.h"
+#include "include/core/SkImageInfo.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkPaint.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSamplingOptions.h"
+#include "include/core/SkSize.h"
+#include "include/core/SkTypes.h"
+#include "src/codec/SkCodecImageGenerator.h"
+
+#include <algorithm>
+#include <cstddef>
+#include <memory>
+#include <utility>
+#include <vector>
+
+SkAnimCodecPlayer::SkAnimCodecPlayer(std::unique_ptr<SkCodec> codec) : fCodec(std::move(codec)) {
+    fImageInfo = fCodec->getInfo();
+    fFrameInfos = fCodec->getFrameInfo();
+    fImages.resize(fFrameInfos.size());
+
+    // change the interpretation of fDuration to a end-time for that frame
+    size_t dur = 0;
+    for (auto& f : fFrameInfos) {
+        dur += f.fDuration;
+        f.fDuration = dur;
+    }
+    fTotalDuration = dur;
+
+    if (!fTotalDuration) {
+        // Static image -- may or may not have returned a single frame info.
+        fFrameInfos.clear();
+        fImages.clear();
+        fImages.push_back(SkImages::DeferredFromGenerator(
+                SkCodecImageGenerator::MakeFromCodec(std::move(fCodec))));
+    }
+}
+
+SkAnimCodecPlayer::~SkAnimCodecPlayer() {}
+
+SkISize SkAnimCodecPlayer::dimensions() const {
+    if (!fCodec) {
+        auto image = fImages.front();
+        return image ? image->dimensions() : SkISize::MakeEmpty();
+    }
+    if (SkEncodedOriginSwapsWidthHeight(fCodec->getOrigin())) {
+        return { fImageInfo.height(), fImageInfo.width() };
+    }
+    return { fImageInfo.width(), fImageInfo.height() };
+}
+
+sk_sp<SkImage> SkAnimCodecPlayer::getFrameAt(int index) {
+    SkASSERT((unsigned)index < fFrameInfos.size());
+
+    if (fImages[index]) {
+        return fImages[index];
+    }
+
+    size_t rb = fImageInfo.minRowBytes();
+    size_t size = fImageInfo.computeByteSize(rb);
+    auto data = SkData::MakeUninitialized(size);
+
+    SkCodec::Options opts;
+    opts.fFrameIndex = index;
+
+    const auto origin = fCodec->getOrigin();
+    const auto orientedDims = this->dimensions();
+    const auto originMatrix = SkEncodedOriginToMatrix(origin, orientedDims.width(),
+                                                              orientedDims.height());
+
+    SkPaint paint;
+    paint.setBlendMode(SkBlendMode::kSrc);
+
+    auto imageInfo = fImageInfo;
+    if (fFrameInfos[index].fAlphaType != kOpaque_SkAlphaType && imageInfo.isOpaque()) {
+        imageInfo = imageInfo.makeAlphaType(kPremul_SkAlphaType);
+    }
+    const int requiredFrame = fFrameInfos[index].fRequiredFrame;
+    if (requiredFrame != SkCodec::kNoFrame && fImages[requiredFrame]) {
+        auto requiredImage = fImages[requiredFrame];
+        auto canvas = SkCanvas::MakeRasterDirect(imageInfo, data->writable_data(), rb);
+        if (origin != kDefault_SkEncodedOrigin) {
+            // The required frame is stored after applying the origin. Undo that,
+            // because the codec decodes prior to applying the origin.
+            // FIXME: Another approach would be to decode the frame's delta on top
+            // of transparent black, and then draw that through the origin matrix
+            // onto the required frame. To do that, SkCodec needs to expose the
+            // rectangle of the delta and the blend mode, so we can handle
+            // kRestoreBGColor frames and Blend::kSrc.
+            SkMatrix inverse;
+            SkAssertResult(originMatrix.invert(&inverse));
+            canvas->concat(inverse);
+        }
+        canvas->drawImage(requiredImage, 0, 0, SkSamplingOptions(), &paint);
+        opts.fPriorFrame = requiredFrame;
+    }
+
+    if (SkCodec::kSuccess != fCodec->getPixels(imageInfo, data->writable_data(), rb, &opts)) {
+        return nullptr;
+    }
+
+    auto image = SkImages::RasterFromData(imageInfo, std::move(data), rb);
+    if (origin != kDefault_SkEncodedOrigin) {
+        imageInfo = imageInfo.makeDimensions(orientedDims);
+        rb = imageInfo.minRowBytes();
+        size = imageInfo.computeByteSize(rb);
+        data = SkData::MakeUninitialized(size);
+        auto canvas = SkCanvas::MakeRasterDirect(imageInfo, data->writable_data(), rb);
+        canvas->concat(originMatrix);
+        canvas->drawImage(image, 0, 0, SkSamplingOptions(), &paint);
+        image = SkImages::RasterFromData(imageInfo, std::move(data), rb);
+    }
+    return fImages[index] = image;
+}
+
+sk_sp<SkImage> SkAnimCodecPlayer::getFrame() {
+    SkASSERT(fTotalDuration > 0 || fImages.size() == 1);
+
+    return fTotalDuration > 0
+        ? this->getFrameAt(fCurrIndex)
+        : fImages.front();
+}
+
+bool SkAnimCodecPlayer::seek(uint32_t msec) {
+    if (!fTotalDuration) {
+        return false;
+    }
+
+    msec %= fTotalDuration;
+
+    auto lower = std::lower_bound(fFrameInfos.begin(), fFrameInfos.end(), msec,
+                                  [](const SkCodec::FrameInfo& info, uint32_t msec) {
+                                      return (uint32_t)info.fDuration <= msec;
+                                  });
+    int prevIndex = fCurrIndex;
+    fCurrIndex = lower - fFrameInfos.begin();
+    return fCurrIndex != prevIndex;
+}
+
+
diff --git a/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h
new file mode 100644
index 00000000..f4729aa3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/SkAnimCodecPlayer.h
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2018 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkAnimCodecPlayer_DEFINED
+#define SkAnimCodecPlayer_DEFINED
+
+#include "include/codec/SkCodec.h"
+#include "include/core/SkImageInfo.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSize.h"
+
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+class SkImage;
+
+class SkAnimCodecPlayer {
+public:
+    SkAnimCodecPlayer(std::unique_ptr<SkCodec> codec);
+    ~SkAnimCodecPlayer();
+
+    /**
+     *  Returns the current frame of the animation. This defaults to the first frame for
+     *  animated codecs (i.e. msec = 0). Calling this multiple times (without calling seek())
+     *  will always return the same image object (or null if there was an error).
+     */
+    sk_sp<SkImage> getFrame();
+
+    /**
+     *  Return the size of the image(s) that will be returned by getFrame().
+     */
+    SkISize dimensions() const;
+
+    /**
+     *  Returns the total duration of the animation in milliseconds. Returns 0 for a single-frame
+     *  image.
+     */
+    uint32_t duration() const { return fTotalDuration; }
+
+    /**
+     *  Finds the closest frame associated with the time code (in milliseconds) and sets that
+     *  to be the current frame (call getFrame() to retrieve that image).
+     *  Returns true iff this call to seek() changed the "current frame" for the animation.
+     *  Thus if seek() returns false, then getFrame() will return the same image as it did
+     *  before this call to seek().
+     */
+    bool seek(uint32_t msec);
+
+
+private:
+    std::unique_ptr<SkCodec>        fCodec;
+    SkImageInfo                     fImageInfo;
+    std::vector<SkCodec::FrameInfo> fFrameInfos;
+    std::vector<sk_sp<SkImage> >    fImages;
+    int                             fCurrIndex = 0;
+    uint32_t                        fTotalDuration;
+
+    sk_sp<SkImage> getFrameAt(int index);
+};
+
+#endif
+
diff --git a/Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp b/Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp
new file mode 100644
index 00000000..166639df
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skresources/src/SkResources.cpp
@@ -0,0 +1,337 @@
+/*
+ * Copyright 2019 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/skresources/include/SkResources.h"
+
+#include "include/codec/SkCodec.h"
+#include "include/core/SkBitmap.h"
+#include "include/core/SkData.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkImage.h"
+#include "include/private/base/SkTPin.h"
+#include "modules/skresources/src/SkAnimCodecPlayer.h"
+#include "src/base/SkBase64.h"
+#include "src/core/SkOSFile.h"
+#include "src/utils/SkOSPath.h"
+
+#include <cmath>
+
+#if defined(HAVE_VIDEO_DECODER)
+    #include "experimental/ffmpeg/SkVideoDecoder.h"
+    #include "include/core/SkStream.h"
+#endif
+
+namespace skresources {
+namespace  {
+
+#if defined(HAVE_VIDEO_DECODER)
+
+class VideoAsset final : public ImageAsset {
+public:
+    static sk_sp<VideoAsset> Make(sk_sp<SkData> data) {
+        auto decoder = std::make_unique<SkVideoDecoder>();
+
+        if (!decoder->loadStream(SkMemoryStream::Make(std::move(data))) ||
+            decoder->duration() <= 0) {
+            return nullptr;
+        }
+
+        return sk_sp<VideoAsset>(new VideoAsset(std::move(decoder)));
+    }
+
+private:
+    explicit VideoAsset(std::unique_ptr<SkVideoDecoder> decoder)
+        : fDecoder(std::move(decoder)) {
+    }
+
+    bool isMultiFrame() override { return true; }
+
+    // Each frame has a presentation timestamp
+    //   => the timespan for frame N is [stamp_N .. stamp_N+1)
+    //   => we use a two-frame sliding window to track the current interval.
+    void advance() {
+        fWindow[0] = std::move(fWindow[1]);
+        fWindow[1].frame = fDecoder->nextImage(&fWindow[1].stamp);
+        fEof = !fWindow[1].frame;
+    }
+
+    sk_sp<SkImage> getFrame(float t_float) override {
+        const auto t = SkTPin(static_cast<double>(t_float), 0.0, fDecoder->duration());
+
+        if (t < fWindow[0].stamp) {
+            // seeking back requires a full rewind
+            fDecoder->rewind();
+            fWindow[0].stamp = fWindow[1].stamp = 0;
+            fEof = 0;
+        }
+
+        while (!fEof && t >= fWindow[1].stamp) {
+            this->advance();
+        }
+
+        SkASSERT(fWindow[0].stamp <= t && (fEof || t < fWindow[1].stamp));
+
+        return fWindow[0].frame;
+    }
+
+    const std::unique_ptr<SkVideoDecoder> fDecoder;
+
+    struct FrameRec {
+        sk_sp<SkImage> frame;
+        double         stamp = 0;
+    };
+
+    FrameRec fWindow[2];
+    bool     fEof = false;
+};
+
+#endif // defined(HAVE_VIDEO_DECODER)
+
+} // namespace
+
+sk_sp<SkImage> ImageAsset::getFrame(float t) {
+    return nullptr;
+}
+
+ImageAsset::FrameData ImageAsset::getFrameData(float t) {
+    // legacy behavior
+    return {
+        this->getFrame(t),
+        SkSamplingOptions(SkFilterMode::kLinear, SkMipmapMode::kNearest),
+        SkMatrix::I(),
+        SizeFit::kCenter,
+    };
+}
+
+sk_sp<MultiFrameImageAsset> MultiFrameImageAsset::Make(sk_sp<SkData> data, ImageDecodeStrategy strat) {
+    if (auto codec = SkCodec::MakeFromData(std::move(data))) {
+        return sk_sp<MultiFrameImageAsset>(new MultiFrameImageAsset(
+                std::make_unique<SkAnimCodecPlayer>(std::move(codec)), strat));
+    }
+
+    return nullptr;
+}
+
+sk_sp<MultiFrameImageAsset> MultiFrameImageAsset::Make(std::unique_ptr<SkCodec> codec, ImageDecodeStrategy strat) {
+    SkASSERT(codec);
+    return sk_sp<MultiFrameImageAsset>(new MultiFrameImageAsset(
+            std::make_unique<SkAnimCodecPlayer>(std::move(codec)), strat));
+}
+
+MultiFrameImageAsset::MultiFrameImageAsset(std::unique_ptr<SkAnimCodecPlayer> player,
+                                           ImageDecodeStrategy strat)
+        : fPlayer(std::move(player)), fStrategy(strat) {
+    SkASSERT(fPlayer);
+}
+
+bool MultiFrameImageAsset::isMultiFrame() {
+    return fPlayer->duration() > 0;
+}
+
+sk_sp<SkImage> MultiFrameImageAsset::generateFrame(float t) {
+    auto decode = [](sk_sp<SkImage> image) {
+        SkASSERT(image->isLazyGenerated());
+
+        static constexpr size_t kMaxArea = 2048 * 2048;
+        const auto image_area = SkToSizeT(image->width() * image->height());
+
+        if (image_area > kMaxArea) {
+            // When the image is too large, decode and scale down to a reasonable size.
+            const auto scale = std::sqrt(static_cast<float>(kMaxArea) / image_area);
+            const auto info  = SkImageInfo::MakeN32Premul(scale * image->width(),
+                                                          scale * image->height());
+            SkBitmap bm;
+            if (bm.tryAllocPixels(info, info.minRowBytes()) &&
+                    image->scalePixels(bm.pixmap(),
+                                       SkSamplingOptions(SkFilterMode::kLinear,
+                                                         SkMipmapMode::kNearest),
+                                       SkImage::kDisallow_CachingHint)) {
+                image = bm.asImage();
+            }
+        } else {
+            // When the image size is OK, just force-decode.
+            image = image->makeRasterImage();
+        }
+
+        return image;
+    };
+
+    fPlayer->seek(static_cast<uint32_t>(t * 1000));
+    auto frame = fPlayer->getFrame();
+
+    if (fStrategy == ImageDecodeStrategy::kPreDecode && frame && frame->isLazyGenerated()) {
+        // The multi-frame decoder should never return lazy images.
+        SkASSERT(!this->isMultiFrame());
+        frame = decode(std::move(frame));
+    }
+
+    return frame;
+}
+
+sk_sp<SkImage> MultiFrameImageAsset::getFrame(float t) {
+    // For static images we can reuse the cached frame
+    // (which includes the optional pre-decode step).
+    if (!fCachedFrame || this->isMultiFrame()) {
+        fCachedFrame = this->generateFrame(t);
+    }
+
+    return fCachedFrame;
+}
+
+sk_sp<FileResourceProvider> FileResourceProvider::Make(SkString base_dir, ImageDecodeStrategy strat) {
+    return sk_isdir(base_dir.c_str()) ? sk_sp<FileResourceProvider>(new FileResourceProvider(
+                                                std::move(base_dir), strat))
+                                      : nullptr;
+}
+
+FileResourceProvider::FileResourceProvider(SkString base_dir, ImageDecodeStrategy strat)
+        : fDir(std::move(base_dir)), fStrategy(strat) {}
+
+sk_sp<SkData> FileResourceProvider::load(const char resource_path[],
+                                         const char resource_name[]) const {
+    const auto full_dir  = SkOSPath::Join(fDir.c_str()    , resource_path),
+               full_path = SkOSPath::Join(full_dir.c_str(), resource_name);
+    return SkData::MakeFromFileName(full_path.c_str());
+}
+
+sk_sp<ImageAsset> FileResourceProvider::loadImageAsset(const char resource_path[],
+                                                       const char resource_name[],
+                                                       const char[]) const {
+    auto data = this->load(resource_path, resource_name);
+
+    if (auto image = MultiFrameImageAsset::Make(data, fStrategy)) {
+        return std::move(image);
+    }
+
+#if defined(HAVE_VIDEO_DECODER)
+    if (auto video = VideoAsset::Make(data)) {
+        return std::move(video);
+    }
+#endif
+
+    return nullptr;
+}
+
+ResourceProviderProxyBase::ResourceProviderProxyBase(sk_sp<ResourceProvider> rp)
+    : fProxy(std::move(rp)) {}
+
+sk_sp<SkData> ResourceProviderProxyBase::load(const char resource_path[],
+                                              const char resource_name[]) const {
+    return fProxy ? fProxy->load(resource_path, resource_name)
+                  : nullptr;
+}
+
+sk_sp<ImageAsset> ResourceProviderProxyBase::loadImageAsset(const char rpath[],
+                                                            const char rname[],
+                                                            const char rid[]) const {
+    return fProxy ? fProxy->loadImageAsset(rpath, rname, rid)
+                  : nullptr;
+}
+
+sk_sp<SkTypeface> ResourceProviderProxyBase::loadTypeface(const char name[],
+                                                          const char url[]) const {
+    return fProxy ? fProxy->loadTypeface(name, url)
+                  : nullptr;
+}
+
+sk_sp<SkData> ResourceProviderProxyBase::loadFont(const char name[], const char url[]) const {
+    return fProxy ? fProxy->loadFont(name, url)
+                  : nullptr;
+}
+
+sk_sp<ExternalTrackAsset> ResourceProviderProxyBase::loadAudioAsset(const char path[],
+                                                                    const char name[],
+                                                                    const char id[]) {
+    return fProxy ? fProxy->loadAudioAsset(path, name, id)
+                  : nullptr;
+}
+
+CachingResourceProvider::CachingResourceProvider(sk_sp<ResourceProvider> rp)
+    : INHERITED(std::move(rp)) {}
+
+sk_sp<ImageAsset> CachingResourceProvider::loadImageAsset(const char resource_path[],
+                                                          const char resource_name[],
+                                                          const char resource_id[]) const {
+    SkAutoMutexExclusive amx(fMutex);
+
+    const SkString key(resource_id);
+    if (const auto* asset = fImageCache.find(key)) {
+        return *asset;
+    }
+
+    auto asset = this->INHERITED::loadImageAsset(resource_path, resource_name, resource_id);
+    fImageCache.set(key, asset);
+
+    return asset;
+}
+
+sk_sp<DataURIResourceProviderProxy> DataURIResourceProviderProxy::Make(sk_sp<ResourceProvider> rp,
+                                                                       ImageDecodeStrategy strat,
+                                                                       sk_sp<const SkFontMgr> mgr) {
+    return sk_sp<DataURIResourceProviderProxy>(
+            new DataURIResourceProviderProxy(std::move(rp), strat, std::move(mgr)));
+}
+
+DataURIResourceProviderProxy::DataURIResourceProviderProxy(sk_sp<ResourceProvider> rp,
+                                                           ImageDecodeStrategy strat,
+                                                           sk_sp<const SkFontMgr> mgr)
+        : INHERITED(std::move(rp)), fStrategy(strat), fFontMgr(std::move(mgr)) {}
+
+static sk_sp<SkData> decode_datauri(const char prefix[], const char uri[]) {
+    // We only handle B64 encoded image dataURIs: data:image/<type>;base64,<data>
+    // (https://en.wikipedia.org/wiki/Data_URI_scheme)
+    static constexpr char kDataURIEncodingStr[] = ";base64,";
+
+    const size_t prefixLen = strlen(prefix);
+    if (strncmp(uri, prefix, prefixLen) != 0) {
+        return nullptr;
+    }
+
+    const char* encoding = strstr(uri + prefixLen, kDataURIEncodingStr);
+    if (!encoding) {
+        return nullptr;
+    }
+
+    const char* b64Data = encoding + std::size(kDataURIEncodingStr) - 1;
+    size_t b64DataLen = strlen(b64Data);
+    size_t dataLen;
+    if (SkBase64::Decode(b64Data, b64DataLen, nullptr, &dataLen) != SkBase64::kNoError) {
+        return nullptr;
+    }
+
+    sk_sp<SkData> data = SkData::MakeUninitialized(dataLen);
+    void* rawData = data->writable_data();
+    if (SkBase64::Decode(b64Data, b64DataLen, rawData, &dataLen) != SkBase64::kNoError) {
+        return nullptr;
+    }
+
+    return data;
+}
+
+sk_sp<ImageAsset> DataURIResourceProviderProxy::loadImageAsset(const char rpath[],
+                                                               const char rname[],
+                                                               const char rid[]) const {
+    // First try to decode the data as base64 using codecs registered with SkCodecs::Register()
+    if (auto data = decode_datauri("data:image/", rname)) {
+        return MultiFrameImageAsset::Make(std::move(data), fStrategy);
+    }
+    // Fallback to the asking the ProviderProxy to load this image for us.
+    return this->INHERITED::loadImageAsset(rpath, rname, rid);
+}
+
+sk_sp<SkTypeface> DataURIResourceProviderProxy::loadTypeface(const char name[],
+                                                             const char url[]) const {
+    if (fFontMgr) {
+        if (auto data = decode_datauri("data:font/", url)) {
+            return fFontMgr->makeFromData(std::move(data));
+        }
+    }
+
+    return this->INHERITED::loadTypeface(name, url);
+}
+
+} // namespace skresources
diff --git a/Source/ThirdParty/skia/modules/skshaper/BUILD.bazel b/Source/ThirdParty/skia/modules/skshaper/BUILD.bazel
new file mode 100644
index 00000000..79964091
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/BUILD.bazel
@@ -0,0 +1,142 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library", "skia_objc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "skshaper_core",
+    srcs = [
+        "//modules/skshaper/src:core_srcs",
+    ],
+    hdrs = [
+        "//modules/skshaper/include:core_hdrs",
+    ],
+    defines = ["SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS"],
+    features = ["layering_check"],
+    local_defines = ["SKSHAPER_IMPLEMENTATION=1"],
+    visibility = [
+        "//modules/skottie:__subpackages__",
+        "//modules/svg:__subpackages__",
+    ],
+    deps = [
+        "//:core",
+        "//src/base",
+        "//src/core:core_priv",
+    ],
+)
+
+# This is its own library to make it harder for Skia itself to unintentionally
+# include FactoryHelpers.h in utils
+skia_cc_library(
+    name = "skshaper_core_and_utils",
+    hdrs = [
+        "//modules/skshaper/include:core_hdrs",
+        "//modules/skshaper/utils:core_hdrs",
+    ],
+    local_defines = ["SKSHAPER_IMPLEMENTATION=1"],
+    visibility = [
+        "//:__pkg__",
+    ],
+    deps = [
+        ":skshaper_core",
+    ],
+)
+
+skia_objc_library(
+    name = "skshaper_coretext",
+    srcs = [
+        "//modules/skshaper/src:coretext_srcs",
+    ],
+    hdrs = [
+        "//modules/skshaper/include:core_hdrs",
+        "//modules/skshaper/include:coretext_hdrs",
+        "//modules/skshaper/utils:core_hdrs",
+    ],
+    copts = ["-DSKSHAPER_IMPLEMENTATION=1"],
+    defines = [
+        "SK_SHAPER_CORETEXT_AVAILABLE",
+        "SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS",
+    ],
+    features = ["layering_check"],
+    ios_frameworks = [
+        "CoreText",
+        "CoreGraphics",
+        "CoreFoundation",
+    ],
+    mac_frameworks = ["ApplicationServices"],
+    visibility = [
+        "//:__subpackages__",
+    ],
+    deps = [
+        ":skshaper_core",
+        "//:core",
+        "//src/base",
+        "//src/core:core_priv",
+        "//src/ports:coretext_typeface",
+        "//src/utils/mac:mac_utils_priv",
+    ],
+)
+
+skia_cc_library(
+    name = "skshaper_harfbuzz",
+    srcs = [
+        "//modules/skshaper/src:harfbuzz_srcs",
+    ],
+    hdrs = [
+        "//modules/skshaper/include:core_hdrs",
+        "//modules/skshaper/include:harfbuzz_hdrs",
+        "//modules/skshaper/utils:core_hdrs",
+    ],
+    defines = [
+        "SK_SHAPER_HARFBUZZ_AVAILABLE",
+        "SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS",
+    ],
+    features = ["layering_check"],
+    local_defines = ["SKSHAPER_IMPLEMENTATION=1"],
+    visibility = [
+        "//:__subpackages__",
+    ],
+    deps = [
+        ":skshaper_core",
+        "//:core",
+        "//modules/skunicode:skunicode_core",
+        "//src/base",
+        "//src/core:core_priv",
+    ] +
+    # We have this harfbuzz dependency all by itself because we need to turn this into a
+    # select statement when rolling into G3.
+    [
+        "@harfbuzz",
+    ],
+)
+
+skia_cc_library(
+    name = "skshaper_unicode",
+    srcs = [
+        "//modules/skshaper/src:skunicode_srcs",
+    ],
+    hdrs = [
+        "//modules/skshaper/include:core_hdrs",
+        "//modules/skshaper/include:skunicode_hdrs",
+        "//modules/skshaper/utils:core_hdrs",
+    ],
+    defines = [
+        "SK_SHAPER_UNICODE_AVAILABLE",
+        "SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS",
+    ],
+    features = ["layering_check"],
+    local_defines = ["SKSHAPER_IMPLEMENTATION=1"],
+    visibility = [
+        "//:__subpackages__",
+    ],
+    deps = [
+        ":skshaper_core",
+        "//:core",
+        "//modules/skunicode:skunicode_core",
+        "//src/base",
+        "//src/core:core_priv",
+    ],
+)
diff --git a/Source/ThirdParty/skia/modules/skshaper/BUILD.gn b/Source/ThirdParty/skia/modules/skshaper/BUILD.gn
new file mode 100644
index 00000000..63dcf271
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/BUILD.gn
@@ -0,0 +1,82 @@
+# Copyright 2018 Google Inc.
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+import("skshaper.gni")
+
+if (skia_enable_skshaper) {
+  config("public_config") {
+    include_dirs = [ "include" ]
+    defines = [ "SK_SHAPER_PRIMITIVE_AVAILABLE" ]
+    if (is_component_build) {
+      defines += [ "SKSHAPER_DLL" ]
+    }
+    if (skia_use_fonthost_mac) {
+      defines += [ "SK_SHAPER_CORETEXT_AVAILABLE" ]
+    }
+    if (skia_use_harfbuzz) {
+      defines += [ "SK_SHAPER_HARFBUZZ_AVAILABLE" ]
+    }
+    if (skia_enable_skunicode) {
+      defines += [ "SK_SHAPER_UNICODE_AVAILABLE" ]
+    }
+  }
+
+  component("skshaper") {
+    check_includes = false
+    public_configs = [ ":public_config" ]
+    public = skia_shaper_public
+    deps = [ "../..:skia" ]
+    defines = [ "SKSHAPER_IMPLEMENTATION=1" ]
+    sources = skia_shaper_primitive_sources
+    if (skia_use_fonthost_mac) {
+      sources += skia_shaper_coretext_sources
+      if (is_mac) {
+        frameworks = [ "ApplicationServices.framework" ]
+      }
+
+      if (is_ios) {
+        frameworks = [
+          "CoreFoundation.framework",
+          "CoreText.framework",
+        ]
+      }
+    }
+    if (skia_enable_skunicode) {
+      sources += skia_shaper_skunicode_sources
+      deps += [ "../skunicode" ]
+    }
+    if (skia_use_harfbuzz && skia_enable_skunicode) {
+      sources += skia_shaper_harfbuzz_sources
+      deps += [
+        "../skunicode",
+        "//third_party/harfbuzz",
+      ]
+    }
+    configs += [ "../../:skia_private" ]
+  }
+
+  if (defined(is_skia_standalone) && skia_enable_tools) {
+    skia_source_set("tests") {
+      if (skia_enable_skshaper_tests) {
+        testonly = true
+        sources = skia_shaper_tests
+        deps = [
+          ":skshaper",
+          "../..:skia",
+          "../..:test",
+          "../skunicode",
+        ]
+      } else {
+        sources = []
+      }
+    }
+  }
+} else {
+  group("skshaper") {
+  }
+  group("tests") {
+  }
+}
diff --git a/Source/ThirdParty/skia/modules/skshaper/include/BUILD.bazel b/Source/ThirdParty/skia/modules/skshaper/include/BUILD.bazel
new file mode 100644
index 00000000..f063a7e5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/include/BUILD.bazel
@@ -0,0 +1,52 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "hdrs",
+    srcs = [
+        "SkShaper.h",
+        "SkShaper_factory.h",
+        "SkShaper_harfbuzz.h",
+        "SkShaper_skunicode.h",
+        "//modules/skshaper/utils:core_hdrs",
+    ],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "core_hdrs",
+    srcs = [
+        "SkShaper.h",
+        "SkShaper_factory.h",
+    ],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "coretext_hdrs",
+    srcs = [
+        "SkShaper_coretext.h",
+    ],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "harfbuzz_hdrs",
+    srcs = [
+        "SkShaper_harfbuzz.h",
+    ],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "skunicode_hdrs",
+    srcs = [
+        "SkShaper_skunicode.h",
+    ],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skshaper/include/SkShaper.h b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper.h
new file mode 100644
index 00000000..f1651719
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper.h
@@ -0,0 +1,315 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkShaper_DEFINED
+#define SkShaper_DEFINED
+
+#include "include/core/SkFont.h"
+#include "include/core/SkPoint.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkScalar.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTextBlob.h"
+#include "include/core/SkTypes.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <type_traits>
+
+class SkFontStyle;
+
+#if defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+class SkFontMgr;
+#else
+#include "include/core/SkFontMgr.h"
+#endif
+
+#if !defined(SKSHAPER_IMPLEMENTATION)
+    #define SKSHAPER_IMPLEMENTATION 0
+#endif
+
+#if !defined(SKSHAPER_API)
+    #if defined(SKSHAPER_DLL)
+        #if defined(_MSC_VER)
+            #if SKSHAPER_IMPLEMENTATION
+                #define SKSHAPER_API __declspec(dllexport)
+            #else
+                #define SKSHAPER_API __declspec(dllimport)
+            #endif
+        #else
+            #define SKSHAPER_API __attribute__((visibility("default")))
+        #endif
+    #else
+        #define SKSHAPER_API
+    #endif
+#endif
+
+class SKSHAPER_API SkShaper {
+public:
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    static std::unique_ptr<SkShaper> MakePrimitive();
+
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE)
+    static std::unique_ptr<SkShaper> MakeShaperDrivenWrapper(sk_sp<SkFontMgr> fallback);
+    static std::unique_ptr<SkShaper> MakeShapeThenWrap(sk_sp<SkFontMgr> fallback);
+    static void PurgeHarfBuzzCache();
+#endif
+
+#if defined(SK_SHAPER_CORETEXT_AVAILABLE)
+    static std::unique_ptr<SkShaper> MakeCoreText();
+#endif
+
+    static std::unique_ptr<SkShaper> Make(sk_sp<SkFontMgr> fallback = nullptr);
+    static void PurgeCaches();
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+    SkShaper();
+    virtual ~SkShaper();
+
+    class RunIterator {
+    public:
+        virtual ~RunIterator() = default;
+        /** Set state to that of current run and move iterator to end of that run. */
+        virtual void consume() = 0;
+        /** Offset to one past the last (utf8) element in the current run. */
+        virtual size_t endOfCurrentRun() const = 0;
+        /** Return true if consume should no longer be called. */
+        virtual bool atEnd() const = 0;
+    };
+    class FontRunIterator : public RunIterator {
+    public:
+        virtual const SkFont& currentFont() const = 0;
+    };
+    class BiDiRunIterator : public RunIterator {
+    public:
+        /** The unicode bidi embedding level (even ltr, odd rtl) */
+        virtual uint8_t currentLevel() const = 0;
+    };
+    class ScriptRunIterator : public RunIterator {
+    public:
+        /** Should be iso15924 codes. */
+        virtual SkFourByteTag currentScript() const = 0;
+    };
+    class LanguageRunIterator : public RunIterator {
+    public:
+        /** Should be BCP-47, c locale names may also work. */
+        virtual const char* currentLanguage() const = 0;
+    };
+    struct Feature {
+        SkFourByteTag tag;
+        uint32_t value;
+        size_t start; // Offset to the start (utf8) element of the run.
+        size_t end;   // Offset to one past the last (utf8) element of the run.
+    };
+
+private:
+    template <typename RunIteratorSubclass>
+    class TrivialRunIterator : public RunIteratorSubclass {
+    public:
+        static_assert(std::is_base_of<RunIterator, RunIteratorSubclass>::value, "");
+        TrivialRunIterator(size_t utf8Bytes) : fEnd(utf8Bytes), fAtEnd(fEnd == 0) {}
+        void consume() override { SkASSERT(!fAtEnd); fAtEnd = true; }
+        size_t endOfCurrentRun() const override { return fAtEnd ? fEnd : 0; }
+        bool atEnd() const override { return fAtEnd; }
+    private:
+        size_t fEnd;
+        bool fAtEnd;
+    };
+
+public:
+    static std::unique_ptr<FontRunIterator>
+    MakeFontMgrRunIterator(const char* utf8, size_t utf8Bytes,
+                           const SkFont& font, sk_sp<SkFontMgr> fallback);
+    static std::unique_ptr<SkShaper::FontRunIterator>
+    MakeFontMgrRunIterator(const char* utf8, size_t utf8Bytes,
+                           const SkFont& font, sk_sp<SkFontMgr> fallback,
+                           const char* requestName, SkFontStyle requestStyle,
+                           const SkShaper::LanguageRunIterator*);
+    class TrivialFontRunIterator : public TrivialRunIterator<FontRunIterator> {
+    public:
+        TrivialFontRunIterator(const SkFont& font, size_t utf8Bytes)
+            : TrivialRunIterator(utf8Bytes), fFont(font) {}
+        const SkFont& currentFont() const override { return fFont; }
+    private:
+        SkFont fFont;
+    };
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    static std::unique_ptr<BiDiRunIterator>
+    MakeBiDiRunIterator(const char* utf8, size_t utf8Bytes, uint8_t bidiLevel);
+#if defined(SK_SHAPER_UNICODE_AVAILABLE)
+    static std::unique_ptr<BiDiRunIterator>
+    MakeIcuBiDiRunIterator(const char* utf8, size_t utf8Bytes, uint8_t bidiLevel);
+#endif  // defined(SK_SHAPER_UNICODE_AVAILABLE)
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+    class TrivialBiDiRunIterator : public TrivialRunIterator<BiDiRunIterator> {
+    public:
+        TrivialBiDiRunIterator(uint8_t bidiLevel, size_t utf8Bytes)
+            : TrivialRunIterator(utf8Bytes), fBidiLevel(bidiLevel) {}
+        uint8_t currentLevel() const override { return fBidiLevel; }
+    private:
+        uint8_t fBidiLevel;
+    };
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    static std::unique_ptr<ScriptRunIterator>
+    MakeScriptRunIterator(const char* utf8, size_t utf8Bytes, SkFourByteTag script);
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE)
+    static std::unique_ptr<ScriptRunIterator>
+    MakeSkUnicodeHbScriptRunIterator(const char* utf8, size_t utf8Bytes);
+    static std::unique_ptr<ScriptRunIterator>
+    MakeSkUnicodeHbScriptRunIterator(const char* utf8, size_t utf8Bytes, SkFourByteTag script);
+    // Still used in some cases
+    static std::unique_ptr<ScriptRunIterator>
+    MakeHbIcuScriptRunIterator(const char* utf8, size_t utf8Bytes);
+#endif  // defined(SK_SHAPER_HARFBUZZ_AVAILABLE)
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+    class TrivialScriptRunIterator : public TrivialRunIterator<ScriptRunIterator> {
+    public:
+        TrivialScriptRunIterator(SkFourByteTag script, size_t utf8Bytes)
+            : TrivialRunIterator(utf8Bytes), fScript(script) {}
+        SkFourByteTag currentScript() const override { return fScript; }
+    private:
+        SkFourByteTag fScript;
+    };
+
+    static std::unique_ptr<LanguageRunIterator>
+    MakeStdLanguageRunIterator(const char* utf8, size_t utf8Bytes);
+    class TrivialLanguageRunIterator : public TrivialRunIterator<LanguageRunIterator> {
+    public:
+        TrivialLanguageRunIterator(const char* language, size_t utf8Bytes)
+            : TrivialRunIterator(utf8Bytes), fLanguage(language) {}
+        const char* currentLanguage() const override { return fLanguage.c_str(); }
+    private:
+        SkString fLanguage;
+    };
+
+    class RunHandler {
+    public:
+        virtual ~RunHandler() = default;
+
+        struct Range {
+            constexpr Range() : fBegin(0), fSize(0) {}
+            constexpr Range(size_t begin, size_t size) : fBegin(begin), fSize(size) {}
+            size_t fBegin;
+            size_t fSize;
+            constexpr size_t begin() const { return fBegin; }
+            constexpr size_t end() const { return begin() + size(); }
+            constexpr size_t size() const { return fSize; }
+        };
+
+        struct RunInfo {
+            const SkFont& fFont;
+            uint8_t fBidiLevel;
+            SkVector fAdvance;
+            size_t glyphCount;
+            Range utf8Range;
+        };
+
+        struct Buffer {
+            SkGlyphID* glyphs;  // required
+            SkPoint* positions; // required, if (!offsets) put glyphs[i] at positions[i]
+                                //           if ( offsets) positions[i+1]-positions[i] are advances
+            SkPoint* offsets;   // optional, if ( offsets) put glyphs[i] at positions[i]+offsets[i]
+            uint32_t* clusters; // optional, utf8+clusters[i] starts run which produced glyphs[i]
+            SkPoint point;      // offset to add to all positions
+        };
+
+        /** Called when beginning a line. */
+        virtual void beginLine() = 0;
+
+        /** Called once for each run in a line. Can compute baselines and offsets. */
+        virtual void runInfo(const RunInfo&) = 0;
+
+        /** Called after all runInfo calls for a line. */
+        virtual void commitRunInfo() = 0;
+
+        /** Called for each run in a line after commitRunInfo. The buffer will be filled out. */
+        virtual Buffer runBuffer(const RunInfo&) = 0;
+
+        /** Called after each runBuffer is filled out. */
+        virtual void commitRunBuffer(const RunInfo&) = 0;
+
+        /** Called when ending a line. */
+        virtual void commitLine() = 0;
+    };
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    virtual void shape(const char* utf8, size_t utf8Bytes,
+                       const SkFont& srcFont,
+                       bool leftToRight,
+                       SkScalar width,
+                       RunHandler*) const = 0;
+
+    virtual void shape(const char* utf8, size_t utf8Bytes,
+                       FontRunIterator&,
+                       BiDiRunIterator&,
+                       ScriptRunIterator&,
+                       LanguageRunIterator&,
+                       SkScalar width,
+                       RunHandler*) const = 0;
+#endif
+    virtual void shape(const char* utf8,
+                       size_t utf8Bytes,
+                       FontRunIterator&,
+                       BiDiRunIterator&,
+                       ScriptRunIterator&,
+                       LanguageRunIterator&,
+                       const Feature* features,
+                       size_t featuresSize,
+                       SkScalar width,
+                       RunHandler*) const = 0;
+
+private:
+    SkShaper(const SkShaper&) = delete;
+    SkShaper& operator=(const SkShaper&) = delete;
+};
+
+/**
+ * Helper for shaping text directly into a SkTextBlob.
+ */
+class SKSHAPER_API SkTextBlobBuilderRunHandler final : public SkShaper::RunHandler {
+public:
+    SkTextBlobBuilderRunHandler(const char* utf8Text, SkPoint offset)
+        : fUtf8Text(utf8Text)
+        , fOffset(offset) {}
+    sk_sp<SkTextBlob> makeBlob();
+    SkPoint endPoint() { return fOffset; }
+
+    void beginLine() override;
+    void runInfo(const RunInfo&) override;
+    void commitRunInfo() override;
+    Buffer runBuffer(const RunInfo&) override;
+    void commitRunBuffer(const RunInfo&) override;
+    void commitLine() override;
+
+private:
+    SkTextBlobBuilder fBuilder;
+    char const * const fUtf8Text;
+    uint32_t* fClusters;
+    int fClusterOffset;
+    int fGlyphCount;
+    SkScalar fMaxRunAscent;
+    SkScalar fMaxRunDescent;
+    SkScalar fMaxRunLeading;
+    SkPoint fCurrentPosition;
+    SkPoint fOffset;
+};
+
+namespace SkShapers::Primitive {
+SKSHAPER_API std::unique_ptr<SkShaper> PrimitiveText();
+
+SKSHAPER_API std::unique_ptr<SkShaper::BiDiRunIterator> TrivialBiDiRunIterator
+                                              (size_t utf8Bytes,  uint8_t bidiLevel);
+SKSHAPER_API std::unique_ptr<SkShaper::ScriptRunIterator> TrivialScriptRunIterator
+                                              (size_t utf8Bytes, SkFourByteTag scriptTag);
+}  // namespace SkShapers
+
+#endif  // SkShaper_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_coretext.h b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_coretext.h
new file mode 100644
index 00000000..d2e2fad8
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_coretext.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkShaper_coretext_DEFINED
+#define SkShaper_coretext_DEFINED
+
+#include "modules/skshaper/include/SkShaper.h"
+
+#include <memory>
+
+namespace SkShapers::CT {
+SKSHAPER_API std::unique_ptr<SkShaper> CoreText();
+}
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_factory.h b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_factory.h
new file mode 100644
index 00000000..23de1f29
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_factory.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkShaperFactory_DEFINED
+#define SkShaperFactory_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkTypes.h"
+#include "modules/skshaper/include/SkShaper.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+
+class SkFontMgr;
+class SkUnicode;
+
+namespace SkShapers {
+
+class SKSHAPER_API Factory : public SkRefCnt {
+public:
+    virtual std::unique_ptr<SkShaper> makeShaper(sk_sp<SkFontMgr> fallback) = 0;
+    virtual std::unique_ptr<SkShaper::BiDiRunIterator> makeBidiRunIterator(
+            const char* utf8, size_t utf8Bytes, uint8_t bidiLevel) = 0;
+    virtual std::unique_ptr<SkShaper::ScriptRunIterator> makeScriptRunIterator(
+            const char* utf8, size_t utf8Bytes, SkFourByteTag script) = 0;
+
+    virtual SkUnicode* getUnicode() = 0;
+};
+
+namespace Primitive {
+SKSHAPER_API sk_sp<Factory> Factory();
+}
+
+}  // namespace SkShapers
+
+#endif  // SkShaperFactory_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_harfbuzz.h b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_harfbuzz.h
new file mode 100644
index 00000000..e66d654e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_harfbuzz.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkShaper_harfbuzz_DEFINED
+#define SkShaper_harfbuzz_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkTypes.h"
+#include "modules/skshaper/include/SkShaper.h"
+
+#include <cstddef>
+#include <memory>
+
+class SkFontMgr;
+class SkUnicode;
+
+namespace SkShapers::HB {
+SKSHAPER_API std::unique_ptr<SkShaper> ShaperDrivenWrapper(sk_sp<SkUnicode> unicode,
+                                                           sk_sp<SkFontMgr> fallback);
+SKSHAPER_API std::unique_ptr<SkShaper> ShapeThenWrap(sk_sp<SkUnicode> unicode,
+                                                     sk_sp<SkFontMgr> fallback);
+SKSHAPER_API std::unique_ptr<SkShaper> ShapeDontWrapOrReorder(sk_sp<SkUnicode> unicode,
+                                                              sk_sp<SkFontMgr> fallback);
+
+SKSHAPER_API std::unique_ptr<SkShaper::ScriptRunIterator> ScriptRunIterator(const char* utf8,
+                                                                            size_t utf8Bytes);
+SKSHAPER_API std::unique_ptr<SkShaper::ScriptRunIterator> ScriptRunIterator(const char* utf8,
+                                                                            size_t utf8Bytes,
+                                                                            SkFourByteTag script);
+
+SKSHAPER_API void PurgeCaches();
+}  // namespace SkShapers::HB
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_skunicode.h b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_skunicode.h
new file mode 100644
index 00000000..21580319
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/include/SkShaper_skunicode.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkShaper_skunicode_DEFINED
+#define SkShaper_skunicode_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/skshaper/include/SkShaper.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+
+class SkUnicode;
+
+namespace SkShapers::unicode {
+SKSHAPER_API std::unique_ptr<SkShaper::BiDiRunIterator> BidiRunIterator(sk_sp<SkUnicode> unicode,
+                                                                        const char* utf8,
+                                                                        size_t utf8Bytes,
+                                                                        uint8_t bidiLevel);
+
+}  // namespace SkShapers::unicode
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skshaper/skshaper.gni b/Source/ThirdParty/skia/modules/skshaper/skshaper.gni
new file mode 100644
index 00000000..8872e104
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/skshaper.gni
@@ -0,0 +1,52 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/skshaper/include/BUILD.bazel
+#   //modules/skshaper/src/BUILD.bazel
+#   //modules/skshaper/tests/BUILD.bazel
+#   //modules/skshaper/utils/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# List generated by Bazel rules:
+#  //modules/skshaper/include:hdrs
+#  //modules/skshaper/utils:core_hdrs
+skia_shaper_public = [
+  "$_modules/skshaper/include/SkShaper.h",
+  "$_modules/skshaper/include/SkShaper_factory.h",
+  "$_modules/skshaper/include/SkShaper_harfbuzz.h",
+  "$_modules/skshaper/include/SkShaper_skunicode.h",
+  "$_modules/skshaper/utils/FactoryHelpers.h",
+]
+
+# Generated by Bazel rule //modules/skshaper/src:base_srcs
+skia_shaper_primitive_sources = [
+  "$_modules/skshaper/src/SkShaper.cpp",
+  "$_modules/skshaper/src/SkShaper_factory.cpp",
+  "$_modules/skshaper/src/SkShaper_primitive.cpp",
+]
+
+# Generated by Bazel rule //modules/skshaper/src:harfbuzz_srcs
+skia_shaper_harfbuzz_sources =
+    [ "$_modules/skshaper/src/SkShaper_harfbuzz.cpp" ]
+
+# Generated by Bazel rule //modules/skshaper/src:skunicode_srcs
+skia_shaper_skunicode_sources =
+    [ "$_modules/skshaper/src/SkShaper_skunicode.cpp" ]
+
+# Generated by Bazel rule //modules/skshaper/src:coretext_srcs
+skia_shaper_coretext_sources =
+    [ "$_modules/skshaper/src/SkShaper_coretext.cpp" ]
+
+# Generated by Bazel rule //modules/skshaper/tests:tests_srcs
+skia_shaper_tests = [ "$_modules/skshaper/tests/ShaperTest.cpp" ]
+
+declare_args() {
+  skia_enable_skshaper = true
+}
+declare_args() {
+  skia_enable_skshaper_tests = skia_enable_skshaper
+}
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/BUILD.bazel b/Source/ThirdParty/skia/modules/skshaper/src/BUILD.bazel
new file mode 100644
index 00000000..f85ab22b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/BUILD.bazel
@@ -0,0 +1,47 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "harfbuzz_srcs",
+    srcs = ["SkShaper_harfbuzz.cpp"],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "skunicode_srcs",
+    srcs = ["SkShaper_skunicode.cpp"],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "coretext_srcs",
+    srcs = ["SkShaper_coretext.cpp"],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
+
+skia_filegroup(
+    name = "base_srcs",
+    srcs = [
+        "SkShaper.cpp",
+        "SkShaper_factory.cpp",
+        "SkShaper_primitive.cpp",
+    ],
+    visibility = [
+        "//modules/skshaper:__pkg__",
+    ],
+)
+
+skia_filegroup(
+    name = "core_srcs",
+    srcs = [
+        "SkShaper.cpp",
+        "SkShaper_factory.cpp",
+        "SkShaper_primitive.cpp",
+    ],
+    visibility = ["//modules/skshaper:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/SkShaper.cpp b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper.cpp
new file mode 100644
index 00000000..3bee54ab
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper.cpp
@@ -0,0 +1,259 @@
+/*
+ * Copyright 2018 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkFont.h"
+#include "include/core/SkFontMetrics.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkFontStyle.h"
+#include "include/core/SkTypeface.h"
+#include "include/private/base/SkTFitsIn.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "src/base/SkUTF.h"
+#include <limits.h>
+#include <algorithm>
+#include <cstring>
+#include <locale>
+#include <string>
+#include <utility>
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE)
+#include "modules/skshaper/include/SkShaper_harfbuzz.h"
+#endif
+
+#if defined(SK_SHAPER_CORETEXT_AVAILABLE)
+#include "modules/skshaper/include/SkShaper_coretext.h"
+#endif
+
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+std::unique_ptr<SkShaper> SkShaper::Make(sk_sp<SkFontMgr> fallback) {
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+    std::unique_ptr<SkShaper> shaper = MakeShapeThenWrap(std::move(fallback));
+    if (shaper) {
+        return shaper;
+    }
+#elif defined(SK_SHAPER_CORETEXT_AVAILABLE)
+    if (auto shaper = SkShapers::CT::CoreText()) {
+        return shaper;
+    }
+#endif
+    return SkShapers::Primitive::PrimitiveText();
+}
+
+void SkShaper::PurgeCaches() {
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+    SkShapers::HB::PurgeCaches();
+#endif
+}
+
+std::unique_ptr<SkShaper::BiDiRunIterator>
+SkShaper::MakeBiDiRunIterator(const char* utf8, size_t utf8Bytes, uint8_t bidiLevel) {
+#if defined(SK_SHAPER_UNICODE_AVAILABLE)
+      std::unique_ptr<SkShaper::BiDiRunIterator> bidi = MakeIcuBiDiRunIterator(utf8, utf8Bytes, bidiLevel);
+      if (bidi) {
+          return bidi;
+      }
+#endif
+    return std::make_unique<SkShaper::TrivialBiDiRunIterator>(bidiLevel, utf8Bytes);
+}
+
+std::unique_ptr<SkShaper::ScriptRunIterator>
+SkShaper::MakeScriptRunIterator(const char* utf8, size_t utf8Bytes, SkFourByteTag scriptTag) {
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+    std::unique_ptr<SkShaper::ScriptRunIterator> script =
+            SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes, scriptTag);
+    if (script) {
+        return script;
+    }
+#endif
+    return std::make_unique<SkShaper::TrivialScriptRunIterator>(scriptTag, utf8Bytes);
+}
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+SkShaper::SkShaper() {}
+SkShaper::~SkShaper() {}
+
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+class FontMgrRunIterator final : public SkShaper::FontRunIterator {
+public:
+    FontMgrRunIterator(const char* utf8, size_t utf8Bytes,
+                       const SkFont& font, sk_sp<SkFontMgr> fallbackMgr,
+                       const char* requestName, SkFontStyle requestStyle,
+                       const SkShaper::LanguageRunIterator* lang)
+        : fCurrent(utf8), fBegin(utf8), fEnd(fCurrent + utf8Bytes)
+        , fFallbackMgr(std::move(fallbackMgr))
+        , fFont(font)
+        , fFallbackFont(fFont)
+        , fCurrentFont(nullptr)
+        , fRequestName(requestName)
+        , fRequestStyle(requestStyle)
+        , fLanguage(lang)
+    {
+        // If fallback is not wanted, clients should use TrivialFontRunIterator.
+        SkASSERT(fFallbackMgr);
+        fFont.setTypeface(font.refTypeface());
+        fFallbackFont.setTypeface(nullptr);
+    }
+    FontMgrRunIterator(const char* utf8, size_t utf8Bytes,
+                       const SkFont& font, sk_sp<SkFontMgr> fallbackMgr)
+        : FontMgrRunIterator(utf8, utf8Bytes, font, std::move(fallbackMgr),
+                             nullptr, font.getTypeface()->fontStyle(), nullptr)
+    {}
+
+    void consume() override {
+        SkASSERT(fCurrent < fEnd);
+        SkASSERT(!fLanguage || this->endOfCurrentRun() <= fLanguage->endOfCurrentRun());
+        SkUnichar u = utf8_next(&fCurrent, fEnd);
+        // If the starting typeface can handle this character, use it.
+        if (fFont.unicharToGlyph(u)) {
+            fCurrentFont = &fFont;
+        // If the current fallback can handle this character, use it.
+        } else if (fFallbackFont.getTypeface() && fFallbackFont.unicharToGlyph(u)) {
+            fCurrentFont = &fFallbackFont;
+        // If not, try to find a fallback typeface
+        } else {
+            const char* language = fLanguage ? fLanguage->currentLanguage() : nullptr;
+            int languageCount = fLanguage ? 1 : 0;
+            sk_sp<SkTypeface> candidate(fFallbackMgr->matchFamilyStyleCharacter(
+                fRequestName, fRequestStyle, &language, languageCount, u));
+            if (candidate) {
+                fFallbackFont.setTypeface(std::move(candidate));
+                fCurrentFont = &fFallbackFont;
+            } else {
+                fCurrentFont = &fFont;
+            }
+        }
+
+        while (fCurrent < fEnd) {
+            const char* prev = fCurrent;
+            u = utf8_next(&fCurrent, fEnd);
+
+            // End run if not using initial typeface and initial typeface has this character.
+            if (fCurrentFont->getTypeface() != fFont.getTypeface() && fFont.unicharToGlyph(u)) {
+                fCurrent = prev;
+                return;
+            }
+
+            // End run if current typeface does not have this character and some other font does.
+            if (!fCurrentFont->unicharToGlyph(u)) {
+                const char* language = fLanguage ? fLanguage->currentLanguage() : nullptr;
+                int languageCount = fLanguage ? 1 : 0;
+                sk_sp<SkTypeface> candidate(fFallbackMgr->matchFamilyStyleCharacter(
+                    fRequestName, fRequestStyle, &language, languageCount, u));
+                if (candidate) {
+                    fCurrent = prev;
+                    return;
+                }
+            }
+        }
+    }
+    size_t endOfCurrentRun() const override {
+        return fCurrent - fBegin;
+    }
+    bool atEnd() const override {
+        return fCurrent == fEnd;
+    }
+
+    const SkFont& currentFont() const override {
+        return *fCurrentFont;
+    }
+
+private:
+    char const * fCurrent;
+    char const * const fBegin;
+    char const * const fEnd;
+    sk_sp<SkFontMgr> const fFallbackMgr;
+    SkFont fFont;
+    SkFont fFallbackFont;
+    SkFont* fCurrentFont;
+    char const * const fRequestName;
+    SkFontStyle const fRequestStyle;
+    SkShaper::LanguageRunIterator const * const fLanguage;
+};
+
+std::unique_ptr<SkShaper::FontRunIterator>
+SkShaper::MakeFontMgrRunIterator(const char* utf8, size_t utf8Bytes,
+                                 const SkFont& font, sk_sp<SkFontMgr> fallback)
+{
+    return std::make_unique<FontMgrRunIterator>(utf8, utf8Bytes, font, std::move(fallback));
+}
+
+std::unique_ptr<SkShaper::FontRunIterator>
+SkShaper::MakeFontMgrRunIterator(const char* utf8, size_t utf8Bytes, const SkFont& font,
+                                 sk_sp<SkFontMgr> fallback,
+                                 const char* requestName, SkFontStyle requestStyle,
+                                 const SkShaper::LanguageRunIterator* language)
+{
+    return std::make_unique<FontMgrRunIterator>(utf8, utf8Bytes, font, std::move(fallback),
+                                                requestName, requestStyle, language);
+}
+
+std::unique_ptr<SkShaper::LanguageRunIterator>
+SkShaper::MakeStdLanguageRunIterator(const char* utf8, size_t utf8Bytes) {
+    return std::make_unique<TrivialLanguageRunIterator>(std::locale().name().c_str(), utf8Bytes);
+}
+
+void SkTextBlobBuilderRunHandler::beginLine() {
+    fCurrentPosition = fOffset;
+    fMaxRunAscent = 0;
+    fMaxRunDescent = 0;
+    fMaxRunLeading = 0;
+}
+void SkTextBlobBuilderRunHandler::runInfo(const RunInfo& info) {
+    SkFontMetrics metrics;
+    info.fFont.getMetrics(&metrics);
+    fMaxRunAscent = std::min(fMaxRunAscent, metrics.fAscent);
+    fMaxRunDescent = std::max(fMaxRunDescent, metrics.fDescent);
+    fMaxRunLeading = std::max(fMaxRunLeading, metrics.fLeading);
+}
+
+void SkTextBlobBuilderRunHandler::commitRunInfo() {
+    fCurrentPosition.fY -= fMaxRunAscent;
+}
+
+SkShaper::RunHandler::Buffer SkTextBlobBuilderRunHandler::runBuffer(const RunInfo& info) {
+    int glyphCount = SkTFitsIn<int>(info.glyphCount) ? info.glyphCount : INT_MAX;
+    int utf8RangeSize = SkTFitsIn<int>(info.utf8Range.size()) ? info.utf8Range.size() : INT_MAX;
+
+    const auto& runBuffer = fBuilder.allocRunTextPos(info.fFont, glyphCount, utf8RangeSize);
+    if (runBuffer.utf8text && fUtf8Text) {
+        memcpy(runBuffer.utf8text, fUtf8Text + info.utf8Range.begin(), utf8RangeSize);
+    }
+    fClusters = runBuffer.clusters;
+    fGlyphCount = glyphCount;
+    fClusterOffset = info.utf8Range.begin();
+
+    return { runBuffer.glyphs,
+             runBuffer.points(),
+             nullptr,
+             runBuffer.clusters,
+             fCurrentPosition };
+}
+
+void SkTextBlobBuilderRunHandler::commitRunBuffer(const RunInfo& info) {
+    SkASSERT(0 <= fClusterOffset);
+    for (int i = 0; i < fGlyphCount; ++i) {
+        SkASSERT(fClusters[i] >= (unsigned)fClusterOffset);
+        fClusters[i] -= fClusterOffset;
+    }
+    fCurrentPosition += info.fAdvance;
+}
+void SkTextBlobBuilderRunHandler::commitLine() {
+    fOffset += { 0, fMaxRunDescent + fMaxRunLeading - fMaxRunAscent };
+}
+
+sk_sp<SkTextBlob> SkTextBlobBuilderRunHandler::makeBlob() {
+    return fBuilder.make();
+}
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_coretext.cpp b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_coretext.cpp
new file mode 100644
index 00000000..d730790e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_coretext.cpp
@@ -0,0 +1,327 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/skshaper/include/SkShaper.h"
+
+#ifdef SK_BUILD_FOR_MAC
+#import <ApplicationServices/ApplicationServices.h>
+#endif
+
+#ifdef SK_BUILD_FOR_IOS
+#include <CoreText/CoreText.h>
+#include <CoreText/CTFontManager.h>
+#include <CoreGraphics/CoreGraphics.h>
+#include <CoreFoundation/CoreFoundation.h>
+#endif
+
+#include "include/ports/SkTypeface_mac.h"
+#include "include/private/base/SkTemplates.h"
+#include "src/base/SkUTF.h"
+#include "src/core/SkFontPriv.h"
+#include "src/utils/mac/SkCGBase.h"
+#include "src/utils/mac/SkUniqueCFRef.h"
+
+#include <vector>
+#include <utility>
+
+using namespace skia_private;
+
+class SkShaper_CoreText : public SkShaper {
+public:
+    SkShaper_CoreText() {}
+private:
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    void shape(const char* utf8, size_t utf8Bytes,
+               const SkFont& srcFont,
+               bool leftToRight,
+               SkScalar width,
+               RunHandler*) const override;
+
+    void shape(const char* utf8, size_t utf8Bytes,
+               FontRunIterator&,
+               BiDiRunIterator&,
+               ScriptRunIterator&,
+               LanguageRunIterator&,
+               SkScalar width,
+               RunHandler*) const override;
+#endif
+
+    void shape(const char* utf8, size_t utf8Bytes,
+               FontRunIterator&,
+               BiDiRunIterator&,
+               ScriptRunIterator&,
+               LanguageRunIterator&,
+               const Feature*, size_t featureSize,
+               SkScalar width,
+               RunHandler*) const override;
+};
+
+// CTFramesetter/CTFrame can do this, but require version 10.14
+class LineBreakIter {
+    CTTypesetterRef fTypesetter;
+    double          fWidth;
+    CFIndex         fStart;
+
+public:
+    LineBreakIter(CTTypesetterRef ts, SkScalar width) : fTypesetter(ts), fWidth(width) {
+        fStart = 0;
+    }
+
+    SkUniqueCFRef<CTLineRef> nextLine() {
+        CFRange stringRange {fStart, CTTypesetterSuggestLineBreak(fTypesetter, fStart, fWidth)};
+        if (stringRange.length == 0) {
+            return nullptr;
+        }
+        fStart += stringRange.length;
+        return SkUniqueCFRef<CTLineRef>(CTTypesetterCreateLine(fTypesetter, stringRange));
+    }
+};
+
+[[maybe_unused]] static void dict_add_double(CFMutableDictionaryRef d, const void* name, double value) {
+    SkUniqueCFRef<CFNumberRef> number(
+            CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &value));
+    CFDictionaryAddValue(d, name, number.get());
+}
+
+static SkUniqueCFRef<CTFontRef> create_ctfont_from_font(const SkFont& font) {
+    auto typeface = font.getTypeface();
+    auto ctfont = SkTypeface_GetCTFontRef(typeface);
+    if (!ctfont) {
+        return nullptr;
+    }
+    return SkUniqueCFRef<CTFontRef>(
+            CTFontCreateCopyWithAttributes(ctfont, font.getSize(), nullptr, nullptr));
+}
+
+static SkFont run_to_font(CTRunRef run, const SkFont& orig) {
+    CFDictionaryRef attr = CTRunGetAttributes(run);
+    CTFontRef ct = (CTFontRef)CFDictionaryGetValue(attr, kCTFontAttributeName);
+    if (!ct) {
+        SkDebugf("no ctfont in Run Attributes\n");
+        CFShow(attr);
+        return orig;
+    }
+    // Do I need to add a local cache, or allow the caller to manage this lookup?
+    SkFont font(orig);
+    font.setTypeface(SkMakeTypefaceFromCTFont(ct));
+    return font;
+}
+
+namespace {
+class UTF16ToUTF8IndicesMap {
+public:
+    /** Builds a UTF-16 to UTF-8 indices map; the text is not retained
+     * @return true if successful
+     */
+    bool setUTF8(const char* utf8, size_t size) {
+        SkASSERT(utf8 != nullptr);
+
+        if (!SkTFitsIn<int32_t>(size)) {
+            SkDEBUGF("UTF16ToUTF8IndicesMap: text too long");
+            return false;
+        }
+
+        auto utf16Size = SkUTF::UTF8ToUTF16(nullptr, 0, utf8, size);
+        if (utf16Size < 0) {
+            SkDEBUGF("UTF16ToUTF8IndicesMap: Invalid utf8 input");
+            return false;
+        }
+
+        // utf16Size+1 to also store the size
+        fUtf16ToUtf8Indices = std::vector<size_t>(utf16Size + 1);
+        auto utf16 = fUtf16ToUtf8Indices.begin();
+        auto utf8Begin = utf8, utf8End = utf8 + size;
+        while (utf8Begin < utf8End) {
+            *utf16 = utf8Begin - utf8;
+            utf16 += SkUTF::ToUTF16(SkUTF::NextUTF8(&utf8Begin, utf8End), nullptr);
+        }
+        *utf16 = size;
+
+        return true;
+    }
+
+    size_t mapIndex(size_t index) const {
+        SkASSERT(index < fUtf16ToUtf8Indices.size());
+        return fUtf16ToUtf8Indices[index];
+    }
+
+    std::pair<size_t, size_t> mapRange(size_t start, size_t size) const {
+        auto utf8Start = mapIndex(start);
+        return {utf8Start, mapIndex(start + size) - utf8Start};
+    }
+private:
+    std::vector<size_t> fUtf16ToUtf8Indices;
+};
+} // namespace
+
+// kCTTrackingAttributeName not available until 10.12
+const CFStringRef kCTTracking_AttributeName = CFSTR("CTTracking");
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+void SkShaper_CoreText::shape(const char* utf8,
+                              size_t utf8Bytes,
+                              FontRunIterator& font,
+                              BiDiRunIterator& bidi,
+                              ScriptRunIterator& script,
+                              LanguageRunIterator& lang,
+                              SkScalar width,
+                              RunHandler* handler) const {
+    return this->shape(utf8, utf8Bytes, font, bidi, script, lang, nullptr, 0, width, handler);
+}
+
+void SkShaper_CoreText::shape(const char* utf8,
+                              size_t utf8Bytes,
+                              const SkFont& font,
+                              bool,
+                              SkScalar width,
+                              RunHandler* handler) const {
+    std::unique_ptr<FontRunIterator> fontRuns(
+            MakeFontMgrRunIterator(utf8, utf8Bytes, font, nullptr));
+    if (!fontRuns) {
+        return;
+    }
+    // bidi, script, and lang are all unused so we can construct them with empty data.
+    TrivialBiDiRunIterator bidi{0, 0};
+    TrivialScriptRunIterator script{0, 0};
+    TrivialLanguageRunIterator lang{nullptr, 0};
+    return this->shape(utf8, utf8Bytes, *fontRuns, bidi, script, lang, nullptr, 0, width, handler);
+}
+#endif
+
+void SkShaper_CoreText::shape(const char* utf8,
+                              size_t utf8Bytes,
+                              FontRunIterator& fontRuns,
+                              BiDiRunIterator&,
+                              ScriptRunIterator&,
+                              LanguageRunIterator&,
+                              const Feature*,
+                              size_t,
+                              SkScalar width,
+                              RunHandler* handler) const {
+    SkFont font;
+    if (!fontRuns.atEnd()) {
+        fontRuns.consume();
+        font = fontRuns.currentFont();
+    }
+
+    SkUniqueCFRef<CFStringRef> textString(
+            CFStringCreateWithBytes(kCFAllocatorDefault, (const uint8_t*)utf8, utf8Bytes,
+                                    kCFStringEncodingUTF8, false));
+
+    UTF16ToUTF8IndicesMap utf8IndicesMap;
+    if (!utf8IndicesMap.setUTF8(utf8, utf8Bytes)) {
+        return;
+    }
+
+    SkUniqueCFRef<CTFontRef> ctfont = create_ctfont_from_font(font);
+    if (!ctfont) {
+        return;
+    }
+
+    SkUniqueCFRef<CFMutableDictionaryRef> attr(
+            CFDictionaryCreateMutable(kCFAllocatorDefault, 0,
+                                      &kCFTypeDictionaryKeyCallBacks,
+                                      &kCFTypeDictionaryValueCallBacks));
+    CFDictionaryAddValue(attr.get(), kCTFontAttributeName, ctfont.get());
+    if ((false)) {
+        // trying to see what these affect
+        dict_add_double(attr.get(), kCTTracking_AttributeName, 1);
+        dict_add_double(attr.get(), kCTKernAttributeName, 0.0);
+    }
+
+    SkUniqueCFRef<CFAttributedStringRef> attrString(
+            CFAttributedStringCreate(kCFAllocatorDefault, textString.get(), attr.get()));
+
+    SkUniqueCFRef<CTTypesetterRef> typesetter(
+            CTTypesetterCreateWithAttributedString(attrString.get()));
+
+    // We have to compute RunInfos in a loop, and then reuse them in a 2nd loop,
+    // so we store them in an array (we reuse the array's storage for each line).
+    std::vector<SkFont> fontStorage;
+    std::vector<SkShaper::RunHandler::RunInfo> infos;
+
+    LineBreakIter iter(typesetter.get(), width);
+    while (SkUniqueCFRef<CTLineRef> line = iter.nextLine()) {
+        CFArrayRef run_array = CTLineGetGlyphRuns(line.get());
+        CFIndex runCount = CFArrayGetCount(run_array);
+        if (runCount == 0) {
+            continue;
+        }
+        handler->beginLine();
+        fontStorage.clear();
+        fontStorage.reserve(runCount); // ensure the refs won't get invalidated
+        infos.clear();
+        for (CFIndex j = 0; j < runCount; ++j) {
+            CTRunRef run = (CTRunRef)CFArrayGetValueAtIndex(run_array, j);
+            CFIndex runGlyphs = CTRunGetGlyphCount(run);
+
+            SkASSERT(sizeof(CGGlyph) == sizeof(uint16_t));
+
+            AutoSTArray<4096, CGSize> advances(runGlyphs);
+            CTRunGetAdvances(run, {0, runGlyphs}, advances.data());
+            SkScalar adv = 0;
+            for (CFIndex k = 0; k < runGlyphs; ++k) {
+                adv += advances[k].width;
+            }
+
+            CFRange cfRange = CTRunGetStringRange(run);
+            auto range = utf8IndicesMap.mapRange(cfRange.location, cfRange.length);
+
+            fontStorage.push_back(run_to_font(run, font));
+            infos.push_back({
+                fontStorage.back(), // info just stores a ref to the font
+                0,                  // need fBidiLevel
+                {adv, 0},
+                (size_t)runGlyphs,
+                {range.first, range.second},
+            });
+            handler->runInfo(infos.back());
+        }
+        handler->commitRunInfo();
+
+        // Now loop through again and fill in the buffers
+        SkScalar lineAdvance = 0;
+        for (CFIndex j = 0; j < runCount; ++j) {
+            const auto& info = infos[j];
+            auto buffer = handler->runBuffer(info);
+
+            CTRunRef run = (CTRunRef)CFArrayGetValueAtIndex(run_array, j);
+            CFIndex runGlyphs = info.glyphCount;
+            SkASSERT(CTRunGetGlyphCount(run) == (CFIndex)info.glyphCount);
+
+            CTRunGetGlyphs(run, {0, runGlyphs}, buffer.glyphs);
+
+            AutoSTArray<4096, CGPoint> positions(runGlyphs);
+            CTRunGetPositions(run, {0, runGlyphs}, positions.data());
+            AutoSTArray<4096, CFIndex> indices;
+            if (buffer.clusters) {
+                indices.reset(runGlyphs);
+                CTRunGetStringIndices(run, {0, runGlyphs}, indices.data());
+            }
+
+            for (CFIndex k = 0; k < runGlyphs; ++k) {
+                buffer.positions[k] = {
+                    buffer.point.fX + SkScalarFromCGFloat(positions[k].x) - lineAdvance,
+                    buffer.point.fY,
+                };
+                if (buffer.offsets) {
+                    buffer.offsets[k] = {0, 0}; // offset relative to the origin for this glyph
+                }
+                if (buffer.clusters) {
+                    buffer.clusters[k] = utf8IndicesMap.mapIndex(indices[k]);
+                }
+            }
+            handler->commitRunBuffer(info);
+            lineAdvance += info.fAdvance.fX;
+        }
+        handler->commitLine();
+    }
+}
+
+namespace SkShapers::CT {
+std::unique_ptr<SkShaper> CoreText() { return std::make_unique<SkShaper_CoreText>(); }
+}  // namespace SkShapers::CT
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_factory.cpp b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_factory.cpp
new file mode 100644
index 00000000..45daa957
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_factory.cpp
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skshaper/include/SkShaper_factory.h"
+
+namespace {
+class PrimitiveFactory final : public SkShapers::Factory {
+    std::unique_ptr<SkShaper> makeShaper(sk_sp<SkFontMgr>) override {
+        return SkShapers::Primitive::PrimitiveText();
+    }
+    std::unique_ptr<SkShaper::BiDiRunIterator> makeBidiRunIterator(const char*,
+                                                                size_t,
+                                                                uint8_t) override {
+        return std::make_unique<SkShaper::TrivialBiDiRunIterator>(0, 0);
+    }
+    std::unique_ptr<SkShaper::ScriptRunIterator> makeScriptRunIterator(const char*,
+                                                                 size_t,
+                                                                 SkFourByteTag) override {
+        return std::make_unique<SkShaper::TrivialScriptRunIterator>(0, 0);
+    }
+
+    SkUnicode* getUnicode() override {
+        return nullptr;
+    }
+};
+}
+
+namespace SkShapers::Primitive {
+sk_sp<SkShapers::Factory> Factory() {
+    return sk_make_sp<PrimitiveFactory>();
+}
+}  // namespace SkShapers::Primitive
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_harfbuzz.cpp b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_harfbuzz.cpp
new file mode 100644
index 00000000..06538577
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_harfbuzz.cpp
@@ -0,0 +1,1538 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/skshaper/include/SkShaper_harfbuzz.h"
+
+#include "include/core/SkData.h"
+#include "include/core/SkFont.h"
+#include "include/core/SkFontArguments.h"
+#include "include/core/SkFontMetrics.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkFontTypes.h"
+#include "include/core/SkPaint.h"
+#include "include/core/SkPoint.h"
+#include "include/core/SkRect.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkScalar.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypeface.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkMalloc.h"
+#include "include/private/base/SkMutex.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTemplates.h"
+#include "include/private/base/SkTo.h"
+#include "include/private/base/SkTypeTraits.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkTDPQueue.h"
+#include "src/base/SkUTF.h"
+#include "src/core/SkLRUCache.h"
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+#include "modules/skshaper/include/SkShaper_skunicode.h"
+#endif
+
+#include <hb-ot.h>
+#include <hb.h>
+
+#include <cstdint>
+#include <cstring>
+#include <memory>
+#include <type_traits>
+#include <utility>
+
+using namespace skia_private;
+
+// HB_FEATURE_GLOBAL_START and HB_FEATURE_GLOBAL_END were not added until HarfBuzz 2.0
+// They would have always worked, they just hadn't been named yet.
+#if !defined(HB_FEATURE_GLOBAL_START)
+#  define HB_FEATURE_GLOBAL_START 0
+#endif
+#if !defined(HB_FEATURE_GLOBAL_END)
+# define HB_FEATURE_GLOBAL_END ((unsigned int) -1)
+#endif
+
+namespace {
+using HBBlob   = std::unique_ptr<hb_blob_t  , SkFunctionObject<hb_blob_destroy>  >;
+using HBFace   = std::unique_ptr<hb_face_t  , SkFunctionObject<hb_face_destroy>  >;
+using HBFont   = std::unique_ptr<hb_font_t  , SkFunctionObject<hb_font_destroy>  >;
+using HBBuffer = std::unique_ptr<hb_buffer_t, SkFunctionObject<hb_buffer_destroy>>;
+
+using SkUnicodeBreak = std::unique_ptr<SkBreakIterator>;
+
+hb_position_t skhb_position(SkScalar value) {
+    // Treat HarfBuzz hb_position_t as 16.16 fixed-point.
+    constexpr int kHbPosition1 = 1 << 16;
+    return SkScalarRoundToInt(value * kHbPosition1);
+}
+
+hb_bool_t skhb_glyph(hb_font_t* hb_font,
+                     void* font_data,
+                     hb_codepoint_t unicode,
+                     hb_codepoint_t variation_selector,
+                     hb_codepoint_t* glyph,
+                     void* user_data) {
+    SkFont& font = *reinterpret_cast<SkFont*>(font_data);
+
+    *glyph = font.unicharToGlyph(unicode);
+    return *glyph != 0;
+}
+
+hb_bool_t skhb_nominal_glyph(hb_font_t* hb_font,
+                             void* font_data,
+                             hb_codepoint_t unicode,
+                             hb_codepoint_t* glyph,
+                             void* user_data) {
+  return skhb_glyph(hb_font, font_data, unicode, 0, glyph, user_data);
+}
+
+unsigned skhb_nominal_glyphs(hb_font_t *hb_font, void *font_data,
+                             unsigned int count,
+                             const hb_codepoint_t *unicodes,
+                             unsigned int unicode_stride,
+                             hb_codepoint_t *glyphs,
+                             unsigned int glyph_stride,
+                             void *user_data) {
+    SkFont& font = *reinterpret_cast<SkFont*>(font_data);
+
+    // Batch call textToGlyphs since entry cost is not cheap.
+    // Copy requred because textToGlyphs is dense and hb is strided.
+    AutoSTMalloc<256, SkUnichar> unicode(count);
+    for (unsigned i = 0; i < count; i++) {
+        unicode[i] = *unicodes;
+        unicodes = SkTAddOffset<const hb_codepoint_t>(unicodes, unicode_stride);
+    }
+    AutoSTMalloc<256, SkGlyphID> glyph(count);
+    font.textToGlyphs(unicode.get(), count * sizeof(SkUnichar), SkTextEncoding::kUTF32,
+                        glyph.get(), count);
+
+    // Copy the results back to the sparse array.
+    unsigned int done;
+    for (done = 0; done < count && glyph[done] != 0; done++) {
+        *glyphs = glyph[done];
+        glyphs = SkTAddOffset<hb_codepoint_t>(glyphs, glyph_stride);
+    }
+    // return 'done' to allow HarfBuzz to synthesize with NFC and spaces, return 'count' to avoid
+    return done;
+}
+
+hb_position_t skhb_glyph_h_advance(hb_font_t* hb_font,
+                                   void* font_data,
+                                   hb_codepoint_t hbGlyph,
+                                   void* user_data) {
+    SkFont& font = *reinterpret_cast<SkFont*>(font_data);
+
+    SkScalar advance;
+    SkGlyphID skGlyph = SkTo<SkGlyphID>(hbGlyph);
+
+    font.getWidths(&skGlyph, 1, &advance);
+    if (!font.isSubpixel()) {
+        advance = SkScalarRoundToInt(advance);
+    }
+    return skhb_position(advance);
+}
+
+void skhb_glyph_h_advances(hb_font_t* hb_font,
+                           void* font_data,
+                           unsigned count,
+                           const hb_codepoint_t* glyphs,
+                           unsigned int glyph_stride,
+                           hb_position_t* advances,
+                           unsigned int advance_stride,
+                           void* user_data) {
+    SkFont& font = *reinterpret_cast<SkFont*>(font_data);
+
+    // Batch call getWidths since entry cost is not cheap.
+    // Copy requred because getWidths is dense and hb is strided.
+    AutoSTMalloc<256, SkGlyphID> glyph(count);
+    for (unsigned i = 0; i < count; i++) {
+        glyph[i] = *glyphs;
+        glyphs = SkTAddOffset<const hb_codepoint_t>(glyphs, glyph_stride);
+    }
+    AutoSTMalloc<256, SkScalar> advance(count);
+    font.getWidths(glyph.get(), count, advance.get());
+
+    if (!font.isSubpixel()) {
+        for (unsigned i = 0; i < count; i++) {
+            advance[i] = SkScalarRoundToInt(advance[i]);
+        }
+    }
+
+    // Copy the results back to the sparse array.
+    for (unsigned i = 0; i < count; i++) {
+        *advances = skhb_position(advance[i]);
+        advances = SkTAddOffset<hb_position_t>(advances, advance_stride);
+    }
+}
+
+// HarfBuzz callback to retrieve glyph extents, mainly used by HarfBuzz for
+// fallback mark positioning, i.e. the situation when the font does not have
+// mark anchors or other mark positioning rules, but instead HarfBuzz is
+// supposed to heuristically place combining marks around base glyphs. HarfBuzz
+// does this by measuring "ink boxes" of glyphs, and placing them according to
+// Unicode mark classes. Above, below, centered or left or right, etc.
+hb_bool_t skhb_glyph_extents(hb_font_t* hb_font,
+                             void* font_data,
+                             hb_codepoint_t hbGlyph,
+                             hb_glyph_extents_t* extents,
+                             void* user_data) {
+    SkFont& font = *reinterpret_cast<SkFont*>(font_data);
+    SkASSERT(extents);
+
+    SkRect sk_bounds;
+    SkGlyphID skGlyph = SkTo<SkGlyphID>(hbGlyph);
+
+    font.getWidths(&skGlyph, 1, nullptr, &sk_bounds);
+    if (!font.isSubpixel()) {
+        sk_bounds.set(sk_bounds.roundOut());
+    }
+
+    // Skia is y-down but HarfBuzz is y-up.
+    extents->x_bearing = skhb_position(sk_bounds.fLeft);
+    extents->y_bearing = skhb_position(-sk_bounds.fTop);
+    extents->width = skhb_position(sk_bounds.width());
+    extents->height = skhb_position(-sk_bounds.height());
+    return true;
+}
+
+#define SK_HB_VERSION_CHECK(x, y, z) \
+    (HB_VERSION_MAJOR >  (x)) || \
+    (HB_VERSION_MAJOR == (x) && HB_VERSION_MINOR >  (y)) || \
+    (HB_VERSION_MAJOR == (x) && HB_VERSION_MINOR == (y) && HB_VERSION_MICRO >= (z))
+
+hb_font_funcs_t* skhb_get_font_funcs() {
+    static hb_font_funcs_t* const funcs = []{
+        // HarfBuzz will use the default (parent) implementation if they aren't set.
+        hb_font_funcs_t* const funcs = hb_font_funcs_create();
+        hb_font_funcs_set_variation_glyph_func(funcs, skhb_glyph, nullptr, nullptr);
+        hb_font_funcs_set_nominal_glyph_func(funcs, skhb_nominal_glyph, nullptr, nullptr);
+#if SK_HB_VERSION_CHECK(2, 0, 0)
+        hb_font_funcs_set_nominal_glyphs_func(funcs, skhb_nominal_glyphs, nullptr, nullptr);
+#else
+        sk_ignore_unused_variable(skhb_nominal_glyphs);
+#endif
+        hb_font_funcs_set_glyph_h_advance_func(funcs, skhb_glyph_h_advance, nullptr, nullptr);
+#if SK_HB_VERSION_CHECK(1, 8, 6)
+        hb_font_funcs_set_glyph_h_advances_func(funcs, skhb_glyph_h_advances, nullptr, nullptr);
+#else
+        sk_ignore_unused_variable(skhb_glyph_h_advances);
+#endif
+        hb_font_funcs_set_glyph_extents_func(funcs, skhb_glyph_extents, nullptr, nullptr);
+        hb_font_funcs_make_immutable(funcs);
+        return funcs;
+    }();
+    SkASSERT(funcs);
+    return funcs;
+}
+
+hb_blob_t* skhb_get_table(hb_face_t* face, hb_tag_t tag, void* user_data) {
+    SkTypeface& typeface = *reinterpret_cast<SkTypeface*>(user_data);
+
+    auto data = typeface.copyTableData(tag);
+    if (!data) {
+        return nullptr;
+    }
+    SkData* rawData = data.release();
+    return hb_blob_create(reinterpret_cast<char*>(rawData->writable_data()), rawData->size(),
+                          HB_MEMORY_MODE_READONLY, rawData, [](void* ctx) {
+                              SkSafeUnref(((SkData*)ctx));
+                          });
+}
+
+HBBlob stream_to_blob(std::unique_ptr<SkStreamAsset> asset) {
+    size_t size = asset->getLength();
+    HBBlob blob;
+    if (const void* base = asset->getMemoryBase()) {
+        blob.reset(hb_blob_create((const char*)base, SkToUInt(size),
+                                  HB_MEMORY_MODE_READONLY, asset.release(),
+                                  [](void* p) { delete (SkStreamAsset*)p; }));
+    } else {
+        // SkDebugf("Extra SkStreamAsset copy\n");
+        void* ptr = size ? sk_malloc_throw(size) : nullptr;
+        asset->read(ptr, size);
+        blob.reset(hb_blob_create((char*)ptr, SkToUInt(size),
+                                  HB_MEMORY_MODE_READONLY, ptr, sk_free));
+    }
+    SkASSERT(blob);
+    hb_blob_make_immutable(blob.get());
+    return blob;
+}
+
+SkDEBUGCODE(static hb_user_data_key_t gDataIdKey;)
+
+HBFace create_hb_face(const SkTypeface& typeface) {
+    int index = 0;
+    std::unique_ptr<SkStreamAsset> typefaceAsset = typeface.openExistingStream(&index);
+    HBFace face;
+    if (typefaceAsset && typefaceAsset->getMemoryBase()) {
+        HBBlob blob(stream_to_blob(std::move(typefaceAsset)));
+        // hb_face_create always succeeds. Check that the format is minimally recognized first.
+        // hb_face_create_for_tables may still create a working hb_face.
+        // See https://github.com/harfbuzz/harfbuzz/issues/248 .
+        unsigned int num_hb_faces = hb_face_count(blob.get());
+        if (0 < num_hb_faces && (unsigned)index < num_hb_faces) {
+            face.reset(hb_face_create(blob.get(), (unsigned)index));
+            // Check the number of glyphs as a basic sanitization step.
+            if (face && hb_face_get_glyph_count(face.get()) == 0) {
+                face.reset();
+            }
+        }
+    }
+    if (!face) {
+        face.reset(hb_face_create_for_tables(
+            skhb_get_table,
+            const_cast<SkTypeface*>(SkRef(&typeface)),
+            [](void* user_data){ SkSafeUnref(reinterpret_cast<SkTypeface*>(user_data)); }));
+        hb_face_set_index(face.get(), (unsigned)index);
+    }
+    SkASSERT(face);
+    if (!face) {
+        return nullptr;
+    }
+    hb_face_set_upem(face.get(), typeface.getUnitsPerEm());
+
+    SkDEBUGCODE(
+        hb_face_set_user_data(face.get(), &gDataIdKey, const_cast<SkTypeface*>(&typeface),
+                              nullptr, false);
+    )
+
+    return face;
+}
+
+HBFont create_typeface_hb_font(const SkTypeface& typeface) {
+    HBFace face(create_hb_face(typeface));
+    if (!face) {
+        return nullptr;
+    }
+
+    HBFont otFont(hb_font_create(face.get()));
+    SkASSERT(otFont);
+    if (!otFont) {
+        return nullptr;
+    }
+    hb_ot_font_set_funcs(otFont.get());
+    int axis_count = typeface.getVariationDesignPosition(nullptr, 0);
+    if (axis_count > 0) {
+        AutoSTMalloc<4, SkFontArguments::VariationPosition::Coordinate> axis_values(axis_count);
+        if (typeface.getVariationDesignPosition(axis_values, axis_count) == axis_count) {
+            hb_font_set_variations(otFont.get(),
+                                   reinterpret_cast<hb_variation_t*>(axis_values.get()),
+                                   axis_count);
+        }
+    }
+
+    return otFont;
+}
+
+HBFont create_sub_hb_font(const SkFont& font, const HBFont& typefaceFont) {
+    SkDEBUGCODE(
+        hb_face_t* face = hb_font_get_face(typefaceFont.get());
+        void* dataId = hb_face_get_user_data(face, &gDataIdKey);
+        SkASSERT(dataId == font.getTypeface());
+    )
+
+    // Creating a sub font means that non-available functions
+    // are found from the parent.
+    HBFont skFont(hb_font_create_sub_font(typefaceFont.get()));
+    hb_font_set_funcs(skFont.get(), skhb_get_font_funcs(),
+                      reinterpret_cast<void *>(new SkFont(font)),
+                      [](void* user_data){ delete reinterpret_cast<SkFont*>(user_data); });
+    int scale = skhb_position(font.getSize());
+    hb_font_set_scale(skFont.get(), scale, scale);
+
+    return skFont;
+}
+
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+class SkUnicodeHbScriptRunIterator final: public SkShaper::ScriptRunIterator {
+public:
+    SkUnicodeHbScriptRunIterator(const char* utf8,
+                                 size_t utf8Bytes,
+                                 hb_script_t defaultScript)
+            : fCurrent(utf8)
+            , fBegin(utf8)
+            , fEnd(fCurrent + utf8Bytes)
+            , fCurrentScript(defaultScript) {}
+    hb_script_t hb_script_for_unichar(SkUnichar u) {
+         return hb_unicode_script(hb_unicode_funcs_get_default(), u);
+    }
+    void consume() override {
+        SkASSERT(fCurrent < fEnd);
+        SkUnichar u = utf8_next(&fCurrent, fEnd);
+        fCurrentScript = hb_script_for_unichar(u);
+        while (fCurrent < fEnd) {
+            const char* prev = fCurrent;
+            u = utf8_next(&fCurrent, fEnd);
+            const hb_script_t script = hb_script_for_unichar(u);
+            if (script != fCurrentScript) {
+                if (fCurrentScript == HB_SCRIPT_INHERITED || fCurrentScript == HB_SCRIPT_COMMON) {
+                    fCurrentScript = script;
+                } else if (script == HB_SCRIPT_INHERITED || script == HB_SCRIPT_COMMON) {
+                    continue;
+                } else {
+                    fCurrent = prev;
+                    break;
+                }
+            }
+        }
+        if (fCurrentScript == HB_SCRIPT_INHERITED) {
+            fCurrentScript = HB_SCRIPT_COMMON;
+        }
+    }
+    size_t endOfCurrentRun() const override {
+        return fCurrent - fBegin;
+    }
+    bool atEnd() const override {
+        return fCurrent == fEnd;
+    }
+
+    SkFourByteTag currentScript() const override {
+        return SkSetFourByteTag(HB_UNTAG(fCurrentScript));
+    }
+private:
+    char const * fCurrent;
+    char const * const fBegin;
+    char const * const fEnd;
+    hb_script_t fCurrentScript;
+};
+
+class RunIteratorQueue {
+public:
+    void insert(SkShaper::RunIterator* runIterator, int priority) {
+        fEntries.insert({runIterator, priority});
+    }
+
+    bool advanceRuns() {
+        const SkShaper::RunIterator* leastRun = fEntries.peek().runIterator;
+        if (leastRun->atEnd()) {
+            SkASSERT(this->allRunsAreAtEnd());
+            return false;
+        }
+        const size_t leastEnd = leastRun->endOfCurrentRun();
+        SkShaper::RunIterator* currentRun = nullptr;
+        SkDEBUGCODE(size_t previousEndOfCurrentRun);
+        while ((currentRun = fEntries.peek().runIterator)->endOfCurrentRun() <= leastEnd) {
+            int priority = fEntries.peek().priority;
+            fEntries.pop();
+            SkDEBUGCODE(previousEndOfCurrentRun = currentRun->endOfCurrentRun());
+            currentRun->consume();
+            SkASSERT(previousEndOfCurrentRun < currentRun->endOfCurrentRun());
+            fEntries.insert({currentRun, priority});
+        }
+        return true;
+    }
+
+    size_t endOfCurrentRun() const {
+        return fEntries.peek().runIterator->endOfCurrentRun();
+    }
+
+private:
+    bool allRunsAreAtEnd() const {
+        for (int i = 0; i < fEntries.count(); ++i) {
+            if (!fEntries.at(i).runIterator->atEnd()) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    struct Entry {
+        SkShaper::RunIterator* runIterator;
+        int priority;
+    };
+    static bool CompareEntry(Entry const& a, Entry const& b) {
+        size_t aEnd = a.runIterator->endOfCurrentRun();
+        size_t bEnd = b.runIterator->endOfCurrentRun();
+        return aEnd  < bEnd || (aEnd == bEnd && a.priority < b.priority);
+    }
+    SkTDPQueue<Entry, CompareEntry> fEntries;
+};
+
+struct ShapedGlyph {
+    SkGlyphID fID;
+    uint32_t fCluster;
+    SkPoint fOffset;
+    SkVector fAdvance;
+    bool fMayLineBreakBefore;
+    bool fMustLineBreakBefore;
+    bool fHasVisual;
+    bool fGraphemeBreakBefore;
+    bool fUnsafeToBreak;
+};
+struct ShapedRun {
+    ShapedRun(SkShaper::RunHandler::Range utf8Range, const SkFont& font, SkBidiIterator::Level level,
+              std::unique_ptr<ShapedGlyph[]> glyphs, size_t numGlyphs, SkVector advance = {0, 0})
+        : fUtf8Range(utf8Range), fFont(font), fLevel(level)
+        , fGlyphs(std::move(glyphs)), fNumGlyphs(numGlyphs), fAdvance(advance)
+    {}
+
+    SkShaper::RunHandler::Range fUtf8Range;
+    SkFont fFont;
+    SkBidiIterator::Level fLevel;
+    std::unique_ptr<ShapedGlyph[]> fGlyphs;
+    size_t fNumGlyphs;
+    SkVector fAdvance;
+
+    static_assert(::sk_is_trivially_relocatable<decltype(fUtf8Range)>::value);
+    static_assert(::sk_is_trivially_relocatable<decltype(fFont)>::value);
+    static_assert(::sk_is_trivially_relocatable<decltype(fLevel)>::value);
+    static_assert(::sk_is_trivially_relocatable<decltype(fGlyphs)>::value);
+    static_assert(::sk_is_trivially_relocatable<decltype(fAdvance)>::value);
+
+    using sk_is_trivially_relocatable = std::true_type;
+};
+struct ShapedLine {
+    TArray<ShapedRun> runs;
+    SkVector fAdvance = { 0, 0 };
+};
+
+constexpr bool is_LTR(SkBidiIterator::Level level) {
+    return (level & 1) == 0;
+}
+
+void append(SkShaper::RunHandler* handler, const SkShaper::RunHandler::RunInfo& runInfo,
+                   const ShapedRun& run, size_t startGlyphIndex, size_t endGlyphIndex) {
+    SkASSERT(startGlyphIndex <= endGlyphIndex);
+    const size_t glyphLen = endGlyphIndex - startGlyphIndex;
+
+    const auto buffer = handler->runBuffer(runInfo);
+    SkASSERT(buffer.glyphs);
+    SkASSERT(buffer.positions);
+
+    SkVector advance = {0,0};
+    for (size_t i = 0; i < glyphLen; i++) {
+        // Glyphs are in logical order, but output ltr since PDF readers seem to expect that.
+        const ShapedGlyph& glyph = run.fGlyphs[is_LTR(run.fLevel) ? startGlyphIndex + i
+                                                                  : endGlyphIndex - 1 - i];
+        buffer.glyphs[i] = glyph.fID;
+        if (buffer.offsets) {
+            buffer.positions[i] = advance + buffer.point;
+            buffer.offsets[i] = glyph.fOffset;
+        } else {
+            buffer.positions[i] = advance + buffer.point + glyph.fOffset;
+        }
+        if (buffer.clusters) {
+            buffer.clusters[i] = glyph.fCluster;
+        }
+        advance += glyph.fAdvance;
+    }
+    handler->commitRunBuffer(runInfo);
+}
+
+void emit(SkUnicode* unicode, const ShapedLine& line, SkShaper::RunHandler* handler) {
+    // Reorder the runs and glyphs per line and write them out.
+    handler->beginLine();
+
+    int numRuns = line.runs.size();
+    AutoSTMalloc<4, SkBidiIterator::Level> runLevels(numRuns);
+    for (int i = 0; i < numRuns; ++i) {
+        runLevels[i] = line.runs[i].fLevel;
+    }
+    AutoSTMalloc<4, int32_t> logicalFromVisual(numRuns);
+    unicode->reorderVisual(runLevels, numRuns, logicalFromVisual);
+
+    for (int i = 0; i < numRuns; ++i) {
+        int logicalIndex = logicalFromVisual[i];
+
+        const auto& run = line.runs[logicalIndex];
+        const SkShaper::RunHandler::RunInfo info = {
+            run.fFont,
+            run.fLevel,
+            run.fAdvance,
+            run.fNumGlyphs,
+            run.fUtf8Range
+        };
+        handler->runInfo(info);
+    }
+    handler->commitRunInfo();
+    for (int i = 0; i < numRuns; ++i) {
+        int logicalIndex = logicalFromVisual[i];
+
+        const auto& run = line.runs[logicalIndex];
+        const SkShaper::RunHandler::RunInfo info = {
+            run.fFont,
+            run.fLevel,
+            run.fAdvance,
+            run.fNumGlyphs,
+            run.fUtf8Range
+        };
+        append(handler, info, run, 0, run.fNumGlyphs);
+    }
+
+    handler->commitLine();
+}
+
+struct ShapedRunGlyphIterator {
+    ShapedRunGlyphIterator(const TArray<ShapedRun>& origRuns)
+        : fRuns(&origRuns), fRunIndex(0), fGlyphIndex(0)
+    { }
+
+    ShapedRunGlyphIterator(const ShapedRunGlyphIterator& that) = default;
+    ShapedRunGlyphIterator& operator=(const ShapedRunGlyphIterator& that) = default;
+    bool operator==(const ShapedRunGlyphIterator& that) const {
+        return fRuns == that.fRuns &&
+               fRunIndex == that.fRunIndex &&
+               fGlyphIndex == that.fGlyphIndex;
+    }
+    bool operator!=(const ShapedRunGlyphIterator& that) const {
+        return fRuns != that.fRuns ||
+               fRunIndex != that.fRunIndex ||
+               fGlyphIndex != that.fGlyphIndex;
+    }
+
+    ShapedGlyph* next() {
+        const TArray<ShapedRun>& runs = *fRuns;
+        SkASSERT(fRunIndex < runs.size());
+        SkASSERT(fGlyphIndex < runs[fRunIndex].fNumGlyphs);
+
+        ++fGlyphIndex;
+        if (fGlyphIndex == runs[fRunIndex].fNumGlyphs) {
+            fGlyphIndex = 0;
+            ++fRunIndex;
+            if (fRunIndex >= runs.size()) {
+                return nullptr;
+            }
+        }
+        return &runs[fRunIndex].fGlyphs[fGlyphIndex];
+    }
+
+    ShapedGlyph* current() {
+        const TArray<ShapedRun>& runs = *fRuns;
+        if (fRunIndex >= runs.size()) {
+            return nullptr;
+        }
+        return &runs[fRunIndex].fGlyphs[fGlyphIndex];
+    }
+
+    const TArray<ShapedRun>* fRuns;
+    int fRunIndex;
+    size_t fGlyphIndex;
+};
+
+class ShaperHarfBuzz : public SkShaper {
+public:
+    ShaperHarfBuzz(sk_sp<SkUnicode>,
+                   HBBuffer,
+                   sk_sp<SkFontMgr>);
+
+protected:
+    sk_sp<SkUnicode> fUnicode;
+
+    ShapedRun shape(const char* utf8, size_t utf8Bytes,
+                    const char* utf8Start,
+                    const char* utf8End,
+                    const BiDiRunIterator&,
+                    const LanguageRunIterator&,
+                    const ScriptRunIterator&,
+                    const FontRunIterator&,
+                    const Feature*, size_t featuresSize) const;
+private:
+    const sk_sp<SkFontMgr> fFontMgr; // for fallback
+    HBBuffer               fBuffer;
+    hb_language_t          fUndefinedLanguage;
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    void shape(const char* utf8, size_t utf8Bytes,
+               const SkFont&,
+               bool leftToRight,
+               SkScalar width,
+               RunHandler*) const override;
+
+    void shape(const char* utf8Text, size_t textBytes,
+               FontRunIterator&,
+               BiDiRunIterator&,
+               ScriptRunIterator&,
+               LanguageRunIterator&,
+               SkScalar width,
+               RunHandler*) const override;
+#endif
+
+    void shape(const char* utf8Text, size_t textBytes,
+               FontRunIterator&,
+               BiDiRunIterator&,
+               ScriptRunIterator&,
+               LanguageRunIterator&,
+               const Feature*, size_t featuresSize,
+               SkScalar width,
+               RunHandler*) const override;
+
+    virtual void wrap(char const * const utf8, size_t utf8Bytes,
+                      const BiDiRunIterator&,
+                      const LanguageRunIterator&,
+                      const ScriptRunIterator&,
+                      const FontRunIterator&,
+                      RunIteratorQueue& runSegmenter,
+                      const Feature*, size_t featuresSize,
+                      SkScalar width,
+                      RunHandler*) const = 0;
+};
+
+class ShaperDrivenWrapper : public ShaperHarfBuzz {
+public:
+    using ShaperHarfBuzz::ShaperHarfBuzz;
+private:
+    void wrap(char const * const utf8, size_t utf8Bytes,
+              const BiDiRunIterator&,
+              const LanguageRunIterator&,
+              const ScriptRunIterator&,
+              const FontRunIterator&,
+              RunIteratorQueue& runSegmenter,
+              const Feature*, size_t featuresSize,
+              SkScalar width,
+              RunHandler*) const override;
+};
+
+class ShapeThenWrap : public ShaperHarfBuzz {
+public:
+    using ShaperHarfBuzz::ShaperHarfBuzz;
+private:
+    void wrap(char const * const utf8, size_t utf8Bytes,
+              const BiDiRunIterator&,
+              const LanguageRunIterator&,
+              const ScriptRunIterator&,
+              const FontRunIterator&,
+              RunIteratorQueue& runSegmenter,
+              const Feature*, size_t featuresSize,
+              SkScalar width,
+              RunHandler*) const override;
+};
+
+class ShapeDontWrapOrReorder : public ShaperHarfBuzz {
+public:
+    using ShaperHarfBuzz::ShaperHarfBuzz;
+private:
+    void wrap(char const * const utf8, size_t utf8Bytes,
+              const BiDiRunIterator&,
+              const LanguageRunIterator&,
+              const ScriptRunIterator&,
+              const FontRunIterator&,
+              RunIteratorQueue& runSegmenter,
+              const Feature*, size_t featuresSize,
+              SkScalar width,
+              RunHandler*) const override;
+};
+
+ShaperHarfBuzz::ShaperHarfBuzz(sk_sp<SkUnicode> unicode,
+                               HBBuffer buffer,
+                               sk_sp<SkFontMgr> fallback)
+    : fUnicode(unicode)
+    , fFontMgr(fallback ? std::move(fallback) : SkFontMgr::RefEmpty())
+    , fBuffer(std::move(buffer))
+    , fUndefinedLanguage(hb_language_from_string("und", -1)) {
+#if defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    SkASSERT(fUnicode);
+#endif
+}
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+void ShaperHarfBuzz::shape(const char* utf8,
+                           size_t utf8Bytes,
+                           const SkFont& srcFont,
+                           bool leftToRight,
+                           SkScalar width,
+                           RunHandler* handler) const {
+    SkBidiIterator::Level defaultLevel = leftToRight ? SkBidiIterator::kLTR : SkBidiIterator::kRTL;
+    std::unique_ptr<BiDiRunIterator> bidi(
+            SkShapers::unicode::BidiRunIterator(fUnicode, utf8, utf8Bytes, defaultLevel));
+
+    if (!bidi) {
+        return;
+    }
+
+    std::unique_ptr<LanguageRunIterator> language(MakeStdLanguageRunIterator(utf8, utf8Bytes));
+    if (!language) {
+        return;
+    }
+
+    std::unique_ptr<ScriptRunIterator> script(SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes));
+    if (!script) {
+        return;
+    }
+
+    std::unique_ptr<FontRunIterator> font(
+                MakeFontMgrRunIterator(utf8, utf8Bytes, srcFont, fFontMgr));
+    if (!font) {
+        return;
+    }
+
+    this->shape(utf8, utf8Bytes, *font, *bidi, *script, *language, width, handler);
+}
+
+void ShaperHarfBuzz::shape(const char* utf8,
+                           size_t utf8Bytes,
+                           FontRunIterator& font,
+                           BiDiRunIterator& bidi,
+                           ScriptRunIterator& script,
+                           LanguageRunIterator& language,
+                           SkScalar width,
+                           RunHandler* handler) const {
+    this->shape(utf8, utf8Bytes, font, bidi, script, language, nullptr, 0, width, handler);
+}
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+void ShaperHarfBuzz::shape(const char* utf8,
+                           size_t utf8Bytes,
+                           FontRunIterator& font,
+                           BiDiRunIterator& bidi,
+                           ScriptRunIterator& script,
+                           LanguageRunIterator& language,
+                           const Feature* features,
+                           size_t featuresSize,
+                           SkScalar width,
+                           RunHandler* handler) const {
+    SkASSERT(handler);
+    RunIteratorQueue runSegmenter;
+    runSegmenter.insert(&font,     3); // The font iterator is always run last in case of tie.
+    runSegmenter.insert(&bidi,     2);
+    runSegmenter.insert(&script,   1);
+    runSegmenter.insert(&language, 0);
+
+    this->wrap(utf8, utf8Bytes, bidi, language, script, font, runSegmenter,
+               features, featuresSize, width, handler);
+}
+
+void ShaperDrivenWrapper::wrap(char const * const utf8, size_t utf8Bytes,
+                               const BiDiRunIterator& bidi,
+                               const LanguageRunIterator& language,
+                               const ScriptRunIterator& script,
+                               const FontRunIterator& font,
+                               RunIteratorQueue& runSegmenter,
+                               const Feature* features, size_t featuresSize,
+                               SkScalar width,
+                               RunHandler* handler) const
+{
+    ShapedLine line;
+
+    const char* utf8Start = nullptr;
+    const char* utf8End = utf8;
+    SkUnicodeBreak lineBreakIterator;
+    SkString currentLanguage;
+    while (runSegmenter.advanceRuns()) {  // For each item
+        utf8Start = utf8End;
+        utf8End = utf8 + runSegmenter.endOfCurrentRun();
+
+        ShapedRun model(RunHandler::Range(), SkFont(), 0, nullptr, 0);
+        bool modelNeedsRegenerated = true;
+        int modelGlyphOffset = 0;
+
+        struct TextProps {
+            int glyphLen = 0;
+            SkVector advance = {0, 0};
+        };
+        // map from character position to [safe to break, glyph position, advance]
+        std::unique_ptr<TextProps[]> modelText;
+        int modelTextOffset = 0;
+        SkVector modelAdvanceOffset = {0, 0};
+
+        while (utf8Start < utf8End) {  // While there are still code points left in this item
+            size_t utf8runLength = utf8End - utf8Start;
+            if (modelNeedsRegenerated) {
+                model = shape(utf8, utf8Bytes,
+                              utf8Start, utf8End,
+                              bidi, language, script, font,
+                              features, featuresSize);
+                modelGlyphOffset = 0;
+
+                SkVector advance = {0, 0};
+                modelText = std::make_unique<TextProps[]>(utf8runLength + 1);
+                size_t modelStartCluster = utf8Start - utf8;
+                size_t previousCluster = 0;
+                for (size_t i = 0; i < model.fNumGlyphs; ++i) {
+                    SkASSERT(modelStartCluster <= model.fGlyphs[i].fCluster);
+                    SkASSERT(                     model.fGlyphs[i].fCluster < (size_t)(utf8End - utf8));
+                    if (!model.fGlyphs[i].fUnsafeToBreak) {
+                        // Store up to the first glyph in the cluster.
+                        size_t currentCluster = model.fGlyphs[i].fCluster - modelStartCluster;
+                        if (previousCluster != currentCluster) {
+                            previousCluster  = currentCluster;
+                            modelText[currentCluster].glyphLen = i;
+                            modelText[currentCluster].advance = advance;
+                        }
+                    }
+                    advance += model.fGlyphs[i].fAdvance;
+                }
+                // Assume it is always safe to break after the end of an item
+                modelText[utf8runLength].glyphLen = model.fNumGlyphs;
+                modelText[utf8runLength].advance = model.fAdvance;
+                modelTextOffset = 0;
+                modelAdvanceOffset = {0, 0};
+                modelNeedsRegenerated = false;
+            }
+
+            // TODO: break iterator per item, but just reset position if needed?
+            // Maybe break iterator with model?
+            if (!lineBreakIterator || !currentLanguage.equals(language.currentLanguage())) {
+                currentLanguage = language.currentLanguage();
+                lineBreakIterator = fUnicode->makeBreakIterator(currentLanguage.c_str(),
+                                                                SkUnicode::BreakType::kLines);
+                if (!lineBreakIterator) {
+                    return;
+                }
+            }
+            if (!lineBreakIterator->setText(utf8Start, utf8runLength)) {
+                return;
+            }
+            SkBreakIterator& breakIterator = *lineBreakIterator;
+
+            ShapedRun best(RunHandler::Range(), SkFont(), 0, nullptr, 0,
+                           { SK_ScalarNegativeInfinity, SK_ScalarNegativeInfinity });
+            bool bestIsInvalid = true;
+            bool bestUsesModelForGlyphs = false;
+            SkScalar widthLeft = width - line.fAdvance.fX;
+
+            for (int32_t breakIteratorCurrent = breakIterator.next();
+                 !breakIterator.isDone();
+                 breakIteratorCurrent = breakIterator.next())
+            {
+                // TODO: if past a safe to break, future safe to break will be at least as long
+
+                // TODO: adjust breakIteratorCurrent by ignorable whitespace
+                bool candidateUsesModelForGlyphs = false;
+                ShapedRun candidate = [&](const TextProps& props){
+                    if (props.glyphLen) {
+                        candidateUsesModelForGlyphs = true;
+                        return ShapedRun(RunHandler::Range(utf8Start - utf8, breakIteratorCurrent),
+                                         font.currentFont(), bidi.currentLevel(),
+                                         std::unique_ptr<ShapedGlyph[]>(),
+                                         props.glyphLen - modelGlyphOffset,
+                                         props.advance - modelAdvanceOffset);
+                    } else {
+                        return shape(utf8, utf8Bytes,
+                                     utf8Start, utf8Start + breakIteratorCurrent,
+                                     bidi, language, script, font,
+                                     features, featuresSize);
+                    }
+                }(modelText[breakIteratorCurrent + modelTextOffset]);
+                auto score = [widthLeft](const ShapedRun& run) -> SkScalar {
+                    if (run.fAdvance.fX < widthLeft) {
+                        return run.fUtf8Range.size();
+                    } else {
+                        return widthLeft - run.fAdvance.fX;
+                    }
+                };
+                if (bestIsInvalid || score(best) < score(candidate)) {
+                    best = std::move(candidate);
+                    bestIsInvalid = false;
+                    bestUsesModelForGlyphs = candidateUsesModelForGlyphs;
+                }
+            }
+
+            // If nothing fit (best score is negative) and the line is not empty
+            if (width < line.fAdvance.fX + best.fAdvance.fX && !line.runs.empty()) {
+                emit(fUnicode.get(), line, handler);
+                line.runs.clear();
+                line.fAdvance = {0, 0};
+            } else {
+                if (bestUsesModelForGlyphs) {
+                    best.fGlyphs = std::make_unique<ShapedGlyph[]>(best.fNumGlyphs);
+                    memcpy(best.fGlyphs.get(), model.fGlyphs.get() + modelGlyphOffset,
+                           best.fNumGlyphs * sizeof(ShapedGlyph));
+                    modelGlyphOffset += best.fNumGlyphs;
+                    modelTextOffset += best.fUtf8Range.size();
+                    modelAdvanceOffset += best.fAdvance;
+                } else {
+                    modelNeedsRegenerated = true;
+                }
+                utf8Start += best.fUtf8Range.size();
+                line.fAdvance += best.fAdvance;
+                line.runs.emplace_back(std::move(best));
+
+                // If item broken, emit line (prevent remainder from accidentally fitting)
+                if (utf8Start != utf8End) {
+                    emit(fUnicode.get(), line, handler);
+                    line.runs.clear();
+                    line.fAdvance = {0, 0};
+                }
+            }
+        }
+    }
+    emit(fUnicode.get(), line, handler);
+}
+
+void ShapeThenWrap::wrap(char const * const utf8, size_t utf8Bytes,
+                         const BiDiRunIterator& bidi,
+                         const LanguageRunIterator& language,
+                         const ScriptRunIterator& script,
+                         const FontRunIterator& font,
+                         RunIteratorQueue& runSegmenter,
+                         const Feature* features, size_t featuresSize,
+                         SkScalar width,
+                         RunHandler* handler) const
+{
+    TArray<ShapedRun> runs;
+{
+    SkString currentLanguage;
+    SkUnicodeBreak lineBreakIterator;
+    SkUnicodeBreak graphemeBreakIterator;
+    bool needIteratorInit = true;
+    const char* utf8Start = nullptr;
+    const char* utf8End = utf8;
+    while (runSegmenter.advanceRuns()) {
+        utf8Start = utf8End;
+        utf8End = utf8 + runSegmenter.endOfCurrentRun();
+
+        runs.emplace_back(shape(utf8, utf8Bytes,
+                                utf8Start, utf8End,
+                                bidi, language, script, font,
+                                features, featuresSize));
+        ShapedRun& run = runs.back();
+
+        if (needIteratorInit || !currentLanguage.equals(language.currentLanguage())) {
+            currentLanguage = language.currentLanguage();
+            lineBreakIterator = fUnicode->makeBreakIterator(currentLanguage.c_str(),
+                                                            SkUnicode::BreakType::kLines);
+            if (!lineBreakIterator) {
+                return;
+            }
+            graphemeBreakIterator = fUnicode->makeBreakIterator(currentLanguage.c_str(),
+                                                                SkUnicode::BreakType::kGraphemes);
+            if (!graphemeBreakIterator) {
+                return;
+            }
+            needIteratorInit = false;
+        }
+        size_t utf8runLength = utf8End - utf8Start;
+        if (!lineBreakIterator->setText(utf8Start, utf8runLength)) {
+            return;
+        }
+        if (!graphemeBreakIterator->setText(utf8Start, utf8runLength)) {
+            return;
+        }
+
+        uint32_t previousCluster = 0xFFFFFFFF;
+        for (size_t i = 0; i < run.fNumGlyphs; ++i) {
+            ShapedGlyph& glyph = run.fGlyphs[i];
+            int32_t glyphCluster = glyph.fCluster;
+
+            int32_t lineBreakIteratorCurrent = lineBreakIterator->current();
+            while (!lineBreakIterator->isDone() && lineBreakIteratorCurrent < glyphCluster)
+            {
+                lineBreakIteratorCurrent = lineBreakIterator->next();
+            }
+            glyph.fMayLineBreakBefore = glyph.fCluster != previousCluster &&
+                                        lineBreakIteratorCurrent == glyphCluster;
+
+            int32_t graphemeBreakIteratorCurrent = graphemeBreakIterator->current();
+            while (!graphemeBreakIterator->isDone() && graphemeBreakIteratorCurrent < glyphCluster)
+            {
+                graphemeBreakIteratorCurrent = graphemeBreakIterator->next();
+            }
+            glyph.fGraphemeBreakBefore = glyph.fCluster != previousCluster &&
+                                         graphemeBreakIteratorCurrent == glyphCluster;
+
+            previousCluster = glyph.fCluster;
+        }
+    }
+}
+
+// Iterate over the glyphs in logical order to find potential line lengths.
+{
+    /** The position of the beginning of the line. */
+    ShapedRunGlyphIterator beginning(runs);
+
+    /** The position of the candidate line break. */
+    ShapedRunGlyphIterator candidateLineBreak(runs);
+    SkScalar candidateLineBreakWidth = 0;
+
+    /** The position of the candidate grapheme break. */
+    ShapedRunGlyphIterator candidateGraphemeBreak(runs);
+    SkScalar candidateGraphemeBreakWidth = 0;
+
+    /** The position of the current location. */
+    ShapedRunGlyphIterator current(runs);
+    SkScalar currentWidth = 0;
+    while (ShapedGlyph* glyph = current.current()) {
+        // 'Break' at graphemes until a line boundary, then only at line boundaries.
+        // Only break at graphemes if no line boundary is valid.
+        if (current != beginning) {
+            if (glyph->fGraphemeBreakBefore || glyph->fMayLineBreakBefore) {
+                // TODO: preserve line breaks <= grapheme breaks
+                // and prevent line breaks inside graphemes
+                candidateGraphemeBreak = current;
+                candidateGraphemeBreakWidth = currentWidth;
+                if (glyph->fMayLineBreakBefore) {
+                    candidateLineBreak = current;
+                    candidateLineBreakWidth = currentWidth;
+                }
+            }
+        }
+
+        SkScalar glyphWidth = glyph->fAdvance.fX;
+        // Break when overwidth, the glyph has a visual representation, and some space is used.
+        if (width < currentWidth + glyphWidth && glyph->fHasVisual && candidateGraphemeBreakWidth > 0){
+            if (candidateLineBreak != beginning) {
+                beginning = candidateLineBreak;
+                currentWidth -= candidateLineBreakWidth;
+                candidateGraphemeBreakWidth -= candidateLineBreakWidth;
+                candidateLineBreakWidth = 0;
+            } else if (candidateGraphemeBreak != beginning) {
+                beginning = candidateGraphemeBreak;
+                candidateLineBreak = beginning;
+                currentWidth -= candidateGraphemeBreakWidth;
+                candidateGraphemeBreakWidth = 0;
+                candidateLineBreakWidth = 0;
+            } else {
+                SK_ABORT("");
+            }
+
+            if (width < currentWidth) {
+                if (width < candidateGraphemeBreakWidth) {
+                    candidateGraphemeBreak = candidateLineBreak;
+                    candidateGraphemeBreakWidth = candidateLineBreakWidth;
+                }
+                current = candidateGraphemeBreak;
+                currentWidth = candidateGraphemeBreakWidth;
+            }
+
+            glyph = beginning.current();
+            if (glyph) {
+                glyph->fMustLineBreakBefore = true;
+            }
+
+        } else {
+            current.next();
+            currentWidth += glyphWidth;
+        }
+    }
+}
+
+// Reorder the runs and glyphs per line and write them out.
+{
+    ShapedRunGlyphIterator previousBreak(runs);
+    ShapedRunGlyphIterator glyphIterator(runs);
+    int previousRunIndex = -1;
+    while (glyphIterator.current()) {
+        const ShapedRunGlyphIterator current = glyphIterator;
+        ShapedGlyph* nextGlyph = glyphIterator.next();
+
+        if (previousRunIndex != current.fRunIndex) {
+            SkFontMetrics metrics;
+            runs[current.fRunIndex].fFont.getMetrics(&metrics);
+            previousRunIndex = current.fRunIndex;
+        }
+
+        // Nothing can be written until the baseline is known.
+        if (!(nextGlyph == nullptr || nextGlyph->fMustLineBreakBefore)) {
+            continue;
+        }
+
+        int numRuns = current.fRunIndex - previousBreak.fRunIndex + 1;
+        AutoSTMalloc<4, SkBidiIterator::Level> runLevels(numRuns);
+        for (int i = 0; i < numRuns; ++i) {
+            runLevels[i] = runs[previousBreak.fRunIndex + i].fLevel;
+        }
+        AutoSTMalloc<4, int32_t> logicalFromVisual(numRuns);
+        fUnicode->reorderVisual(runLevels, numRuns, logicalFromVisual);
+
+        // step through the runs in reverse visual order and the glyphs in reverse logical order
+        // until a visible glyph is found and force them to the end of the visual line.
+
+        handler->beginLine();
+
+        struct SubRun { const ShapedRun& run; size_t startGlyphIndex; size_t endGlyphIndex; };
+        auto makeSubRun = [&runs, &previousBreak, &current, &logicalFromVisual](size_t visualIndex){
+            int logicalIndex = previousBreak.fRunIndex + logicalFromVisual[visualIndex];
+            const auto& run = runs[logicalIndex];
+            size_t startGlyphIndex = (logicalIndex == previousBreak.fRunIndex)
+                                   ? previousBreak.fGlyphIndex
+                                   : 0;
+            size_t endGlyphIndex = (logicalIndex == current.fRunIndex)
+                                 ? current.fGlyphIndex + 1
+                                 : run.fNumGlyphs;
+            return SubRun{ run, startGlyphIndex, endGlyphIndex };
+        };
+        auto makeRunInfo = [](const SubRun& sub) {
+            uint32_t startUtf8 = sub.run.fGlyphs[sub.startGlyphIndex].fCluster;
+            uint32_t endUtf8 = (sub.endGlyphIndex < sub.run.fNumGlyphs)
+                             ? sub.run.fGlyphs[sub.endGlyphIndex].fCluster
+                             : sub.run.fUtf8Range.end();
+
+            SkVector advance = SkVector::Make(0, 0);
+            for (size_t i = sub.startGlyphIndex; i < sub.endGlyphIndex; ++i) {
+                advance += sub.run.fGlyphs[i].fAdvance;
+            }
+
+            return RunHandler::RunInfo{
+                sub.run.fFont,
+                sub.run.fLevel,
+                advance,
+                sub.endGlyphIndex - sub.startGlyphIndex,
+                RunHandler::Range(startUtf8, endUtf8 - startUtf8)
+            };
+        };
+
+        for (int i = 0; i < numRuns; ++i) {
+            handler->runInfo(makeRunInfo(makeSubRun(i)));
+        }
+        handler->commitRunInfo();
+        for (int i = 0; i < numRuns; ++i) {
+            SubRun sub = makeSubRun(i);
+            append(handler, makeRunInfo(sub), sub.run, sub.startGlyphIndex, sub.endGlyphIndex);
+        }
+
+        handler->commitLine();
+
+        previousRunIndex = -1;
+        previousBreak = glyphIterator;
+    }
+}
+}
+
+void ShapeDontWrapOrReorder::wrap(char const * const utf8, size_t utf8Bytes,
+                                  const BiDiRunIterator& bidi,
+                                  const LanguageRunIterator& language,
+                                  const ScriptRunIterator& script,
+                                  const FontRunIterator& font,
+                                  RunIteratorQueue& runSegmenter,
+                                  const Feature* features, size_t featuresSize,
+                                  SkScalar width,
+                                  RunHandler* handler) const
+{
+    sk_ignore_unused_variable(width);
+    TArray<ShapedRun> runs;
+
+    const char* utf8Start = nullptr;
+    const char* utf8End = utf8;
+    while (runSegmenter.advanceRuns()) {
+        utf8Start = utf8End;
+        utf8End = utf8 + runSegmenter.endOfCurrentRun();
+
+        runs.emplace_back(shape(utf8, utf8Bytes,
+                                utf8Start, utf8End,
+                                bidi, language, script, font,
+                                features, featuresSize));
+    }
+
+    handler->beginLine();
+    for (const auto& run : runs) {
+        const RunHandler::RunInfo info = {
+            run.fFont,
+            run.fLevel,
+            run.fAdvance,
+            run.fNumGlyphs,
+            run.fUtf8Range
+        };
+        handler->runInfo(info);
+    }
+    handler->commitRunInfo();
+    for (const auto& run : runs) {
+        const RunHandler::RunInfo info = {
+            run.fFont,
+            run.fLevel,
+            run.fAdvance,
+            run.fNumGlyphs,
+            run.fUtf8Range
+        };
+        append(handler, info, run, 0, run.fNumGlyphs);
+    }
+    handler->commitLine();
+}
+
+class HBLockedFaceCache {
+public:
+    HBLockedFaceCache(SkLRUCache<SkTypefaceID, HBFont>& lruCache, SkMutex& mutex)
+        : fLRUCache(lruCache), fMutex(mutex)
+    {
+        fMutex.acquire();
+    }
+    HBLockedFaceCache(const HBLockedFaceCache&) = delete;
+    HBLockedFaceCache& operator=(const HBLockedFaceCache&) = delete;
+    HBLockedFaceCache& operator=(HBLockedFaceCache&&) = delete;
+
+    ~HBLockedFaceCache() {
+        fMutex.release();
+    }
+
+    HBFont* find(SkTypefaceID fontId) {
+        return fLRUCache.find(fontId);
+    }
+    HBFont* insert(SkTypefaceID fontId, HBFont hbFont) {
+        return fLRUCache.insert(fontId, std::move(hbFont));
+    }
+    void reset() {
+        fLRUCache.reset();
+    }
+private:
+    SkLRUCache<SkTypefaceID, HBFont>& fLRUCache;
+    SkMutex& fMutex;
+};
+static HBLockedFaceCache get_hbFace_cache() {
+    static SkMutex gHBFaceCacheMutex;
+    static SkLRUCache<SkTypefaceID, HBFont> gHBFaceCache(100);
+    return HBLockedFaceCache(gHBFaceCache, gHBFaceCacheMutex);
+}
+
+ShapedRun ShaperHarfBuzz::shape(char const * const utf8,
+                                  size_t const utf8Bytes,
+                                  char const * const utf8Start,
+                                  char const * const utf8End,
+                                  const BiDiRunIterator& bidi,
+                                  const LanguageRunIterator& language,
+                                  const ScriptRunIterator& script,
+                                  const FontRunIterator& font,
+                                  Feature const * const features, size_t const featuresSize) const
+{
+    size_t utf8runLength = utf8End - utf8Start;
+    ShapedRun run(RunHandler::Range(utf8Start - utf8, utf8runLength),
+                  font.currentFont(), bidi.currentLevel(), nullptr, 0);
+
+    hb_buffer_t* buffer = fBuffer.get();
+    SkAutoTCallVProc<hb_buffer_t, hb_buffer_clear_contents> autoClearBuffer(buffer);
+    hb_buffer_set_content_type(buffer, HB_BUFFER_CONTENT_TYPE_UNICODE);
+    hb_buffer_set_cluster_level(buffer, HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS);
+
+    // Documentation for HB_BUFFER_FLAG_BOT/EOT at 763e5466c0a03a7c27020e1e2598e488612529a7.
+    // Currently BOT forces a dotted circle when first codepoint is a mark; EOT has no effect.
+    // Avoid adding dotted circle, re-evaluate if BOT/EOT change. See https://skbug.com/9618.
+    // hb_buffer_set_flags(buffer, HB_BUFFER_FLAG_BOT | HB_BUFFER_FLAG_EOT);
+
+    // Add precontext.
+    hb_buffer_add_utf8(buffer, utf8, utf8Start - utf8, utf8Start - utf8, 0);
+
+    // Populate the hb_buffer directly with utf8 cluster indexes.
+    const char* utf8Current = utf8Start;
+    while (utf8Current < utf8End) {
+        unsigned int cluster = utf8Current - utf8;
+        hb_codepoint_t u = utf8_next(&utf8Current, utf8End);
+        hb_buffer_add(buffer, u, cluster);
+    }
+
+    // Add postcontext.
+    hb_buffer_add_utf8(buffer, utf8Current, utf8 + utf8Bytes - utf8Current, 0, 0);
+
+    hb_direction_t direction = is_LTR(bidi.currentLevel()) ? HB_DIRECTION_LTR:HB_DIRECTION_RTL;
+    hb_buffer_set_direction(buffer, direction);
+    hb_buffer_set_script(buffer, hb_script_from_iso15924_tag((hb_tag_t)script.currentScript()));
+    // Buffers with HB_LANGUAGE_INVALID race since hb_language_get_default is not thread safe.
+    // The user must provide a language, but may provide data hb_language_from_string cannot use.
+    // Use "und" for the undefined language in this case (RFC5646 4.1 5).
+    hb_language_t hbLanguage = hb_language_from_string(language.currentLanguage(), -1);
+    if (hbLanguage == HB_LANGUAGE_INVALID) {
+        hbLanguage = fUndefinedLanguage;
+    }
+    hb_buffer_set_language(buffer, hbLanguage);
+    hb_buffer_guess_segment_properties(buffer);
+
+    // TODO: better cache HBFace (data) / hbfont (typeface)
+    // An HBFace is expensive (it sanitizes the bits).
+    // An HBFont is fairly inexpensive.
+    // An HBFace is actually tied to the data, not the typeface.
+    // The size of 100 here is completely arbitrary and used to match libtxt.
+    HBFont hbFont;
+    {
+        HBLockedFaceCache cache = get_hbFace_cache();
+        SkTypefaceID dataId = font.currentFont().getTypeface()->uniqueID();
+        HBFont* typefaceFontCached = cache.find(dataId);
+        if (!typefaceFontCached) {
+            HBFont typefaceFont(create_typeface_hb_font(*font.currentFont().getTypeface()));
+            typefaceFontCached = cache.insert(dataId, std::move(typefaceFont));
+        }
+        hbFont = create_sub_hb_font(font.currentFont(), *typefaceFontCached);
+    }
+    if (!hbFont) {
+        return run;
+    }
+
+    STArray<32, hb_feature_t> hbFeatures;
+    for (const auto& feature : SkSpan(features, featuresSize)) {
+        if (feature.end < SkTo<size_t>(utf8Start - utf8) ||
+                          SkTo<size_t>(utf8End   - utf8)  <= feature.start)
+        {
+            continue;
+        }
+        if (feature.start <= SkTo<size_t>(utf8Start - utf8) &&
+                             SkTo<size_t>(utf8End   - utf8) <= feature.end)
+        {
+            hbFeatures.push_back({ (hb_tag_t)feature.tag, feature.value,
+                                   HB_FEATURE_GLOBAL_START, HB_FEATURE_GLOBAL_END});
+        } else {
+            hbFeatures.push_back({ (hb_tag_t)feature.tag, feature.value,
+                                   SkTo<unsigned>(feature.start), SkTo<unsigned>(feature.end)});
+        }
+    }
+
+    hb_shape(hbFont.get(), buffer, hbFeatures.data(), hbFeatures.size());
+    unsigned len = hb_buffer_get_length(buffer);
+    if (len == 0) {
+        return run;
+    }
+
+    if (direction == HB_DIRECTION_RTL) {
+        // Put the clusters back in logical order.
+        // Note that the advances remain ltr.
+        hb_buffer_reverse(buffer);
+    }
+    hb_glyph_info_t* info = hb_buffer_get_glyph_infos(buffer, nullptr);
+    hb_glyph_position_t* pos = hb_buffer_get_glyph_positions(buffer, nullptr);
+
+    run = ShapedRun(RunHandler::Range(utf8Start - utf8, utf8runLength),
+                    font.currentFont(), bidi.currentLevel(),
+                    std::unique_ptr<ShapedGlyph[]>(new ShapedGlyph[len]), len);
+
+    // Undo skhb_position with (1.0/(1<<16)) and scale as needed.
+    AutoSTArray<32, SkGlyphID> glyphIDs(len);
+    for (unsigned i = 0; i < len; i++) {
+        glyphIDs[i] = info[i].codepoint;
+    }
+    AutoSTArray<32, SkRect> glyphBounds(len);
+    SkPaint p;
+    run.fFont.getBounds(glyphIDs.get(), len, glyphBounds.get(), &p);
+
+    double SkScalarFromHBPosX = +(1.52587890625e-5) * run.fFont.getScaleX();
+    double SkScalarFromHBPosY = -(1.52587890625e-5);  // HarfBuzz y-up, Skia y-down
+    SkVector runAdvance = { 0, 0 };
+    for (unsigned i = 0; i < len; i++) {
+        ShapedGlyph& glyph = run.fGlyphs[i];
+        glyph.fID = info[i].codepoint;
+        glyph.fCluster = info[i].cluster;
+        glyph.fOffset.fX = pos[i].x_offset * SkScalarFromHBPosX;
+        glyph.fOffset.fY = pos[i].y_offset * SkScalarFromHBPosY;
+        glyph.fAdvance.fX = pos[i].x_advance * SkScalarFromHBPosX;
+        glyph.fAdvance.fY = pos[i].y_advance * SkScalarFromHBPosY;
+
+        glyph.fHasVisual = !glyphBounds[i].isEmpty(); //!font->currentTypeface()->glyphBoundsAreZero(glyph.fID);
+#if SK_HB_VERSION_CHECK(1, 5, 0)
+        glyph.fUnsafeToBreak = info[i].mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
+#else
+        glyph.fUnsafeToBreak = false;
+#endif
+        glyph.fMustLineBreakBefore = false;
+
+        runAdvance += glyph.fAdvance;
+    }
+    run.fAdvance = runAdvance;
+
+    return run;
+}
+}  // namespace
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu.h"
+#endif
+
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+#endif
+
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+#endif
+
+static sk_sp<SkUnicode> get_unicode() {
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::ICU::Make()) {
+        return unicode;
+    }
+#endif  // defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::Libgrapheme::Make()) {
+        return unicode;
+    }
+#endif
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::ICU4X::Make()) {
+        return unicode;
+    }
+#endif
+    return nullptr;
+}
+
+std::unique_ptr<SkShaper::ScriptRunIterator>
+SkShaper::MakeHbIcuScriptRunIterator(const char* utf8, size_t utf8Bytes) {
+    return SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes);
+}
+
+std::unique_ptr<SkShaper::ScriptRunIterator>
+SkShaper::MakeSkUnicodeHbScriptRunIterator(const char* utf8, size_t utf8Bytes) {
+    return SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes);
+}
+
+std::unique_ptr<SkShaper::ScriptRunIterator> SkShaper::MakeSkUnicodeHbScriptRunIterator(
+        const char* utf8, size_t utf8Bytes, SkFourByteTag script) {
+    return SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes, script);
+}
+
+std::unique_ptr<SkShaper> SkShaper::MakeShaperDrivenWrapper(sk_sp<SkFontMgr> fontmgr) {
+    return SkShapers::HB::ShaperDrivenWrapper(get_unicode(), fontmgr);
+}
+
+std::unique_ptr<SkShaper> SkShaper::MakeShapeThenWrap(sk_sp<SkFontMgr> fontmgr) {
+    return SkShapers::HB::ShapeThenWrap(get_unicode(), fontmgr);
+}
+
+void SkShaper::PurgeHarfBuzzCache() { SkShapers::HB::PurgeCaches(); }
+#endif  // !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+namespace SkShapers::HB {
+std::unique_ptr<SkShaper> ShaperDrivenWrapper(sk_sp<SkUnicode> unicode,
+                                              sk_sp<SkFontMgr> fallback) {
+    if (!unicode) {
+        return nullptr;
+    }
+    HBBuffer buffer(hb_buffer_create());
+    if (!buffer) {
+        SkDEBUGF("Could not create hb_buffer");
+        return nullptr;
+    }
+    return std::make_unique<::ShaperDrivenWrapper>(
+            unicode, std::move(buffer), std::move(fallback));
+}
+
+std::unique_ptr<SkShaper> ShapeThenWrap(sk_sp<SkUnicode> unicode,
+                                        sk_sp<SkFontMgr> fallback) {
+    if (!unicode) {
+        return nullptr;
+    }
+    HBBuffer buffer(hb_buffer_create());
+    if (!buffer) {
+        SkDEBUGF("Could not create hb_buffer");
+        return nullptr;
+    }
+    return std::make_unique<::ShapeThenWrap>(
+            unicode, std::move(buffer), std::move(fallback));
+}
+
+std::unique_ptr<SkShaper> ShapeDontWrapOrReorder(sk_sp<SkUnicode> unicode,
+                                                 sk_sp<SkFontMgr> fallback) {
+    if (!unicode) {
+        return nullptr;
+    }
+    HBBuffer buffer(hb_buffer_create());
+    if (!buffer) {
+        SkDEBUGF("Could not create hb_buffer");
+        return nullptr;
+    }
+    return std::make_unique<::ShapeDontWrapOrReorder>(
+            unicode, std::move(buffer), std::move(fallback));
+}
+
+std::unique_ptr<SkShaper::ScriptRunIterator> ScriptRunIterator(const char* utf8, size_t utf8Bytes) {
+    return std::make_unique<SkUnicodeHbScriptRunIterator>(utf8, utf8Bytes, HB_SCRIPT_UNKNOWN);
+}
+std::unique_ptr<SkShaper::ScriptRunIterator> ScriptRunIterator(const char* utf8,
+                                                               size_t utf8Bytes,
+                                                               SkFourByteTag script) {
+    return std::make_unique<SkUnicodeHbScriptRunIterator>(
+            utf8, utf8Bytes, hb_script_from_iso15924_tag((hb_tag_t)script));
+}
+
+void PurgeCaches() {
+    HBLockedFaceCache cache = get_hbFace_cache();
+    cache.reset();
+}
+}  // namespace SkShapers::HB
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_primitive.cpp b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_primitive.cpp
new file mode 100644
index 00000000..92f78afd
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_primitive.cpp
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/core/SkFont.h"
+#include "include/core/SkFontTypes.h"
+#include "include/core/SkPoint.h"
+#include "include/core/SkScalar.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "src/base/SkUTF.h"
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+#include "include/core/SkFontMgr.h"
+#endif
+
+#include <cstdint>
+#include <cstring>
+#include <memory>
+
+class SkShaperPrimitive : public SkShaper {
+public:
+    SkShaperPrimitive() {}
+private:
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+    void shape(const char* utf8, size_t utf8Bytes,
+               const SkFont& srcFont,
+               bool leftToRight,
+               SkScalar width,
+               RunHandler*) const override;
+
+    void shape(const char* utf8, size_t utf8Bytes,
+               FontRunIterator&,
+               BiDiRunIterator&,
+               ScriptRunIterator&,
+               LanguageRunIterator&,
+               SkScalar width,
+               RunHandler*) const override;
+#endif
+
+    void shape(const char* utf8, size_t utf8Bytes,
+               FontRunIterator&,
+               BiDiRunIterator&,
+               ScriptRunIterator&,
+               LanguageRunIterator&,
+               const Feature*, size_t featureSize,
+               SkScalar width,
+               RunHandler*) const override;
+};
+
+static inline bool is_breaking_whitespace(SkUnichar c) {
+    switch (c) {
+        case 0x0020: // SPACE
+        //case 0x00A0: // NO-BREAK SPACE
+        case 0x1680: // OGHAM SPACE MARK
+        case 0x180E: // MONGOLIAN VOWEL SEPARATOR
+        case 0x2000: // EN QUAD
+        case 0x2001: // EM QUAD
+        case 0x2002: // EN SPACE (nut)
+        case 0x2003: // EM SPACE (mutton)
+        case 0x2004: // THREE-PER-EM SPACE (thick space)
+        case 0x2005: // FOUR-PER-EM SPACE (mid space)
+        case 0x2006: // SIX-PER-EM SPACE
+        case 0x2007: // FIGURE SPACE
+        case 0x2008: // PUNCTUATION SPACE
+        case 0x2009: // THIN SPACE
+        case 0x200A: // HAIR SPACE
+        case 0x200B: // ZERO WIDTH SPACE
+        case 0x202F: // NARROW NO-BREAK SPACE
+        case 0x205F: // MEDIUM MATHEMATICAL SPACE
+        case 0x3000: // IDEOGRAPHIC SPACE
+        //case 0xFEFF: // ZERO WIDTH NO-BREAK SPACE
+            return true;
+        default:
+            return false;
+    }
+}
+
+static size_t linebreak(const char text[], const char stop[],
+                        const SkFont& font, SkScalar width,
+                        SkScalar* advance,
+                        size_t* trailing)
+{
+    SkScalar accumulatedWidth = 0;
+    int glyphIndex = 0;
+    const char* start = text;
+    const char* wordStart = text;
+    bool prevWS = true;
+    *trailing = 0;
+
+    while (text < stop) {
+        const char* prevText = text;
+        SkUnichar uni = SkUTF::NextUTF8(&text, stop);
+        accumulatedWidth += advance[glyphIndex++];
+        bool currWS = is_breaking_whitespace(uni);
+
+        if (!currWS && prevWS) {
+            wordStart = prevText;
+        }
+        prevWS = currWS;
+
+        if (width < accumulatedWidth) {
+            bool consumeWhitespace = false;
+            if (currWS) {
+                // previous fit, put this and following whitespace in trailing
+                if (prevText == start) {
+                    // don't put this in trailing if it's the first thing
+                    prevText = text;
+                }
+                consumeWhitespace = true;
+            } else if (wordStart != start) {
+                // backup to the last whitespace that fit
+                text = wordStart;
+            } else if (prevText > start) {
+                // backup to just before the glyph that didn't fit
+                text = prevText;
+            } else {
+                // let it overflow, put any following whitespace in trailing
+                prevText = text;
+                consumeWhitespace = true;
+            }
+            if (consumeWhitespace) {
+                const char* next = text;
+                while (next < stop && is_breaking_whitespace(SkUTF::NextUTF8(&next, stop))) {
+                    text = next;
+                }
+                if (trailing) {
+                    *trailing = text - prevText;
+                }
+            }
+            break;
+        }
+    }
+
+    return text - start;
+}
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+void SkShaperPrimitive::shape(const char* utf8,
+                              size_t utf8Bytes,
+                              FontRunIterator& font,
+                              BiDiRunIterator& bidi,
+                              ScriptRunIterator& script,
+                              LanguageRunIterator& lang,
+                              SkScalar width,
+                              RunHandler* handler) const {
+    return this->shape(utf8, utf8Bytes, font, bidi, script, lang, nullptr, 0, width, handler);
+}
+
+void SkShaperPrimitive::shape(const char* utf8,
+                              size_t utf8Bytes,
+                              const SkFont& font,
+                              bool leftToRight,
+                              SkScalar width,
+                              RunHandler* handler) const {
+    std::unique_ptr<FontRunIterator> fontRuns(
+            MakeFontMgrRunIterator(utf8, utf8Bytes, font, nullptr));
+    if (!fontRuns) {
+        return;
+    }
+    // bidi, script, and lang are all unused so we can construct them with empty data.
+    TrivialBiDiRunIterator bidi{0, 0};
+    TrivialScriptRunIterator script{0, 0};
+    TrivialLanguageRunIterator lang{nullptr, 0};
+    return this->shape(utf8, utf8Bytes, *fontRuns, bidi, script, lang, nullptr, 0, width, handler);
+}
+#endif
+
+void SkShaperPrimitive::shape(const char* utf8,
+                              size_t utf8Bytes,
+                              FontRunIterator& fontRuns,
+                              BiDiRunIterator&,
+                              ScriptRunIterator&,
+                              LanguageRunIterator&,
+                              const Feature*,
+                              size_t,
+                              SkScalar width,
+                              RunHandler* handler) const {
+    SkFont font;
+    if (!fontRuns.atEnd()) {
+        fontRuns.consume();
+        font = fontRuns.currentFont();
+    }
+    SkASSERT(font.getTypeface());
+
+    int glyphCount = font.countText(utf8, utf8Bytes, SkTextEncoding::kUTF8);
+    if (glyphCount < 0) {
+        return;
+    }
+
+    std::unique_ptr<SkGlyphID[]> glyphs(new SkGlyphID[glyphCount]);
+    font.textToGlyphs(utf8, utf8Bytes, SkTextEncoding::kUTF8, glyphs.get(), glyphCount);
+
+    std::unique_ptr<SkScalar[]> advances(new SkScalar[glyphCount]);
+    font.getWidthsBounds(glyphs.get(), glyphCount, advances.get(), nullptr, nullptr);
+
+    size_t glyphOffset = 0;
+    size_t utf8Offset = 0;
+    do {
+        size_t bytesCollapsed;
+        size_t bytesConsumed = linebreak(utf8, utf8 + utf8Bytes, font, width,
+                                         advances.get() + glyphOffset, &bytesCollapsed);
+        size_t bytesVisible = bytesConsumed - bytesCollapsed;
+
+        size_t numGlyphs = SkUTF::CountUTF8(utf8, bytesVisible);
+        const RunHandler::RunInfo info = {
+            font,
+            0,
+            { font.measureText(utf8, bytesVisible, SkTextEncoding::kUTF8), 0 },
+            numGlyphs,
+            RunHandler::Range(utf8Offset, bytesVisible)
+        };
+        handler->beginLine();
+        if (info.glyphCount) {
+            handler->runInfo(info);
+        }
+        handler->commitRunInfo();
+        if (info.glyphCount) {
+            const auto buffer = handler->runBuffer(info);
+
+            memcpy(buffer.glyphs, glyphs.get() + glyphOffset, info.glyphCount * sizeof(SkGlyphID));
+            SkPoint position = buffer.point;
+            for (size_t i = 0; i < info.glyphCount; ++i) {
+                buffer.positions[i] = position;
+                position.fX += advances[i + glyphOffset];
+            }
+            if (buffer.clusters) {
+                const char* txtPtr = utf8;
+                for (size_t i = 0; i < info.glyphCount; ++i) {
+                    // Each character maps to exactly one glyph.
+                    buffer.clusters[i] = SkToU32(txtPtr - utf8 + utf8Offset);
+                    SkUTF::NextUTF8(&txtPtr, utf8 + utf8Bytes);
+                }
+            }
+            handler->commitRunBuffer(info);
+        }
+        handler->commitLine();
+
+        glyphOffset += SkUTF::CountUTF8(utf8, bytesConsumed);
+        utf8Offset += bytesConsumed;
+        utf8 += bytesConsumed;
+        utf8Bytes -= bytesConsumed;
+    } while (0 < utf8Bytes);
+}
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+std::unique_ptr<SkShaper> SkShaper::MakePrimitive() { return SkShapers::Primitive::PrimitiveText(); }
+#endif
+
+namespace SkShapers::Primitive {
+std::unique_ptr<SkShaper> PrimitiveText() { return std::make_unique<SkShaperPrimitive>(); }
+}  // namespace SkShapers
diff --git a/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_skunicode.cpp b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_skunicode.cpp
new file mode 100644
index 00000000..84e83061
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/src/SkShaper_skunicode.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2023 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/core/SkRefCnt.h"
+#include "include/private/base/SkAssert.h"
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkTFitsIn.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/skshaper/include/SkShaper_skunicode.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkUTF.h"
+
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <utility>
+
+using SkUnicodeBidi = std::unique_ptr<SkBidiIterator>;
+
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+class SkUnicodeBidiRunIterator final : public SkShaper::BiDiRunIterator {
+public:
+    SkUnicodeBidiRunIterator(const char* utf8, const char* end, SkUnicodeBidi bidi)
+        : fBidi(std::move(bidi))
+        , fEndOfCurrentRun(utf8)
+        , fBegin(utf8)
+        , fEnd(end)
+        , fUTF16LogicalPosition(0)
+        , fLevel(SkBidiIterator::kLTR)
+    {}
+
+    void consume() override {
+        SkASSERT(fUTF16LogicalPosition < fBidi->getLength());
+        int32_t endPosition = fBidi->getLength();
+        fLevel = fBidi->getLevelAt(fUTF16LogicalPosition);
+        SkUnichar u = utf8_next(&fEndOfCurrentRun, fEnd);
+        fUTF16LogicalPosition += SkUTF::ToUTF16(u);
+        SkBidiIterator::Level level;
+        while (fUTF16LogicalPosition < endPosition) {
+            level = fBidi->getLevelAt(fUTF16LogicalPosition);
+            if (level != fLevel) {
+                break;
+            }
+            u = utf8_next(&fEndOfCurrentRun, fEnd);
+
+            fUTF16LogicalPosition += SkUTF::ToUTF16(u);
+        }
+    }
+    size_t endOfCurrentRun() const override {
+        return fEndOfCurrentRun - fBegin;
+    }
+    bool atEnd() const override {
+        return fUTF16LogicalPosition == fBidi->getLength();
+    }
+    SkBidiIterator::Level currentLevel() const override {
+        return fLevel;
+    }
+private:
+    SkUnicodeBidi fBidi;
+    char const * fEndOfCurrentRun;
+    char const * const fBegin;
+    char const * const fEnd;
+    int32_t fUTF16LogicalPosition;
+    SkBidiIterator::Level fLevel;
+};
+
+#if !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu.h"
+#endif
+
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+#endif
+
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+#endif
+
+sk_sp<SkUnicode> get_unicode() {
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::ICU::Make()) {
+        return unicode;
+    }
+#endif  // defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::Libgrapheme::Make()) {
+        return unicode;
+    }
+#endif
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::ICU4X::Make()) {
+        return unicode;
+    }
+#endif
+    return nullptr;
+}
+
+std::unique_ptr<SkShaper::BiDiRunIterator> SkShaper::MakeIcuBiDiRunIterator(const char* utf8,
+                                                                            size_t utf8Bytes,
+                                                                            uint8_t bidiLevel) {
+    static auto unicode = get_unicode();
+    if (!unicode) {
+        return nullptr;
+    }
+    return SkShapers::unicode::BidiRunIterator(unicode, utf8, utf8Bytes, bidiLevel);
+}
+#endif  //  !defined(SK_DISABLE_LEGACY_SKSHAPER_FUNCTIONS)
+
+namespace SkShapers::unicode {
+std::unique_ptr<SkShaper::BiDiRunIterator> BidiRunIterator(sk_sp<SkUnicode> unicode,
+                                                           const char* utf8,
+                                                           size_t utf8Bytes,
+                                                           uint8_t bidiLevel) {
+    if (!unicode) {
+        return nullptr;
+    }
+    // ubidi only accepts utf16 (though internally it basically works on utf32 chars).
+    // We want an ubidi_setPara(UBiDi*, UText*, UBiDiLevel, UBiDiLevel*, UErrorCode*);
+    if (!SkTFitsIn<int32_t>(utf8Bytes)) {
+        SkDEBUGF("Bidi error: text too long");
+        return nullptr;
+    }
+
+    int32_t utf16Units = SkUTF::UTF8ToUTF16(nullptr, 0, utf8, utf8Bytes);
+    if (utf16Units < 0) {
+        SkDEBUGF("Invalid utf8 input\n");
+        return nullptr;
+    }
+
+    std::unique_ptr<uint16_t[]> utf16(new uint16_t[utf16Units]);
+    (void)SkUTF::UTF8ToUTF16(utf16.get(), utf16Units, utf8, utf8Bytes);
+
+    auto bidiDir = (bidiLevel % 2 == 0) ? SkBidiIterator::kLTR : SkBidiIterator::kRTL;
+    SkUnicodeBidi bidi = unicode->makeBidiIterator(utf16.get(), utf16Units, bidiDir);
+    if (!bidi) {
+        SkDEBUGF("Bidi error\n");
+        return nullptr;
+    }
+
+    return std::make_unique<SkUnicodeBidiRunIterator>(utf8, utf8 + utf8Bytes, std::move(bidi));
+}
+}  // namespace SkShapers::unicode
diff --git a/Source/ThirdParty/skia/modules/skshaper/tests/BUILD.bazel b/Source/ThirdParty/skia/modules/skshaper/tests/BUILD.bazel
new file mode 100644
index 00000000..cda1206c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/tests/BUILD.bazel
@@ -0,0 +1,12 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "tests_srcs",
+    srcs = ["ShaperTest.cpp"],
+)
diff --git a/Source/ThirdParty/skia/modules/skshaper/tests/ShaperTest.cpp b/Source/ThirdParty/skia/modules/skshaper/tests/ShaperTest.cpp
new file mode 100644
index 00000000..2e640c06
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/tests/ShaperTest.cpp
@@ -0,0 +1,274 @@
+// Copyright 2019 Google LLC.
+// Use of this source code is governed by a BSD-style license that can be found in the LICENSE file.
+
+#include "tests/Test.h"
+
+#include "include/core/SkData.h"
+#include "include/core/SkFont.h"
+#include "include/core/SkPoint.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkTypeface.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/skshaper/include/SkShaper_harfbuzz.h"
+#include "modules/skshaper/include/SkShaper_skunicode.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkZip.h"
+#include "tools/Resources.h"
+#include "tools/fonts/FontToolUtils.h"
+
+#include <cinttypes>
+#include <cstdint>
+#include <memory>
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu.h"
+#endif
+
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+#endif
+
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+#endif
+
+namespace {
+
+sk_sp<SkUnicode> get_unicode() {
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::ICU::Make()) {
+        return unicode;
+    }
+#endif  // defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::Libgrapheme::Make()) {
+        return unicode;
+    }
+#endif
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+    if (auto unicode = SkUnicodes::ICU4X::Make()) {
+        return unicode;
+    }
+#endif
+    return nullptr;
+}
+
+struct RunHandler final : public SkShaper::RunHandler {
+    const char* fResource;
+    skiatest::Reporter* fReporter;
+    const char* fUtf8;
+    size_t fUtf8Size;
+    std::unique_ptr<SkGlyphID[]> fGlyphs;
+    std::unique_ptr<SkPoint[]> fPositions;
+    std::unique_ptr<uint32_t[]> fClusters;
+    SkShaper::RunHandler::Range fRange;
+    unsigned fGlyphCount = 0;
+
+    bool fBeginLine = false;
+    bool fCommitRunInfo = false;
+    bool fCommitLine = false;
+
+    RunHandler(const char* resource, skiatest::Reporter* reporter, const char* utf8,size_t utf8Size)
+        : fResource(resource), fReporter(reporter), fUtf8(utf8), fUtf8Size(utf8Size) {}
+
+    void beginLine() override { fBeginLine = true;}
+    void runInfo(const SkShaper::RunHandler::RunInfo& info) override {}
+    void commitRunInfo() override { fCommitRunInfo = true; }
+    SkShaper::RunHandler::Buffer runBuffer(const SkShaper::RunHandler::RunInfo& info) override {
+        fGlyphCount = SkToUInt(info.glyphCount);
+        fRange = info.utf8Range;
+        fGlyphs = std::make_unique<SkGlyphID[]>(info.glyphCount);
+        fPositions = std::make_unique<SkPoint[]>(info.glyphCount);
+        fClusters = std::make_unique<uint32_t[]>(info.glyphCount);
+        return SkShaper::RunHandler::Buffer{fGlyphs.get(),
+                                            fPositions.get(),
+                                            nullptr,
+                                            fClusters.get(),
+                                            {0, 0}};
+    }
+    void commitRunBuffer(const RunInfo& info) override {
+        REPORTER_ASSERT(fReporter, fGlyphCount == info.glyphCount, "%s", fResource);
+        REPORTER_ASSERT(fReporter, fRange.begin() == info.utf8Range.begin(), "%s", fResource);
+        REPORTER_ASSERT(fReporter, fRange.size() == info.utf8Range.size(), "%s", fResource);
+        if (!(fRange.begin() + fRange.size() <= fUtf8Size)) {
+            REPORTER_ASSERT(fReporter, fRange.begin() + fRange.size() <= fUtf8Size, "%s",fResource);
+            return;
+        }
+
+        if ((false)) {
+            SkString familyName;
+            SkString postscriptName;
+            SkTypeface* typeface = info.fFont.getTypeface();
+            int ttcIndex = 0;
+            size_t fontSize = 0;
+            if (typeface) {
+                typeface->getFamilyName(&familyName);
+                typeface->getPostScriptName(&postscriptName);
+                std::unique_ptr<SkStreamAsset> stream = typeface->openStream(&ttcIndex);
+                if (stream) {
+                    fontSize = stream->getLength();
+                }
+            }
+            SkString glyphs;
+            for (auto&& [glyph, cluster] : SkZip(info.glyphCount, fGlyphs.get(), fClusters.get())) {
+                glyphs.appendU32(glyph);
+                glyphs.append(":");
+                glyphs.appendU32(cluster);
+                glyphs.append(" ");
+            }
+            SkString chars;
+            for (const char c : SkSpan(fUtf8 + fRange.begin(), fRange.size())) {
+                chars.appendHex((unsigned char)c, 2);
+                chars.append(" ");
+            }
+            SkDebugf(
+                "%s range: %zu-%zu(%zu) glyphCount:%u font: \"%s\" \"%s\" #%d %zuB\n"
+                "rangeText: \"%.*s\"\n"
+                "rangeBytes: %s\n"
+                "glyphs:%s\n\n",
+                fResource, fRange.begin(), fRange.end(), fRange.size(), fGlyphCount,
+                familyName.c_str(), postscriptName.c_str(), ttcIndex, fontSize,
+                (int)fRange.size(), fUtf8 + fRange.begin(),
+                chars.c_str(),
+                glyphs.c_str());
+        }
+
+        for (unsigned i = 0; i < fGlyphCount; ++i) {
+            REPORTER_ASSERT(fReporter, fClusters[i] >= fRange.begin(),
+                            "%" PRIu32 " >= %zu %s i:%u glyphCount:%u",
+                            fClusters[i], fRange.begin(), fResource, i, fGlyphCount);
+            REPORTER_ASSERT(fReporter, fClusters[i] < fRange.end(),
+                            "%" PRIu32 " < %zu %s i:%u glyphCount:%u",
+                            fClusters[i], fRange.end(), fResource, i, fGlyphCount);
+        }
+    }
+    void commitLine() override { fCommitLine = true; }
+};
+
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+void shaper_test(skiatest::Reporter* reporter, const char* name, SkData* data) {
+    skiatest::ReporterContext context(reporter, name);
+    auto unicode = get_unicode();
+    if (!unicode) {
+        ERRORF(reporter, "Could not create unicode.");
+        return;
+    }
+
+    auto shaper = SkShapers::HB::ShaperDrivenWrapper(unicode,
+                                                     SkFontMgr::RefEmpty());  // no fallback
+    if (!shaper) {
+        ERRORF(reporter, "Could not create shaper.");
+        return;
+    }
+    if (!unicode) {
+        ERRORF(reporter, "Could not create unicode.");
+        return;
+    }
+    constexpr float kWidth = 400;
+    SkFont font = ToolUtils::DefaultFont();
+    const char* utf8 = (const char*)data->data();
+    size_t utf8Bytes = data->size();
+
+    RunHandler rh(name, reporter, utf8, utf8Bytes);
+
+    const SkBidiIterator::Level defaultLevel = SkBidiIterator::kLTR;
+    std::unique_ptr<SkShaper::BiDiRunIterator> bidi =
+            SkShapers::unicode::BidiRunIterator(unicode, utf8, utf8Bytes, defaultLevel);
+    SkASSERT(bidi);
+
+    std::unique_ptr<SkShaper::LanguageRunIterator> language =
+            SkShaper::MakeStdLanguageRunIterator(utf8, utf8Bytes);
+    SkASSERT(language);
+
+    std::unique_ptr<SkShaper::ScriptRunIterator> script =
+            SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes);
+    SkASSERT(script);
+
+    std::unique_ptr<SkShaper::FontRunIterator> fontRuns =
+            SkShaper::MakeFontMgrRunIterator(utf8, utf8Bytes, font, SkFontMgr::RefEmpty());
+    SkASSERT(fontRuns);
+    shaper->shape(utf8, utf8Bytes, *fontRuns, *bidi, *script, *language, nullptr, 0, kWidth, &rh);
+
+    // Even on empty input, expect that the line is started, that the zero run infos are committed,
+    // and the empty line is committed. This allows the user to properly handle empty runs.
+    REPORTER_ASSERT(reporter, rh.fBeginLine);
+    REPORTER_ASSERT(reporter, rh.fCommitRunInfo);
+    REPORTER_ASSERT(reporter, rh.fCommitLine);
+
+    constexpr SkFourByteTag latn = SkSetFourByteTag('l','a','t','n');
+    auto fontIterator = SkShaper::TrivialFontRunIterator(font, data->size());
+    auto bidiIterator = SkShaper::TrivialBiDiRunIterator(0, data->size());
+    auto scriptIterator = SkShaper::TrivialScriptRunIterator(latn, data->size());
+    auto languageIterator = SkShaper::TrivialLanguageRunIterator("en-US", data->size());
+    shaper->shape((const char*)data->data(),
+                  data->size(),
+                  fontIterator,
+                  bidiIterator,
+                  scriptIterator,
+                  languageIterator,
+                  nullptr,
+                  0,
+                  kWidth,
+                  &rh);
+}
+
+void cluster_test(skiatest::Reporter* reporter, const char* resource) {
+    auto data = GetResourceAsData(resource);
+    if (!data) {
+        ERRORF(reporter, "Could not get resource %s.", resource);
+        return;
+    }
+
+    shaper_test(reporter, resource, data.get());
+}
+
+#endif  // defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+
+}  // namespace
+
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+
+DEF_TEST(Shaper_cluster_empty, r) { shaper_test(r, "empty", SkData::MakeEmpty().get()); }
+
+#define SHAPER_TEST(X) DEF_TEST(Shaper_cluster_ ## X, r) { cluster_test(r, "text/" #X ".txt"); }
+SHAPER_TEST(arabic)
+SHAPER_TEST(armenian)
+SHAPER_TEST(balinese)
+SHAPER_TEST(buginese)
+SHAPER_TEST(cherokee)
+SHAPER_TEST(cyrillic)
+SHAPER_TEST(emoji)
+SHAPER_TEST(english)
+SHAPER_TEST(ethiopic)
+SHAPER_TEST(greek)
+SHAPER_TEST(hangul)
+SHAPER_TEST(han_simplified)
+SHAPER_TEST(han_traditional)
+SHAPER_TEST(hebrew)
+SHAPER_TEST(javanese)
+SHAPER_TEST(kana)
+SHAPER_TEST(lao)
+SHAPER_TEST(mandaic)
+SHAPER_TEST(newtailue)
+SHAPER_TEST(nko)
+SHAPER_TEST(sinhala)
+SHAPER_TEST(sundanese)
+SHAPER_TEST(syriac)
+SHAPER_TEST(thaana)
+SHAPER_TEST(thai)
+SHAPER_TEST(tibetan)
+SHAPER_TEST(tifnagh)
+SHAPER_TEST(vai)
+SHAPER_TEST(bengali)
+SHAPER_TEST(devanagari)
+SHAPER_TEST(khmer)
+SHAPER_TEST(myanmar)
+SHAPER_TEST(taitham)
+SHAPER_TEST(tamil)
+#undef SHAPER_TEST
+
+#endif  // #if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
diff --git a/Source/ThirdParty/skia/modules/skshaper/utils/BUILD.bazel b/Source/ThirdParty/skia/modules/skshaper/utils/BUILD.bazel
new file mode 100644
index 00000000..c2ca43f4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/utils/BUILD.bazel
@@ -0,0 +1,18 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "core_hdrs",
+    srcs = [
+        "FactoryHelpers.h",
+    ],
+    visibility = [
+        "//modules/skshaper:__pkg__",
+        "//modules/skshaper/include:__pkg__",
+    ],
+)
diff --git a/Source/ThirdParty/skia/modules/skshaper/utils/FactoryHelpers.h b/Source/ThirdParty/skia/modules/skshaper/utils/FactoryHelpers.h
new file mode 100644
index 00000000..b87e841a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skshaper/utils/FactoryHelpers.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkShaperFactoryHelpers_DEFINED
+#define SkShaperFactoryHelpers_DEFINED
+
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+#include "modules/skshaper/include/SkShaper_harfbuzz.h"
+#include "modules/skshaper/include/SkShaper_skunicode.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#endif
+
+#if defined(SK_SHAPER_CORETEXT_AVAILABLE)
+#include "modules/skshaper/include/SkShaper_coretext.h"
+#endif
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu.h"
+#endif
+
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+#endif
+
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+#endif
+
+namespace SkShapers {
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+class HarfbuzzFactory final : public Factory {
+public:
+    HarfbuzzFactory() {
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+        fUnicode = SkUnicodes::ICU::Make();
+#endif
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+        if (!fUnicode) {
+            fUnicode = SkUnicodes::ICU4X::Make();
+        }
+#endif
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+        if (!fUnicode) {
+            fUnicode = SkUnicodes::Libgrapheme::Make();
+        }
+#endif
+    }
+    std::unique_ptr<SkShaper> makeShaper(sk_sp<SkFontMgr> fallback) override {
+        return SkShapers::HB::ShaperDrivenWrapper(fUnicode, fallback);
+    }
+
+    std::unique_ptr<SkShaper::BiDiRunIterator> makeBidiRunIterator(const char* utf8,
+                                                                size_t utf8Bytes,
+                                                                uint8_t bidiLevel) override {
+        return SkShapers::unicode::BidiRunIterator(fUnicode, utf8, utf8Bytes, bidiLevel);
+    }
+
+    std::unique_ptr<SkShaper::ScriptRunIterator> makeScriptRunIterator(const char* utf8,
+                                                                 size_t utf8Bytes,
+                                                                 SkFourByteTag script) override {
+        return SkShapers::HB::ScriptRunIterator(utf8, utf8Bytes, script);
+    }
+
+    SkUnicode* getUnicode() override { return fUnicode.get(); }
+
+private:
+    sk_sp<SkUnicode> fUnicode;
+};
+#endif  // defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+
+#if defined(SK_SHAPER_CORETEXT_AVAILABLE)
+class CoreTextFactory final : public Factory {
+    std::unique_ptr<SkShaper> makeShaper(sk_sp<SkFontMgr>) override {
+        return SkShapers::CT::CoreText();
+    }
+    std::unique_ptr<SkShaper::BiDiRunIterator> makeBidiRunIterator(const char* utf8,
+                                                                size_t utf8Bytes,
+                                                                uint8_t bidiLevel) override {
+        return std::make_unique<SkShaper::TrivialBiDiRunIterator>(0, 0);
+    }
+    std::unique_ptr<SkShaper::ScriptRunIterator> makeScriptRunIterator(const char* utf8,
+                                                                 size_t utf8Bytes,
+                                                                 SkFourByteTag script) override {
+        return std::make_unique<SkShaper::TrivialScriptRunIterator>(0, 0);
+    }
+    SkUnicode* getUnicode() override { return nullptr; }
+};
+#endif  // defined(SK_SHAPER_CORETEXT_AVAILABLE)
+
+// This convenience function will return a set of callbacks that has the "best" text shaping
+// depending on what parts of Skia the client has compiled in. For example, if the clients
+// have compiled in SkShaper and a version of SkUnicode, callbacks which produce the
+// appropriate types will be returned.
+//
+// This must be inline (and defined in this header) because the *client* has to compile this code
+// with all defines set by *their* dependencies (which may include defines from SkShaper and
+// SkUnicode modules).
+inline sk_sp<Factory> BestAvailable() {
+#if defined(SK_SHAPER_HARFBUZZ_AVAILABLE) && defined(SK_SHAPER_UNICODE_AVAILABLE)
+    return sk_make_sp<SkShapers::HarfbuzzFactory>();
+#elif defined(SK_SHAPER_CORETEXT_AVAILABLE)
+    return sk_make_sp<SkShapers::CoreTextFactory>();
+#else
+    return SkShapers::Primitive::Factory();
+#endif
+}
+
+};  // namespace SkShapers
+
+#endif  // SkShaperFactoryHelpers_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/BUILD.bazel
new file mode 100644
index 00000000..c9dbf371
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/BUILD.bazel
@@ -0,0 +1,68 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "skunicode_core",
+    srcs = [
+        "//modules/skunicode/src:srcs",
+    ],
+    hdrs = ["//modules/skunicode/include:core_hdrs"],
+    defines = [
+        "SK_UNICODE_AVAILABLE",
+    ],
+    visibility = [
+        "//:__pkg__",
+        "//modules:__subpackages__",
+    ],
+    deps = [
+        "//:core",
+        "//src/base",
+        "//src/core:core_priv",
+    ],
+)
+
+skia_cc_library(
+    name = "skunicode_icu",
+    srcs = [
+        "//modules/skunicode/src:bidi_full_srcs",
+        "//modules/skunicode/src:icu_bidi_srcs",
+        "//modules/skunicode/src:icu_core_srcs",
+    ] + select({
+        "@platforms//os:android": [
+            "//modules/skunicode/src:runtime_srcs",
+        ],
+        "//conditions:default": [
+            "//modules/skunicode/src:builtin_srcs",
+        ],
+    }),
+    hdrs = [
+        "//modules/skunicode/include:core_hdrs",
+        "//modules/skunicode/include:icu_hdrs",
+    ],
+    defines = [
+        "SK_UNICODE_AVAILABLE",
+        "SK_UNICODE_ICU_IMPLEMENTATION",
+    ] + select({
+        "@platforms//os:android": ["SK_UNICODE_RUNTIME_ICU_AVAILABLE"],
+        "//conditions:default": [],
+    }),
+    features = ["layering_check"],
+    visibility = [
+        "//:__pkg__",
+        "//modules:__subpackages__",
+    ],
+    deps = [
+        ":skunicode_core",
+        "//:core",
+        "//src/base",
+        "//src/core:core_priv",
+    ] + select({
+        "@platforms//os:android": ["@icu//:icu_headers"],
+        "//conditions:default": ["@icu"],
+    }),
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/BUILD.gn b/Source/ThirdParty/skia/modules/skunicode/BUILD.gn
new file mode 100644
index 00000000..7a4dcb76
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/BUILD.gn
@@ -0,0 +1,220 @@
+# Copyright 2021 Google Inc.
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+import("../../third_party/icu/icu.gni")
+import("skunicode.gni")
+
+declare_args() {
+  skia_use_runtime_icu = false
+  skunicode_tests_enabled = true
+}
+
+if (skia_use_icu || skia_use_client_icu || skia_use_libgrapheme ||
+    skia_use_icu4x) {
+  config("public_config") {
+    defines = [ "SK_UNICODE_AVAILABLE" ]
+    if (skia_use_icu) {
+      defines += [ "SK_UNICODE_ICU_IMPLEMENTATION" ]
+    }
+    if (skia_use_client_icu) {
+      defines += [ "SK_UNICODE_CLIENT_IMPLEMENTATION" ]
+    }
+    if (skia_use_libgrapheme) {
+      defines += [ "SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION" ]
+    }
+    if (skia_use_icu4x) {
+      defines += [ "SK_UNICODE_ICU4X_IMPLEMENTATION" ]
+    }
+  }
+
+  config("cpp20") {
+    if (is_win) {
+      cflags_cc = [ "/std:c++20" ]
+    } else {
+      cflags_cc = [ "-std=c++20" ]
+    }
+  }
+
+  config("module") {
+    defines = [ "SKUNICODE_IMPLEMENTATION=1" ]
+    if (is_component_build) {
+      defines += [ "SKUNICODE_DLL" ]
+    }
+  }
+
+  component("skunicode_core") {
+    check_includes = false
+    deps = [ "../..:skia" ]
+    configs += [
+      ":module",
+      "../../:skia_private",
+      "../../third_party/icu/config:no_cxx",
+    ]
+    sources = skia_unicode_sources
+  }
+
+  if (skia_use_icu) {
+    component("skunicode_icu") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+
+      # These are explicitly *not* public defines because we don't want them
+      # to leak to dependents.
+      defines = [ "U_USING_ICU_NAMESPACE=0" ]
+      if (!skia_use_system_icu) {
+        defines += [ "U_DISABLE_RENAMING=1" ]
+      }
+
+      sources = skia_unicode_icu_bidi_sources
+      sources += skia_unicode_bidi_full_sources
+      sources += skia_unicode_icu_sources
+
+      # only available for Android at the moment
+      if (skia_use_runtime_icu && (is_android || is_linux)) {
+        sources += skia_unicode_runtime_icu_sources
+        defines += [ "SK_UNICODE_RUNTIME_ICU_AVAILABLE" ]
+        deps += [ "//third_party/icu:headers" ]
+      } else {
+        sources += skia_unicode_builtin_icu_sources
+        deps += [ "//third_party/icu" ]
+      }
+    }
+  }
+
+  if (skia_use_client_icu) {
+    component("skunicode_client_icu") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+      defines = [
+        # In order to use the bidi_subset at the same time as "full ICU", we must have
+        # compiled icu with the given defines also being set. This is to make sure the functions
+        # we call are given a suffix of "_skia" to prevent ODR violations if this "subset of ICU"
+        # is compiled alongside a full ICU build also.
+        # See https://chromium.googlesource.com/chromium/deps/icu.git/+/d94ab131bc8fef3bc17f356a628d8e4cd44d65d9/source/common/unicode/uversion.h
+        # for how these are used.
+        "U_DISABLE_RENAMING=0",
+        "U_USING_ICU_NAMESPACE=0",
+        "U_LIB_SUFFIX_C_NAME=_skia",
+        "U_HAVE_LIB_SUFFIX=1",
+        "U_DISABLE_VERSION_SUFFIX=1",
+      ]
+
+      sources = skia_unicode_icu_bidi_sources
+      sources += skia_unicode_bidi_subset_sources
+      sources += skia_unicode_client_icu_sources
+      deps += [ skia_icu_bidi_third_party_dir ]
+    }
+  }
+
+  if (skia_use_libgrapheme) {
+    component("skunicode_libgrapheme") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+      defines = [
+        "U_DISABLE_RENAMING=0",
+        "U_USING_ICU_NAMESPACE=0",
+        "U_LIB_SUFFIX_C_NAME=_skia",
+        "U_HAVE_LIB_SUFFIX=1",
+        "U_DISABLE_VERSION_SUFFIX=1",
+      ]
+
+      sources = skia_unicode_icu_bidi_sources
+      sources += skia_unicode_bidi_subset_sources
+
+      sources += skia_unicode_libgrapheme_sources
+      deps += [
+        skia_icu_bidi_third_party_dir,
+        skia_libgrapheme_third_party_dir,
+      ]
+    }
+  }
+
+  if (skia_use_icu4x) {
+    component("skunicode_icu4x") {
+      check_includes = false
+      deps = [
+        ":skunicode_core",
+        "../..:skia",
+      ]
+      configs += [
+        ":module",
+        "../../:skia_private",
+        "../../third_party/icu/config:no_cxx",
+      ]
+
+      sources = skia_unicode_icu4x_sources
+
+      deps += [ "//third_party/icu4x" ]
+    }
+  }
+
+  group("skunicode") {
+    public_configs = [ ":public_config" ]
+    public_deps = [ ":skunicode_core" ]
+
+    # We have these different flavors of skunicode as independent components because
+    # we have to set different defines for different builds of ICU.
+    if (skia_use_icu) {
+      public_deps += [ ":skunicode_icu" ]
+    }
+    if (skia_use_client_icu) {
+      public_deps += [ ":skunicode_client_icu" ]
+    }
+    if (skia_use_libgrapheme) {
+      public_deps += [ ":skunicode_libgrapheme" ]
+    }
+    if (skia_use_icu4x) {
+      public_deps += [ ":skunicode_icu4x" ]
+    }
+  }
+
+  if (defined(is_skia_standalone) && skia_enable_tools) {
+    skia_source_set("tests") {
+      if (skunicode_tests_enabled &&
+          (skia_use_icu || skia_use_libgrapheme || skia_use_icu4x)) {
+        testonly = true
+        deps = [
+          ":skunicode",
+          "../..:skia",
+          "../..:test",
+        ]
+        sources = skia_unicode_tests
+        deps += [ skia_icu_bidi_third_party_dir ]
+      } else {
+        sources = []
+      }
+    }
+  }
+} else {
+  group("skunicode") {
+  }
+  group("tests") {
+  }
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel
new file mode 100644
index 00000000..84117885
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/BUILD.bazel
@@ -0,0 +1,35 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "hdrs",
+    srcs = [
+        "SkUnicode.h",
+        "SkUnicode_client.h",
+        "SkUnicode_icu.h",
+        "SkUnicode_icu4x.h",
+        "SkUnicode_libgrapheme.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "core_hdrs",
+    srcs = [
+        "SkUnicode.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_hdrs",
+    srcs = [
+        "SkUnicode_icu.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h
new file mode 100644
index 00000000..6b91a10c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode.h
@@ -0,0 +1,307 @@
+/*
+ * Copyright 2020 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_DEFINED
+#define SkUnicode_DEFINED
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTo.h"
+#include "src/base/SkUTF.h"
+#include <cstddef>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+namespace sknonstd { template <typename T> struct is_bitmask_enum; }
+
+#if !defined(SKUNICODE_IMPLEMENTATION)
+    #define SKUNICODE_IMPLEMENTATION 0
+#endif
+
+#if !defined(SKUNICODE_API)
+    #if defined(SKUNICODE_DLL)
+        #if defined(_MSC_VER)
+            #if SKUNICODE_IMPLEMENTATION
+                #define SKUNICODE_API __declspec(dllexport)
+            #else
+                #define SKUNICODE_API __declspec(dllimport)
+            #endif
+        #else
+            #define SKUNICODE_API __attribute__((visibility("default")))
+        #endif
+    #else
+        #define SKUNICODE_API
+    #endif
+#endif
+
+class SKUNICODE_API SkBidiIterator {
+public:
+    typedef int32_t Position;
+    typedef uint8_t Level;
+    struct Region {
+        Region(Position start, Position end, Level level)
+            : start(start), end(end), level(level) { }
+        Position start;
+        Position end;
+        Level level;
+    };
+    enum Direction {
+        kLTR,
+        kRTL,
+    };
+    virtual ~SkBidiIterator() = default;
+    virtual Position getLength() = 0;
+    virtual Level getLevelAt(Position) = 0;
+};
+
+class SKUNICODE_API SkBreakIterator {
+public:
+    typedef int32_t Position;
+    typedef int32_t Status;
+    virtual ~SkBreakIterator() = default;
+    virtual Position first() = 0;
+    virtual Position current() = 0;
+    virtual Position next() = 0;
+    virtual Status status() = 0;
+    virtual bool isDone() = 0;
+    virtual bool setText(const char utftext8[], int utf8Units) = 0;
+    virtual bool setText(const char16_t utftext16[], int utf16Units) = 0;
+};
+
+class SKUNICODE_API SkUnicode : public SkRefCnt {
+    public:
+        enum CodeUnitFlags {
+            kNoCodeUnitFlag = 0x00,
+            kPartOfWhiteSpaceBreak = 0x01,
+            kGraphemeStart = 0x02,
+            kSoftLineBreakBefore = 0x04,
+            kHardLineBreakBefore = 0x08,
+            kPartOfIntraWordBreak = 0x10,
+            kControl = 0x20,
+            kTabulation = 0x40,
+            kGlyphClusterStart = 0x80,
+            kIdeographic = 0x100,
+            kEmoji = 0x200,
+            kWordBreak = 0x400,
+            kSentenceBreak = 0x800,
+        };
+        enum class TextDirection {
+            kLTR,
+            kRTL,
+        };
+        typedef size_t Position;
+        typedef uint8_t BidiLevel;
+        struct BidiRegion {
+            BidiRegion(Position start, Position end, BidiLevel level)
+              : start(start), end(end), level(level) { }
+            Position start;
+            Position end;
+            BidiLevel level;
+        };
+        enum class LineBreakType {
+            kSoftLineBreak = 0,
+            kHardLineBreak = 100,
+        };
+
+        enum class BreakType { kWords, kGraphemes, kLines, kSentences };
+        struct LineBreakBefore {
+            LineBreakBefore(Position pos, LineBreakType breakType)
+              : pos(pos), breakType(breakType) { }
+            Position pos;
+            LineBreakType breakType;
+        };
+
+        ~SkUnicode() override = default;
+
+        // deprecated
+        virtual SkString toUpper(const SkString&) = 0;
+        virtual SkString toUpper(const SkString&, const char* locale) = 0;
+
+        virtual bool isControl(SkUnichar utf8) = 0;
+        virtual bool isWhitespace(SkUnichar utf8) = 0;
+        virtual bool isSpace(SkUnichar utf8) = 0;
+        virtual bool isTabulation(SkUnichar utf8) = 0;
+        virtual bool isHardBreak(SkUnichar utf8) = 0;
+        /**
+         * Returns if a code point may start an emoji sequence.
+         * Returns true for '#', '*', and '0'-'9' since they may start an emoji sequence.
+         * To determine if a list of code points begins with an emoji sequence, use
+         * getEmojiSequence.
+         **/
+        virtual bool isEmoji(SkUnichar utf8) = 0;
+        virtual bool isEmojiComponent(SkUnichar utf8) = 0;
+        virtual bool isEmojiModifierBase(SkUnichar utf8) = 0;
+        virtual bool isEmojiModifier(SkUnichar utf8) = 0;
+        virtual bool isRegionalIndicator(SkUnichar utf8) = 0;
+        virtual bool isIdeographic(SkUnichar utf8) = 0;
+
+        // Methods used in SkShaper and SkText
+        virtual std::unique_ptr<SkBidiIterator> makeBidiIterator
+            (const uint16_t text[], int count, SkBidiIterator::Direction) = 0;
+        virtual std::unique_ptr<SkBidiIterator> makeBidiIterator
+            (const char text[], int count, SkBidiIterator::Direction) = 0;
+        virtual std::unique_ptr<SkBreakIterator> makeBreakIterator
+            (const char locale[], BreakType breakType) = 0;
+        virtual std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType type) = 0;
+
+        // Methods used in SkParagraph
+        static bool hasTabulationFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasHardLineBreakFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasSoftLineBreakFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasGraphemeStartFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasControlFlag(SkUnicode::CodeUnitFlags flags);
+        static bool hasPartOfWhiteSpaceBreakFlag(SkUnicode::CodeUnitFlags flags);
+
+        static bool extractBidi(const char utf8[],
+                                int utf8Units,
+                                TextDirection dir,
+                                std::vector<BidiRegion>* bidiRegions);
+        virtual bool getBidiRegions(const char utf8[],
+                                    int utf8Units,
+                                    TextDirection dir,
+                                    std::vector<BidiRegion>* results) = 0;
+        // Returns results in utf16
+        virtual bool getWords(const char utf8[], int utf8Units, const char* locale,
+                              std::vector<Position>* results) = 0;
+        virtual bool getUtf8Words(const char utf8[],
+                                  int utf8Units,
+                                  const char* locale,
+                                  std::vector<Position>* results) = 0;
+        virtual bool getSentences(const char utf8[],
+                                  int utf8Units,
+                                  const char* locale,
+                                  std::vector<Position>* results) = 0;
+        virtual bool computeCodeUnitFlags(
+                char utf8[], int utf8Units, bool replaceTabs,
+                skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) = 0;
+        virtual bool computeCodeUnitFlags(
+                char16_t utf16[], int utf16Units, bool replaceTabs,
+                skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) = 0;
+
+        static SkString convertUtf16ToUtf8(const char16_t * utf16, int utf16Units);
+        static SkString convertUtf16ToUtf8(const std::u16string& utf16);
+        static std::u16string convertUtf8ToUtf16(const char* utf8, int utf8Units);
+        static std::u16string convertUtf8ToUtf16(const SkString& utf8);
+
+        template <typename Appender8, typename Appender16>
+        static bool extractUtfConversionMapping(SkSpan<const char> utf8, Appender8&& appender8, Appender16&& appender16) {
+            size_t size8 = 0;
+            size_t size16 = 0;
+            auto ptr = utf8.begin();
+            auto end = utf8.end();
+            while (ptr < end) {
+
+                size_t index = SkToSizeT(ptr - utf8.begin());
+                SkUnichar u = SkUTF::NextUTF8(&ptr, end);
+
+                // All UTF8 code units refer to the same codepoint
+                size_t next = SkToSizeT(ptr - utf8.begin());
+                for (auto i = index; i < next; ++i) {
+                    //fUTF16IndexForUTF8Index.emplace_back(fUTF8IndexForUTF16Index.size());
+                    appender16(size8);
+                    ++size16;
+                }
+                //SkASSERT(fUTF16IndexForUTF8Index.size() == next);
+                SkASSERT(size16 == next);
+                if (size16 != next) {
+                    return false;
+                }
+
+                // One or two UTF16 code units refer to the same codepoint
+                uint16_t buffer[2];
+                size_t count = SkUTF::ToUTF16(u, buffer);
+                //fUTF8IndexForUTF16Index.emplace_back(index);
+                appender8(index);
+                ++size8;
+                if (count > 1) {
+                    //fUTF8IndexForUTF16Index.emplace_back(index);
+                    appender8(index);
+                    ++size8;
+                }
+            }
+            //fUTF16IndexForUTF8Index.emplace_back(fUTF8IndexForUTF16Index.size());
+            appender16(size8);
+            ++size16;
+            //fUTF8IndexForUTF16Index.emplace_back(fText.size());
+            appender8(utf8.size());
+            ++size8;
+
+            return true;
+        }
+
+        template <typename Callback>
+        void forEachCodepoint(const char* utf8, int32_t utf8Units, Callback&& callback) {
+            const char* current = utf8;
+            const char* end = utf8 + utf8Units;
+            while (current < end) {
+                auto before = current - utf8;
+                SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+                if (unichar < 0) unichar = 0xFFFD;
+                auto after = current - utf8;
+                uint16_t buffer[2];
+                size_t count = SkUTF::ToUTF16(unichar, buffer);
+                callback(unichar, before, after, count);
+            }
+        }
+
+        template <typename Callback>
+        void forEachCodepoint(const char16_t* utf16, int32_t utf16Units, Callback&& callback) {
+            const char16_t* current = utf16;
+            const char16_t* end = utf16 + utf16Units;
+            while (current < end) {
+                auto before = current - utf16;
+                SkUnichar unichar = SkUTF::NextUTF16((const uint16_t**)&current, (const uint16_t*)end);
+                auto after = current - utf16;
+                callback(unichar, before, after);
+            }
+        }
+
+        template <typename Callback>
+        void forEachBidiRegion(const uint16_t utf16[], int utf16Units, SkBidiIterator::Direction dir, Callback&& callback) {
+            auto iter = makeBidiIterator(utf16, utf16Units, dir);
+            const uint16_t* start16 = utf16;
+            const uint16_t* end16 = utf16 + utf16Units;
+            SkBidiIterator::Level currentLevel = 0;
+
+            SkBidiIterator::Position pos16 = 0;
+            while (pos16 <= iter->getLength()) {
+                auto level = iter->getLevelAt(pos16);
+                if (pos16 == 0) {
+                    currentLevel = level;
+                } else if (level != currentLevel) {
+                    callback(pos16, start16 - utf16, currentLevel);
+                    currentLevel = level;
+                }
+                if (start16 == end16) {
+                    break;
+                }
+                SkUnichar u = SkUTF::NextUTF16(&start16, end16);
+                pos16 += SkUTF::ToUTF16(u);
+            }
+        }
+
+        template <typename Callback>
+        void forEachBreak(const char16_t utf16[], int utf16Units, SkUnicode::BreakType type, Callback&& callback) {
+            auto iter = makeBreakIterator(type);
+            iter->setText(utf16, utf16Units);
+            auto pos = iter->first();
+            do {
+                callback(pos, iter->status());
+                pos = iter->next();
+            } while (!iter->isDone());
+        }
+
+        virtual void reorderVisual(const BidiLevel runLevels[], int levelsCount, int32_t logicalFromVisual[]) = 0;
+};
+
+namespace sknonstd {
+template <> struct is_bitmask_enum<SkUnicode::CodeUnitFlags> : std::true_type {};
+}  // namespace sknonstd
+
+#endif // SkUnicode_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h
new file mode 100644
index 00000000..6e5781dd
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_client.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_client_DEFINED
+#define SkUnicode_client_DEFINED
+
+#include "include/core/SkSpan.h"
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <memory>
+#include <vector>
+
+namespace SkUnicodes::Client {
+SKUNICODE_API sk_sp<SkUnicode> Make(
+                SkSpan<char> text,
+                std::vector<SkUnicode::Position> words,
+                std::vector<SkUnicode::Position> graphemeBreaks,
+                std::vector<SkUnicode::LineBreakBefore> lineBreaks);
+}
+
+#endif // SkUnicode_client_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h
new file mode 100644
index 00000000..d389c8d6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu.h
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_icu_DEFINED
+#define SkUnicode_icu_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/skunicode/include/SkUnicode.h"
+
+namespace SkUnicodes::ICU {
+SKUNICODE_API sk_sp<SkUnicode> Make();
+}
+
+#endif //SkUnicode_icu_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h
new file mode 100644
index 00000000..222a448e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_icu4x.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_icu4x_DEFINED
+#define SkUnicode_icu4x_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <memory>
+
+namespace SkUnicodes::ICU4X {
+SKUNICODE_API sk_sp<SkUnicode> Make();
+}
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h
new file mode 100644
index 00000000..9bb4c72a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/include/SkUnicode_libgrapheme.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkUnicode_libgrapheme_DEFINED
+#define SkUnicode_libgrapheme_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <memory>
+
+namespace SkUnicodes::Libgrapheme {
+SKUNICODE_API sk_sp<SkUnicode> Make();
+}
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/skunicode.gni b/Source/ThirdParty/skia/modules/skunicode/skunicode.gni
new file mode 100644
index 00000000..8e854fd4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/skunicode.gni
@@ -0,0 +1,73 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/skunicode/include/BUILD.bazel
+#   //modules/skunicode/src/BUILD.bazel
+#   //modules/skunicode/tests/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# Generated by Bazel rule //modules/skunicode/include:hdrs
+skia_unicode_public = [
+  "$_modules/skunicode/include/SkUnicode.h",
+  "$_modules/skunicode/include/SkUnicode_client.h",
+  "$_modules/skunicode/include/SkUnicode_icu.h",
+  "$_modules/skunicode/include/SkUnicode_icu4x.h",
+  "$_modules/skunicode/include/SkUnicode_libgrapheme.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:srcs
+skia_unicode_sources = [
+  "$_modules/skunicode/src/SkUnicode.cpp",
+  "$_modules/skunicode/src/SkUnicode_hardcoded.cpp",
+  "$_modules/skunicode/src/SkUnicode_hardcoded.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:icu_srcs
+skia_unicode_icu_sources = [
+  "$_modules/skunicode/src/SkUnicode_icu.cpp",
+  "$_modules/skunicode/src/SkUnicode_icupriv.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:icu_bidi_srcs
+skia_unicode_icu_bidi_sources = [
+  "$_modules/skunicode/src/SkUnicode_icu_bidi.cpp",
+  "$_modules/skunicode/src/SkUnicode_icu_bidi.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:bidi_full_srcs
+skia_unicode_bidi_full_sources = [
+  "$_modules/skunicode/src/SkBidiFactory_icu_full.cpp",
+  "$_modules/skunicode/src/SkBidiFactory_icu_full.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:bidi_subset_srcs
+skia_unicode_bidi_subset_sources = [
+  "$_modules/skunicode/src/SkBidiFactory_icu_subset.cpp",
+  "$_modules/skunicode/src/SkBidiFactory_icu_subset.h",
+]
+
+# Generated by Bazel rule //modules/skunicode/src:icu4x_srcs
+skia_unicode_icu4x_sources = [ "$_modules/skunicode/src/SkUnicode_icu4x.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:client_srcs
+skia_unicode_client_icu_sources =
+    [ "$_modules/skunicode/src/SkUnicode_client.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:builtin_srcs
+skia_unicode_builtin_icu_sources =
+    [ "$_modules/skunicode/src/SkUnicode_icu_builtin.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:runtime_srcs
+skia_unicode_runtime_icu_sources =
+    [ "$_modules/skunicode/src/SkUnicode_icu_runtime.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/src:libgrapheme_srcs
+skia_unicode_libgrapheme_sources =
+    [ "$_modules/skunicode/src/SkUnicode_libgrapheme.cpp" ]
+
+# Generated by Bazel rule //modules/skunicode/tests:tests
+skia_unicode_tests = [ "$_modules/skunicode/tests/SkUnicodeTest.cpp" ]
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel
new file mode 100644
index 00000000..dd3144a1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/BUILD.bazel
@@ -0,0 +1,103 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+# In own group for export to //modules/skunicode/skunicode.gni:skia_unicode_builtin_icu_sources.
+skia_filegroup(
+    name = "builtin_srcs",
+    srcs = ["SkUnicode_icu_builtin.cpp"],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+# In own group for export to //modules/skunicode/skunicode.gni:skia_unicode_runtime_icu_sources.
+skia_filegroup(
+    name = "runtime_srcs",
+    srcs = ["SkUnicode_icu_runtime.cpp"],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+# In own group for export to //modules/skunicode/skunicode.gni:skia_unicode_common_icu_sources.
+skia_filegroup(
+    name = "srcs",
+    srcs = [
+        "SkUnicode.cpp",
+        "SkUnicode_hardcoded.cpp",
+        "SkUnicode_hardcoded.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_bidi_srcs",
+    srcs = [
+        "SkUnicode_icu_bidi.cpp",
+        "SkUnicode_icu_bidi.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "bidi_full_srcs",
+    srcs = [
+        "SkBidiFactory_icu_full.cpp",
+        "SkBidiFactory_icu_full.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "bidi_subset_srcs",
+    srcs = [
+        "SkBidiFactory_icu_subset.cpp",
+        "SkBidiFactory_icu_subset.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_srcs",
+    srcs = [
+        "SkUnicode_icu.cpp",
+        "SkUnicode_icupriv.h",
+        ":builtin_srcs",
+        # TODO(kjlubick, bungeman): add support for SkUnicode_icu_runtime.cpp
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu_core_srcs",
+    srcs = [
+        "SkUnicode_icu.cpp",
+        "SkUnicode_icupriv.h",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "client_srcs",
+    srcs = [
+        "SkUnicode_client.cpp",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "libgrapheme_srcs",
+    srcs = [
+        "SkUnicode_libgrapheme.cpp",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
+
+skia_filegroup(
+    name = "icu4x_srcs",
+    srcs = [
+        "SkUnicode_icu4x.cpp",
+    ],
+    visibility = ["//modules/skunicode:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp
new file mode 100644
index 00000000..cc0abeb4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skunicode/src/SkBidiFactory_icu_full.h"
+
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+const char* SkBidiICUFactory::errorName(UErrorCode status) const {
+    return SkGetICULib()->f_u_errorName(status);
+}
+
+SkBidiFactory::BidiCloseCallback SkBidiICUFactory::bidi_close_callback() const {
+    return SkGetICULib()->f_ubidi_close;
+}
+
+UBiDiDirection SkBidiICUFactory::bidi_getDirection(const UBiDi* bidi) const {
+    return SkGetICULib()->f_ubidi_getDirection(bidi);
+}
+
+SkBidiIterator::Position SkBidiICUFactory::bidi_getLength(const UBiDi* bidi) const {
+    return SkGetICULib()->f_ubidi_getLength(bidi);
+}
+
+SkBidiIterator::Level SkBidiICUFactory::bidi_getLevelAt(const UBiDi* bidi, int pos) const {
+    return SkGetICULib()->f_ubidi_getLevelAt(bidi, pos);
+}
+
+UBiDi* SkBidiICUFactory::bidi_openSized(int32_t maxLength,
+                                        int32_t maxRunCount,
+                                        UErrorCode* pErrorCode) const {
+    return SkGetICULib()->f_ubidi_openSized(maxLength, maxRunCount, pErrorCode);
+}
+
+void SkBidiICUFactory::bidi_setPara(UBiDi* bidi,
+                                    const UChar* text,
+                                    int32_t length,
+                                    UBiDiLevel paraLevel,
+                                    UBiDiLevel* embeddingLevels,
+                                    UErrorCode* status) const {
+    return SkGetICULib()->f_ubidi_setPara(bidi, text, length, paraLevel, embeddingLevels, status);
+}
+
+void SkBidiICUFactory::bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                                          int levelsCount,
+                                          int32_t logicalFromVisual[]) const {
+    SkGetICULib()->f_ubidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h
new file mode 100644
index 00000000..74eeeb06
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_full.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkBidiICUFactory_DEFINED
+#define SkBidiICUFactory_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+
+class SkBidiICUFactory : public SkBidiFactory {
+public:
+    const char* errorName(UErrorCode status) const override;
+    SkBidiFactory::BidiCloseCallback bidi_close_callback() const override;
+    UBiDiDirection bidi_getDirection(const UBiDi* bidi) const override;
+    SkBidiIterator::Position bidi_getLength(const UBiDi* bidi) const override;
+    SkBidiIterator::Level bidi_getLevelAt(const UBiDi* bidi, int pos) const override;
+    UBiDi* bidi_openSized(int32_t maxLength,
+                          int32_t maxRunCount,
+                          UErrorCode* pErrorCode) const override;
+    void bidi_setPara(UBiDi* bidi,
+                      const UChar* text,
+                      int32_t length,
+                      UBiDiLevel paraLevel,
+                      UBiDiLevel* embeddingLevels,
+                      UErrorCode* status) const override;
+    void bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                            int levelsCount,
+                            int32_t logicalFromVisual[]) const override;
+};
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp
new file mode 100644
index 00000000..71399ba9
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.cpp
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skunicode/src/SkBidiFactory_icu_subset.h"
+
+#include <unicode/umachine.h>
+
+const char* SkBidiSubsetFactory::errorName(UErrorCode status) const {
+    return u_errorName_skia(status);
+}
+
+SkBidiFactory::BidiCloseCallback SkBidiSubsetFactory::bidi_close_callback() const {
+    return ubidi_close_skia;
+}
+
+UBiDiDirection SkBidiSubsetFactory::bidi_getDirection(const UBiDi* bidi) const {
+    return ubidi_getDirection_skia(bidi);
+}
+
+SkBidiIterator::Position SkBidiSubsetFactory::bidi_getLength(const UBiDi* bidi) const {
+    return ubidi_getLength_skia(bidi);
+}
+
+SkBidiIterator::Level SkBidiSubsetFactory::bidi_getLevelAt(const UBiDi* bidi, int pos) const {
+    return ubidi_getLevelAt_skia(bidi, pos);
+}
+
+UBiDi* SkBidiSubsetFactory::bidi_openSized(int32_t maxLength,
+                                           int32_t maxRunCount,
+                                           UErrorCode* pErrorCode) const {
+    return ubidi_openSized_skia(maxLength, maxRunCount, pErrorCode);
+}
+
+void SkBidiSubsetFactory::bidi_setPara(UBiDi* bidi,
+                                       const UChar* text,
+                                       int32_t length,
+                                       UBiDiLevel paraLevel,
+                                       UBiDiLevel* embeddingLevels,
+                                       UErrorCode* status) const {
+    return ubidi_setPara_skia(bidi, text, length, paraLevel, embeddingLevels, status);
+}
+
+void SkBidiSubsetFactory::bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                                             int levelsCount,
+                                             int32_t logicalFromVisual[]) const {
+    ubidi_reorderVisual_skia(runLevels, levelsCount, logicalFromVisual);
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h
new file mode 100644
index 00000000..583b90ef
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkBidiFactory_icu_subset.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2024 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkBidiSubsetFactory_DEFINED
+#define SkBidiSubsetFactory_DEFINED
+
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+
+class SkBidiSubsetFactory : public SkBidiFactory {
+public:
+    const char* errorName(UErrorCode status) const override;
+    SkBidiFactory::BidiCloseCallback bidi_close_callback() const override;
+    UBiDiDirection bidi_getDirection(const UBiDi* bidi) const override;
+    SkBidiIterator::Position bidi_getLength(const UBiDi* bidi) const override;
+    SkBidiIterator::Level bidi_getLevelAt(const UBiDi* bidi, int pos) const override;
+    UBiDi* bidi_openSized(int32_t maxLength,
+                          int32_t maxRunCount,
+                          UErrorCode* pErrorCode) const override;
+    void bidi_setPara(UBiDi* bidi,
+                      const UChar* text,
+                      int32_t length,
+                      UBiDiLevel paraLevel,
+                      UBiDiLevel* embeddingLevels,
+                      UErrorCode* status) const override;
+    void bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                            int levelsCount,
+                            int32_t logicalFromVisual[]) const override;
+};
+
+#endif
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp
new file mode 100644
index 00000000..e027e319
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode.cpp
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkTemplates.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkBitmaskEnum.h"
+
+using namespace skia_private;
+
+SkString SkUnicode::convertUtf16ToUtf8(const char16_t* utf16, int utf16Units) {
+
+    int utf8Units = SkUTF::UTF16ToUTF8(nullptr, 0, (uint16_t*)utf16, utf16Units);
+    if (utf8Units < 0) {
+        SkDEBUGF("Convert error: Invalid utf16 input");
+        return SkString();
+    }
+    AutoTArray<char> utf8(utf8Units);
+    SkDEBUGCODE(int dstLen =) SkUTF::UTF16ToUTF8(utf8.data(), utf8Units, (uint16_t*)utf16, utf16Units);
+    SkASSERT(dstLen == utf8Units);
+
+    return SkString(utf8.data(), utf8Units);
+}
+
+SkString SkUnicode::convertUtf16ToUtf8(const std::u16string& utf16) {
+    return convertUtf16ToUtf8(utf16.c_str(), utf16.size());
+}
+
+std::u16string SkUnicode::convertUtf8ToUtf16(const char* utf8, int utf8Units) {
+
+    int utf16Units = SkUTF::UTF8ToUTF16(nullptr, 0, utf8, utf8Units);
+    if (utf16Units < 0) {
+        SkDEBUGF("Convert error: Invalid utf8 input");
+        return std::u16string();
+    }
+
+    AutoTArray<uint16_t> utf16(utf16Units);
+    SkDEBUGCODE(int dstLen =) SkUTF::UTF8ToUTF16(utf16.data(), utf16Units, utf8, utf8Units);
+    SkASSERT(dstLen == utf16Units);
+
+    return std::u16string((char16_t *)utf16.data(), utf16Units);
+}
+
+std::u16string SkUnicode::convertUtf8ToUtf16(const SkString& utf8) {
+    return convertUtf8ToUtf16(utf8.c_str(), utf8.size());
+}
+
+bool SkUnicode::hasTabulationFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kTabulation) == SkUnicode::kTabulation;
+}
+
+bool SkUnicode::hasHardLineBreakFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kHardLineBreakBefore) == SkUnicode::kHardLineBreakBefore;
+}
+
+bool SkUnicode::hasSoftLineBreakFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kSoftLineBreakBefore) == SkUnicode::kSoftLineBreakBefore;
+}
+
+bool SkUnicode::hasGraphemeStartFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kGraphemeStart) == SkUnicode::kGraphemeStart;
+}
+
+bool SkUnicode::hasControlFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kControl) == SkUnicode::kControl;
+}
+
+bool SkUnicode::hasPartOfWhiteSpaceBreakFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kPartOfWhiteSpaceBreak) == SkUnicode::kPartOfWhiteSpaceBreak;
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp
new file mode 100644
index 00000000..5b33d7ae
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_client.cpp
@@ -0,0 +1,263 @@
+/*
+* Copyright 2022 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+#include "modules/skunicode/include/SkUnicode_client.h"
+
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkBidiFactory_icu_subset.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "src/base/SkUTF.h"
+
+#include <algorithm>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+#include <array>
+#include <unicode/ubidi.h>
+#include <unicode/ubrk.h>
+#include <unicode/uchar.h>
+#include <unicode/uloc.h>
+#include <unicode/uscript.h>
+#include <unicode/ustring.h>
+#include <unicode/utext.h>
+#include <unicode/utypes.h>
+
+using namespace skia_private;
+
+class SkUnicode_client : public SkUnicodeHardCodedCharProperties {
+public:
+    struct Data {
+        SkSpan<const char> fText8;
+        SkSpan<const char16_t> fText16;
+        std::vector<Position> fWords;
+        std::vector<SkUnicode::Position> fGraphemeBreaks;
+        std::vector<SkUnicode::LineBreakBefore> fLineBreaks;
+        Data(SkSpan<char> text,
+             std::vector<SkUnicode::Position> words,
+             std::vector<SkUnicode::Position> graphemeBreaks,
+             std::vector<SkUnicode::LineBreakBefore> lineBreaks)
+            : fText8(text)
+            , fText16(SkSpan<const char16_t>(nullptr, 0))
+            , fWords(std::move(words))
+            , fGraphemeBreaks(std::move(graphemeBreaks))
+            , fLineBreaks(std::move(lineBreaks)) {
+        }
+
+        void reset() {
+            fText8 = SkSpan<const char>(nullptr, 0);
+            fText16 = SkSpan<const char16_t>(nullptr, 0);
+            fGraphemeBreaks.clear();
+            fLineBreaks.clear();
+        }
+    };
+    SkUnicode_client() = delete;
+    SkUnicode_client(SkSpan<char> text,
+                     std::vector<SkUnicode::Position> words,
+                     std::vector<SkUnicode::Position> graphemeBreaks,
+                     std::vector<SkUnicode::LineBreakBefore> lineBreaks)
+            : fData(std::make_shared<Data>(text,
+                                           std::move(words),
+                                           std::move(graphemeBreaks),
+                                           std::move(lineBreaks))) { }
+
+    ~SkUnicode_client() override = default;
+
+    void reset() { fData->reset(); }
+    // For SkShaper
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType breakType) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType breakType) override;
+    // For SkParagraph
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+        return fBidiFact->ExtractBidi(utf8, utf8Units, dir, results);
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        SkDEBUGF("Method 'getUtf8Words' is not implemented\n");
+        return false;
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkDEBUGF("Method 'getSentences' is not implemented\n");
+        return false;
+    }
+
+    bool computeCodeUnitFlags(char utf8[],
+                              int utf8Units,
+                              bool replaceTabs,
+                              TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+        for (auto& lineBreak : fData->fLineBreaks) {
+            (*results)[lineBreak.pos] |=
+                lineBreak.breakType == LineBreakType::kHardLineBreak
+                    ? CodeUnitFlags::kHardLineBreakBefore
+                    : CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        for (auto& grapheme : fData->fGraphemeBreaks) {
+            (*results)[grapheme] |= CodeUnitFlags::kGraphemeStart;
+        }
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && this->isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                if (this->isSpace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (this->isWhitespace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf16Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+        for (auto& lineBreak : fData->fLineBreaks) {
+            (*results)[lineBreak.pos] |=
+                lineBreak.breakType == LineBreakType::kHardLineBreak
+                    ? CodeUnitFlags::kHardLineBreakBefore
+                    : CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        for (auto& grapheme : fData->fGraphemeBreaks) {
+            (*results)[grapheme] |= CodeUnitFlags::kGraphemeStart;
+        }
+        return true;
+    }
+
+    bool getWords(const char utf8[], int utf8Units, const char* locale, std::vector<Position>* results) override {
+        *results = fData->fWords;
+        return true;
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return this->toUpper(str, nullptr);
+    }
+
+    SkString toUpper(const SkString& str, const char* locale) override {
+        return SkString(fData->fText8.data(), fData->fText8.size());
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+        fBidiFact->bidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+    }
+private:
+    friend class SkBreakIterator_client;
+
+    std::shared_ptr<Data> fData;
+    sk_sp<SkBidiFactory> fBidiFact = sk_make_sp<SkBidiSubsetFactory>();
+};
+
+class SkBreakIterator_client: public SkBreakIterator {
+    std::shared_ptr<SkUnicode_client::Data> fData;
+    Position fLastResult;
+    Position fStart;
+    Position fEnd;
+public:
+    explicit SkBreakIterator_client(std::shared_ptr<SkUnicode_client::Data> data) : fData(data) { }
+    Position first() override
+      { return fData->fLineBreaks[fStart + (fLastResult = 0)].pos; }
+    Position current() override
+      { return fData->fLineBreaks[fStart + fLastResult].pos; }
+    Position next() override
+      { return fData->fLineBreaks[fStart + fLastResult + 1].pos; }
+    Status status() override {
+        return fData->fLineBreaks[fStart + fLastResult].breakType ==
+                       SkUnicode::LineBreakType::kHardLineBreak
+                       ? SkUnicode::CodeUnitFlags::kHardLineBreakBefore
+                       : SkUnicode::CodeUnitFlags::kSoftLineBreakBefore;
+    }
+    bool isDone() override { return fStart + fLastResult == fEnd; }
+    bool setText(const char utftext8[], int utf8Units) override {
+        SkASSERT(utftext8 >= fData->fText8.data() &&
+                 utf8Units <= SkToS16(fData->fText8.size()));
+        fStart = utftext8 - fData->fText8.data();
+        fEnd = fStart + utf8Units;
+        fLastResult = 0;
+        return true;
+    }
+    bool setText(const char16_t utftext16[], int utf16Units) override {
+        SkASSERT(utftext16 >= fData->fText16.data() &&
+                 utf16Units <= SkToS16(fData->fText16.size()));
+        fStart = utftext16 - fData->fText16.data();
+        fEnd = fStart + utf16Units;
+        fLastResult = 0;
+        return true;
+    }
+};
+std::unique_ptr<SkBidiIterator> SkUnicode_client::makeBidiIterator(const uint16_t text[], int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBidiIterator> SkUnicode_client::makeBidiIterator(const char text[],
+                                                 int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_client::makeBreakIterator(const char locale[],
+                                                   BreakType breakType) {
+    return std::make_unique<SkBreakIterator_client>(fData);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_client::makeBreakIterator(BreakType breakType) {
+    return std::make_unique<SkBreakIterator_client>(fData);
+}
+
+namespace SkUnicodes::Client {
+sk_sp<SkUnicode> Make(
+        SkSpan<char> text,
+        std::vector<SkUnicode::Position> words,
+        std::vector<SkUnicode::Position> graphemeBreaks,
+        std::vector<SkUnicode::LineBreakBefore> lineBreaks) {
+    return sk_make_sp<SkUnicode_client>(text,
+                                        std::move(words),
+                                        std::move(graphemeBreaks),
+                                        std::move(lineBreaks));
+}
+}
+
+
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp
new file mode 100644
index 00000000..6cabd3f9
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.cpp
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2023 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/private/base/SkDebug.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include <algorithm>
+#include <array>
+#include <utility>
+
+bool SkUnicodeHardCodedCharProperties::isControl(SkUnichar utf8) {
+    return (utf8 < ' ') || (utf8 >= 0x7f && utf8 <= 0x9f) ||
+           (utf8 >= 0x200D && utf8 <= 0x200F) ||
+           (utf8 >= 0x202A && utf8 <= 0x202E);
+}
+
+bool SkUnicodeHardCodedCharProperties::isWhitespace(SkUnichar unichar) {
+    static constexpr std::array<SkUnichar, 21> whitespaces {
+            0x0009, // character tabulation
+            0x000A, // line feed
+            0x000B, // line tabulation
+            0x000C, // form feed
+            0x000D, // carriage return
+            0x0020, // space
+          //0x0085, // next line
+          //0x00A0, // no-break space
+            0x1680, // ogham space mark
+            0x2000, // en quad
+            0x2001, // em quad
+            0x2002, // en space
+            0x2003, // em space
+            0x2004, // three-per-em space
+            0x2005, // four-per-em space
+            0x2006, // six-per-em space
+          //0x2007, // figure space
+            0x2008, // punctuation space
+            0x2009, // thin space
+            0x200A, // hair space
+            0x2028, // line separator
+            0x2029, // paragraph separator
+          //0x202F, // narrow no-break space
+            0x205F, // medium mathematical space
+            0x3000};// ideographic space
+    return std::find(whitespaces.begin(), whitespaces.end(), unichar) != whitespaces.end();
+}
+
+bool SkUnicodeHardCodedCharProperties::isSpace(SkUnichar unichar) {
+    static constexpr std::array<SkUnichar, 25> spaces {
+            0x0009, // character tabulation
+            0x000A, // line feed
+            0x000B, // line tabulation
+            0x000C, // form feed
+            0x000D, // carriage return
+            0x0020, // space
+            0x0085, // next line
+            0x00A0, // no-break space
+            0x1680, // ogham space mark
+            0x2000, // en quad
+            0x2001, // em quad
+            0x2002, // en space
+            0x2003, // em space
+            0x2004, // three-per-em space
+            0x2005, // four-per-em space
+            0x2006, // six-per-em space
+            0x2007, // figure space
+            0x2008, // punctuation space
+            0x2009, // thin space
+            0x200A, // hair space
+            0x2028, // line separator
+            0x2029, // paragraph separator
+            0x202F, // narrow no-break space
+            0x205F, // medium mathematical space
+            0x3000}; // ideographic space
+    return std::find(spaces.begin(), spaces.end(), unichar) != spaces.end();
+}
+
+bool SkUnicodeHardCodedCharProperties::isTabulation(SkUnichar utf8) {
+    return utf8 == '\t';
+}
+
+bool SkUnicodeHardCodedCharProperties::isHardBreak(SkUnichar utf8) {
+    return utf8 == '\n' || utf8 == u'\u2028';
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmoji(SkUnichar unichar) {
+    SkDEBUGFAIL("isEmoji Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmojiComponent(SkUnichar utf8)  {
+    SkDEBUGFAIL("isEmojiComponent Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmojiModifier(SkUnichar utf8)  {
+    SkDEBUGFAIL("isEmojiModifier Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isEmojiModifierBase(SkUnichar utf8) {
+    SkDEBUGFAIL("isEmojiModifierBase Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isRegionalIndicator(SkUnichar unichar) {
+    SkDEBUGFAIL("isRegionalIndicator Not implemented");
+    return false;
+}
+
+bool SkUnicodeHardCodedCharProperties::isIdeographic(SkUnichar unichar) {
+    static constexpr std::array<std::pair<SkUnichar, SkUnichar>, 8> ranges {{
+          {4352,   4607}, // Hangul Jamo
+          {11904, 42191}, // CJK_Radicals
+          {43072, 43135}, // Phags_Pa
+          {44032, 55215}, // Hangul_Syllables
+          {63744, 64255}, // CJK_Compatibility_Ideographs
+          {65072, 65103}, // CJK_Compatibility_Forms
+          {65381, 65500}, // Katakana_Hangul_Halfwidth
+          {131072, 196607}// Supplementary_Ideographic_Plane
+    }};
+    for (auto range : ranges) {
+        if (range.first <= unichar && range.second > unichar) {
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h
new file mode 100644
index 00000000..39e4cd3d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_hardcoded.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2023 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_hardcoded_DEFINED
+#define SkUnicode_hardcoded_DEFINED
+
+#include "include/core/SkTypes.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "src/base/SkUTF.h"
+
+class SKUNICODE_API SkUnicodeHardCodedCharProperties : public SkUnicode {
+public:
+    bool isControl(SkUnichar utf8) override;
+    bool isWhitespace(SkUnichar utf8) override;
+    bool isSpace(SkUnichar utf8) override;
+    bool isTabulation(SkUnichar utf8) override;
+    bool isHardBreak(SkUnichar utf8) override;
+    bool isEmoji(SkUnichar utf8) override;
+    bool isEmojiComponent(SkUnichar utf8) override;
+    bool isEmojiModifierBase(SkUnichar utf8) override;
+    bool isEmojiModifier(SkUnichar utf8) override;
+    bool isRegionalIndicator(SkUnichar utf8) override;
+    bool isIdeographic(SkUnichar utf8) override;
+};
+
+#endif // SkUnicode_hardcoded_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp
new file mode 100644
index 00000000..b8ff31d2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu.cpp
@@ -0,0 +1,700 @@
+/*
+* Copyright 2020 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+#include "modules/skunicode/include/SkUnicode_icu.h"
+
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkMutex.h"
+#include "include/private/base/SkSpan_impl.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTemplates.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkBidiFactory_icu_full.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "src/base/SkUTF.h"
+#include "src/core/SkChecksum.h"
+#include "src/core/SkTHash.h"
+
+#include <unicode/ubrk.h>
+#include <unicode/uchar.h>
+#include <unicode/uloc.h>
+#include <unicode/umachine.h>
+#include <unicode/utext.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+#include <cstring>
+#include <functional>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+#if defined(SK_USING_THIRD_PARTY_ICU) && defined(SK_BUILD_FOR_WIN)
+#include "SkLoadICU.h"
+#include "include/private/base/SkOnce.h"
+#endif
+
+using namespace skia_private;
+
+const SkICULib* SkGetICULib() {
+    static const auto gICU = SkLoadICULib();
+    return gICU.get();
+}
+
+// sk_* wrappers for ICU funcs
+#define SKICU_FUNC(funcname)                                                                \
+    template <typename... Args>                                                             \
+    auto sk_##funcname(Args&&... args) -> decltype(funcname(std::forward<Args>(args)...)) { \
+        return SkGetICULib()->f_##funcname(std::forward<Args>(args)...);                    \
+    }                                                                                       \
+
+SKICU_EMIT_FUNCS
+#undef SKICU_FUNC
+
+static inline UBreakIterator* sk_ubrk_clone(const UBreakIterator* bi, UErrorCode* status) {
+    const auto* icu = SkGetICULib();
+    SkASSERT(icu->f_ubrk_clone_ || icu->f_ubrk_safeClone_);
+    return icu->f_ubrk_clone_
+        ? icu->f_ubrk_clone_(bi, status)
+        : icu->f_ubrk_safeClone_(bi, nullptr, nullptr, status);
+}
+
+static UText* utext_close_wrapper(UText* ut) {
+    return sk_utext_close(ut);
+}
+static void ubrk_close_wrapper(UBreakIterator* bi) {
+    sk_ubrk_close(bi);
+}
+
+using ICUUText = std::unique_ptr<UText, SkFunctionObject<utext_close_wrapper>>;
+using ICUBreakIterator = std::unique_ptr<UBreakIterator, SkFunctionObject<ubrk_close_wrapper>>;
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+static UBreakIteratorType convertType(SkUnicode::BreakType type) {
+    switch (type) {
+        case SkUnicode::BreakType::kLines: return UBRK_LINE;
+        case SkUnicode::BreakType::kGraphemes: return UBRK_CHARACTER;
+        case SkUnicode::BreakType::kWords: return UBRK_WORD;
+        case SkUnicode::BreakType::kSentences:
+            return UBRK_SENTENCE;
+        default:
+            return UBRK_CHARACTER;
+    }
+}
+
+class SkBreakIterator_icu : public SkBreakIterator {
+    ICUBreakIterator fBreakIterator;
+    Position fLastResult;
+ public:
+    explicit SkBreakIterator_icu(ICUBreakIterator iter)
+            : fBreakIterator(std::move(iter))
+            , fLastResult(0) {}
+    Position first() override { return fLastResult = sk_ubrk_first(fBreakIterator.get()); }
+    Position current() override { return fLastResult = sk_ubrk_current(fBreakIterator.get()); }
+    Position next() override { return fLastResult = sk_ubrk_next(fBreakIterator.get()); }
+    Status status() override { return sk_ubrk_getRuleStatus(fBreakIterator.get()); }
+    bool isDone() override { return fLastResult == UBRK_DONE; }
+
+    bool setText(const char utftext8[], int utf8Units) override {
+        UErrorCode status = U_ZERO_ERROR;
+        ICUUText text(sk_utext_openUTF8(nullptr, &utftext8[0], utf8Units, &status));
+
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(text);
+        sk_ubrk_setUText(fBreakIterator.get(), text.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        fLastResult = 0;
+        return true;
+    }
+    bool setText(const char16_t utftext16[], int utf16Units) override {
+        UErrorCode status = U_ZERO_ERROR;
+        ICUUText text(sk_utext_openUChars(nullptr, reinterpret_cast<const UChar*>(&utftext16[0]),
+                                          utf16Units, &status));
+
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(text);
+        sk_ubrk_setUText(fBreakIterator.get(), text.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        fLastResult = 0;
+        return true;
+    }
+};
+
+class SkIcuBreakIteratorCache final {
+    struct Request final {
+        Request(SkUnicode::BreakType type, const char* icuLocale)
+            : fType(type)
+            , fIcuLocale(icuLocale)
+            , hash(SkGoodHash()(type) ^ SkGoodHash()(fIcuLocale))
+        {}
+        const SkUnicode::BreakType fType;
+        const SkString fIcuLocale;
+        const uint32_t hash;
+        struct Hash {
+            uint32_t operator()(const Request& key) const {
+                return key.hash;
+            }
+        };
+        bool operator==(const Request& that) const {
+            return this->fType == that.fType && this->fIcuLocale == that.fIcuLocale;
+        }
+    };
+    /* Every holder of this class is referencing the same (logical) break iterator.
+     * Due to caching, the actual break iterator may come and go.
+     */
+    class BreakIteratorRef final {
+    public:
+        BreakIteratorRef(ICUBreakIterator iter) : breakIterator(iter.release()), fRefCnt(1) {
+            ++Instances;
+        }
+        BreakIteratorRef(SkRefCntBase&&) = delete;
+        BreakIteratorRef(const SkRefCntBase&) = delete;
+        BreakIteratorRef& operator=(SkRefCntBase&&) = delete;
+        BreakIteratorRef& operator=(const SkRefCntBase&) = delete;
+        ~BreakIteratorRef() {
+            if (breakIterator) {
+                ubrk_close_wrapper(breakIterator);
+            }
+        }
+
+        void ref() const {
+            SkASSERT(fRefCnt > 0);
+            ++fRefCnt;
+        }
+        void unref() const {
+            SkASSERT(fRefCnt > 0);
+            if (1 == fRefCnt--) {
+                delete this;
+                --Instances;
+            }
+        }
+
+        UBreakIterator* breakIterator;
+        static int32_t GetInstanceCount() { return Instances; }
+    private:
+        mutable int32_t fRefCnt;
+        static int32_t Instances;
+    };
+    THashMap<Request, sk_sp<BreakIteratorRef>, Request::Hash> fRequestCache;
+    SkMutex fCacheMutex;
+
+    void purgeIfNeeded() {
+        // If there are too many requests remove some (oldest first?)
+        // This may free some break iterators
+        if (fRequestCache.count() > 100) {
+            // remove the oldest requests
+            fRequestCache.reset();
+        }
+        // If there are still too many break iterators remove some (oldest first?)
+        if (BreakIteratorRef::GetInstanceCount() > 4) {
+            // delete the oldest break iterators and set the references to nullptr
+            for (auto&& [key, value] : fRequestCache) {
+                if (value->breakIterator) {
+                    sk_ubrk_close(value->breakIterator);
+                    value->breakIterator = nullptr;
+                }
+            }
+        }
+    }
+
+ public:
+    static SkIcuBreakIteratorCache& get() {
+        static SkIcuBreakIteratorCache instance;
+        return instance;
+    }
+
+    ICUBreakIterator makeBreakIterator(SkUnicode::BreakType type, const char* bcp47) {
+        SkAutoMutexExclusive lock(fCacheMutex);
+        UErrorCode status = U_ZERO_ERROR;
+
+        // Get ICU locale for BCP47 langtag
+        char localeIDStorage[ULOC_FULLNAME_CAPACITY];
+        const char* localeID = nullptr;
+        if (bcp47) {
+            sk_uloc_forLanguageTag(bcp47, localeIDStorage, ULOC_FULLNAME_CAPACITY, nullptr, &status);
+            if (U_FAILURE(status)) {
+                SkDEBUGF("Break error could not get language tag: %s", sk_u_errorName(status));
+            } else if (localeIDStorage[0]) {
+                localeID = localeIDStorage;
+            }
+        }
+        if (!localeID) {
+            localeID = sk_uloc_getDefault();
+        }
+
+        auto make = [](const Request& request) -> UBreakIterator* {
+            UErrorCode status = U_ZERO_ERROR;
+            UBreakIterator* bi = sk_ubrk_open(convertType(request.fType),
+                                              request.fIcuLocale.c_str(),
+                                              nullptr, 0, &status);
+            if (U_FAILURE(status)) {
+                SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            }
+            return bi;
+        };
+
+        auto clone = [](const UBreakIterator* existing) -> ICUBreakIterator {
+            if (!existing) {
+                return nullptr;
+            }
+
+            UErrorCode status = U_ZERO_ERROR;
+            ICUBreakIterator clone(sk_ubrk_clone(existing, &status));
+            if (U_FAILURE(status)) {
+                SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            }
+            return clone;
+        };
+
+        Request request(type, localeID);
+
+        // See if this request is already in the cache
+        const sk_sp<BreakIteratorRef>* ref = fRequestCache.find(request);
+        if (ref) {
+            // See if the breakIterator needs to be re-created
+            if (!(*ref)->breakIterator) {
+                (*ref)->breakIterator = make(request);
+            }
+            return clone((*ref)->breakIterator);
+        }
+
+        // This request was not in the cache, create an iterator.
+        ICUBreakIterator newIter(make(request));
+        if (!newIter) {
+            return nullptr;
+        }
+
+        sk_sp<BreakIteratorRef> newRef;
+
+        // Check if the new iterator is a duplicate
+        // Android doesn't expose ubrk_getLocaleByType so there is no means of de-duplicating.
+        // ubrk_getAvailable seems like it should work, but the implementation is just every locale.
+        if (SkGetICULib()->f_ubrk_getLocaleByType) {
+            const char* actualLocale = SkGetICULib()->f_ubrk_getLocaleByType(
+                                           newIter.get(), ULOC_ACTUAL_LOCALE, &status);
+            // Android doesn't expose ubrk_getLocaleByType so a wrapper may return an error.
+            if (!U_FAILURE(status)) {
+                if (!actualLocale) {
+                    actualLocale = "";
+                }
+                // If the actual locale is the same as the requested locale we know there is no entry.
+                if (strcmp(actualLocale, localeID) != 0) {
+                    Request actualRequest(type, actualLocale);
+                    const sk_sp<BreakIteratorRef>* actualRef = fRequestCache.find(actualRequest);
+                    if (actualRef) {
+                        if (!(*actualRef)->breakIterator) {
+                            (*actualRef)->breakIterator = newIter.release();
+                        }
+                        actualRef = fRequestCache.set(request, *actualRef);
+                        return clone((*actualRef)->breakIterator);
+                    } else {
+                        this->purgeIfNeeded();
+                        newRef = sk_make_sp<BreakIteratorRef>(std::move(newIter));
+                        fRequestCache.set(actualRequest, newRef);
+                    }
+                }
+            }
+        }
+
+        if (!newRef) {
+            this->purgeIfNeeded();
+            newRef = sk_make_sp<BreakIteratorRef>(std::move(newIter));
+        }
+        fRequestCache.set(request, newRef);
+
+        return clone(newRef->breakIterator);
+    }
+};
+/*static*/ int32_t SkIcuBreakIteratorCache::BreakIteratorRef::Instances{0};
+
+class SkUnicode_icu : public SkUnicode {
+
+    static bool extractWords(uint16_t utf16[], int utf16Units, const char* locale,
+                             std::vector<Position>* words) {
+
+        UErrorCode status = U_ZERO_ERROR;
+
+        const BreakType type = BreakType::kWords;
+        ICUBreakIterator iterator = SkIcuBreakIteratorCache::get().makeBreakIterator(type, locale);
+        if (!iterator) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(iterator);
+
+        ICUUText utf16UText(sk_utext_openUChars(nullptr, (UChar*)utf16, utf16Units, &status));
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+
+        sk_ubrk_setUText(iterator.get(), utf16UText.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+
+        // Get the words
+        int32_t pos = sk_ubrk_first(iterator.get());
+        while (pos != UBRK_DONE) {
+            words->emplace_back(pos);
+            pos = sk_ubrk_next(iterator.get());
+        }
+
+        return true;
+    }
+
+    static bool extractPositions(const char utf8[], int utf8Units,
+                                 BreakType type, const char* locale,
+                                 const std::function<void(int, int)>& setBreak) {
+
+        UErrorCode status = U_ZERO_ERROR;
+        ICUUText text(sk_utext_openUTF8(nullptr, &utf8[0], utf8Units, &status));
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+        SkASSERT(text);
+
+        ICUBreakIterator iterator = SkIcuBreakIteratorCache::get().makeBreakIterator(type, locale);
+        if (!iterator) {
+            return false;
+        }
+
+        sk_ubrk_setUText(iterator.get(), text.get(), &status);
+        if (U_FAILURE(status)) {
+            SkDEBUGF("Break error: %s", sk_u_errorName(status));
+            return false;
+        }
+
+        auto iter = iterator.get();
+        int32_t pos = sk_ubrk_first(iter);
+        while (pos != UBRK_DONE) {
+            int s = type == SkUnicode::BreakType::kLines
+                        ? UBRK_LINE_SOFT
+                        : sk_ubrk_getRuleStatus(iter);
+            setBreak(pos, s);
+            pos = sk_ubrk_next(iter);
+        }
+
+        if (type == SkUnicode::BreakType::kLines) {
+            // This is a workaround for https://bugs.chromium.org/p/skia/issues/detail?id=10715
+            // (ICU line break iterator does not work correctly on Thai text with new lines)
+            // So, we only use the iterator to collect soft line breaks and
+            // scan the text for all hard line breaks ourselves
+            const char* end = utf8 + utf8Units;
+            const char* ch = utf8;
+            while (ch < end) {
+                auto unichar = utf8_next(&ch, end);
+                if (SkUnicode_icu::isHardLineBreak(unichar)) {
+                    setBreak(ch - utf8, UBRK_LINE_HARD);
+                }
+            }
+        }
+        return true;
+    }
+
+    bool isControl(SkUnichar utf8) override {
+        return sk_u_iscntrl(utf8);
+    }
+
+    bool isWhitespace(SkUnichar utf8) override {
+        return sk_u_isWhitespace(utf8);
+    }
+
+    bool isSpace(SkUnichar utf8) override {
+        return sk_u_isspace(utf8);
+    }
+
+    bool isHardBreak(SkUnichar utf8) override {
+        return SkUnicode_icu::isHardLineBreak(utf8);
+    }
+
+    bool isEmoji(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI);
+    }
+
+    bool isEmojiComponent(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI_COMPONENT);
+    }
+
+    bool isEmojiModifierBase(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI_MODIFIER_BASE);
+    }
+
+    bool isEmojiModifier(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_EMOJI_MODIFIER);
+    }
+
+    bool isRegionalIndicator(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_REGIONAL_INDICATOR);
+    }
+
+    bool isIdeographic(SkUnichar unichar) override {
+        return sk_u_hasBinaryProperty(unichar, UCHAR_IDEOGRAPHIC);
+    }
+
+    bool isTabulation(SkUnichar utf8) override {
+        return utf8 == '\t';
+    }
+
+    static bool isHardLineBreak(SkUnichar utf8) {
+        auto property = sk_u_getIntPropertyValue(utf8, UCHAR_LINE_BREAK);
+        return property == U_LB_LINE_FEED || property == U_LB_MANDATORY_BREAK;
+    }
+
+public:
+    ~SkUnicode_icu() override { }
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override {
+        return fBidiFact->MakeIterator(text, count, dir);
+    }
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override {
+        return fBidiFact->MakeIterator(text, count, dir);
+    }
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType type) override {
+        ICUBreakIterator iterator = SkIcuBreakIteratorCache::get().makeBreakIterator(type, locale);
+        if (!iterator) {
+            return nullptr;
+        }
+        return std::unique_ptr<SkBreakIterator>(new SkBreakIterator_icu(std::move(iterator)));
+    }
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType type) override {
+        return makeBreakIterator(sk_uloc_getDefault(), type);
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return this->toUpper(str, nullptr);
+    }
+
+    SkString toUpper(const SkString& str, const char* locale) override {
+        // Convert to UTF16 since that's what ICU wants.
+        auto str16 = SkUnicode::convertUtf8ToUtf16(str.c_str(), str.size());
+
+        UErrorCode icu_err = U_ZERO_ERROR;
+        const auto upper16len = sk_u_strToUpper(nullptr, 0, (UChar*)(str16.c_str()), str16.size(),
+                                                locale, &icu_err);
+        if (icu_err != U_BUFFER_OVERFLOW_ERROR || upper16len <= 0) {
+            return SkString();
+        }
+
+        AutoSTArray<128, uint16_t> upper16(upper16len);
+        icu_err = U_ZERO_ERROR;
+        sk_u_strToUpper((UChar*)(upper16.get()), SkToS32(upper16.size()),
+                        (UChar*)(str16.c_str()), str16.size(),
+                        locale, &icu_err);
+        SkASSERT(!U_FAILURE(icu_err));
+
+        // ... and back to utf8 'cause that's what we want.
+        return convertUtf16ToUtf8((char16_t*)upper16.get(), upper16.size());
+    }
+
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+        return fBidiFact->ExtractBidi(utf8, utf8Units, dir, results);
+    }
+
+    bool getWords(const char utf8[], int utf8Units, const char* locale,
+                  std::vector<Position>* results) override {
+
+        // Convert to UTF16 since we want the results in utf16
+        auto utf16 = convertUtf8ToUtf16(utf8, utf8Units);
+        return SkUnicode_icu::extractWords((uint16_t*)utf16.c_str(), utf16.size(), locale, results);
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        // Convert to UTF16 since we want the results in utf16
+        auto utf16 = convertUtf8ToUtf16(utf8, utf8Units);
+        std::vector<Position> utf16Results;
+        if (!SkUnicode_icu::extractWords(
+                    (uint16_t*)utf16.c_str(), utf16.size(), locale, &utf16Results)) {
+            return false;
+        }
+
+        std::vector<Position> mapping;
+        SkSpan<const char> text(utf8, utf8Units);
+        SkUnicode::extractUtfConversionMapping(
+                text, [&](size_t index) { mapping.emplace_back(index); }, [&](size_t index) {});
+
+        for (auto i16 : utf16Results) {
+            results->emplace_back(mapping[i16]);
+        }
+        return true;
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkUnicode_icu::extractPositions(
+                utf8, utf8Units, BreakType::kSentences, nullptr,
+                [&](int pos, int status) {
+                    results->emplace_back(pos);
+                });
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char utf8[], int utf8Units, bool replaceTabs,
+                              TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        SkUnicode_icu::extractPositions(utf8, utf8Units, BreakType::kLines, nullptr, // TODO: locale
+                                        [&](int pos, int status) {
+            (*results)[pos] |= status == UBRK_LINE_HARD
+                                       ? CodeUnitFlags::kHardLineBreakBefore
+                                       : CodeUnitFlags::kSoftLineBreakBefore;
+        });
+
+        SkUnicode_icu::extractPositions(utf8, utf8Units, BreakType::kGraphemes, nullptr, //TODO
+                                        [&](int pos, int status) {
+            (*results)[pos] |= CodeUnitFlags::kGraphemeStart;
+        });
+
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && this->isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                if (this->isSpace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (this->isWhitespace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+                if (this->isIdeographic(unichar)) {
+                    results->at(i) |= SkUnicode::kIdeographic;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf16Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        // Get white spaces
+        this->forEachCodepoint((char16_t*)&utf16[0], utf16Units,
+           [this, results, replaceTabs, &utf16](SkUnichar unichar, int32_t start, int32_t end) {
+                for (auto i = start; i < end; ++i) {
+                    if (replaceTabs && this->isTabulation(unichar)) {
+                        results->at(i) |= SkUnicode::kTabulation;
+                    if (replaceTabs) {
+                            unichar = ' ';
+                            utf16[start] = ' ';
+                        }
+                    }
+                    if (this->isSpace(unichar)) {
+                        results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                    }
+                    if (this->isWhitespace(unichar)) {
+                        results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                    }
+                    if (this->isControl(unichar)) {
+                        results->at(i) |= SkUnicode::kControl;
+                    }
+                }
+           });
+        // Get graphemes
+        this->forEachBreak((char16_t*)&utf16[0],
+                           utf16Units,
+                           SkUnicode::BreakType::kGraphemes,
+                           [results](SkBreakIterator::Position pos, SkBreakIterator::Status) {
+                               (*results)[pos] |= CodeUnitFlags::kGraphemeStart;
+                           });
+        // Get line breaks
+        this->forEachBreak(
+                (char16_t*)&utf16[0],
+                utf16Units,
+                SkUnicode::BreakType::kLines,
+                [results](SkBreakIterator::Position pos, SkBreakIterator::Status status) {
+                    if (status ==
+                        (SkBreakIterator::Status)SkUnicode::LineBreakType::kHardLineBreak) {
+                        // Hard line breaks clears off all the other flags
+                        // TODO: Treat \n as a formatting mark and do not pass it to SkShaper
+                        (*results)[pos-1] = CodeUnitFlags::kHardLineBreakBefore;
+                    } else {
+                        (*results)[pos] |= CodeUnitFlags::kSoftLineBreakBefore;
+                    }
+                });
+
+        return true;
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+        fBidiFact->bidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+    }
+
+private:
+    sk_sp<SkBidiFactory> fBidiFact = sk_make_sp<SkBidiICUFactory>();
+};
+
+namespace SkUnicodes::ICU {
+sk_sp<SkUnicode> Make() {
+    // We haven't yet created a way to encode the ICU data for assembly on Windows,
+    // so we use a helper library to load icudtl.dat from the harddrive.
+#if defined(SK_USING_THIRD_PARTY_ICU) && defined(SK_BUILD_FOR_WIN)
+    if (!SkLoadICU()) {
+        static SkOnce once;
+        once([] { SkDEBUGF("SkLoadICU() failed!\n"); });
+        return nullptr;
+    }
+#endif
+    if (SkGetICULib()) {
+        return sk_make_sp<SkUnicode_icu>();
+    }
+    return nullptr;
+}
+}  // namespace SkUnicodes::ICU
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp
new file mode 100644
index 00000000..2fa6079a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu4x.cpp
@@ -0,0 +1,409 @@
+/*
+* Copyright 2023 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "src/base/SkUTF.h"
+
+#include <ICU4XBidi.hpp>
+#include <ICU4XCaseMapper.hpp>
+#include <ICU4XCodePointMapData8.hpp>
+#include <ICU4XCodePointSetData.hpp>
+#include <ICU4XDataProvider.hpp>
+#include <ICU4XGraphemeClusterSegmenter.hpp>
+#include <ICU4XLineSegmenter.hpp>
+#include <ICU4XWordSegmenter.hpp>
+
+#include <algorithm>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+class SkUnicode_icu4x :  public SkUnicode {
+public:
+    SkUnicode_icu4x() {
+        fLocale = ICU4XLocale::create_from_string("tr").ok().value();
+        fDataProvider = ICU4XDataProvider::create_compiled();
+        fCaseMapper = ICU4XCaseMapper::create(fDataProvider).ok().value();
+        const auto general = ICU4XCodePointMapData8::load_general_category(fDataProvider).ok().value();
+        fControls = general.get_set_for_value(/*Control*/15);
+        fWhitespaces = general.get_set_for_value(/*SpaceSeparator*/12);
+        fSpaces = general.get_set_for_value(/*SpaceSeparator*/12);
+        // TODO: u_isSpace
+        fBlanks = ICU4XCodePointSetData::load_blank(fDataProvider).ok().value();
+        fEmoji = ICU4XCodePointSetData::load_emoji(fDataProvider).ok().value();
+        fEmojiComponent = ICU4XCodePointSetData::load_emoji_component(fDataProvider).ok().value();
+        fEmojiModifier = ICU4XCodePointSetData::load_emoji_modifier(fDataProvider).ok().value();
+        fEmojiModifierBase = ICU4XCodePointSetData::load_emoji_modifier_base(fDataProvider).ok().value();
+        fEmoji = ICU4XCodePointSetData::load_emoji(fDataProvider).ok().value();
+        fRegionalIndicator = ICU4XCodePointSetData::load_regional_indicator(fDataProvider).ok().value();
+        fIdeographic = ICU4XCodePointSetData::load_ideographic(fDataProvider).ok().value();
+        fLineBreaks = ICU4XCodePointMapData8::load_line_break(fDataProvider).ok().value();
+    }
+
+    ~SkUnicode_icu4x() override = default;
+
+    void reset();
+
+    // SkUnicode properties
+    bool isControl(SkUnichar utf8) override { return fControls.contains(utf8); }
+    bool isWhitespace(SkUnichar utf8) override { return fWhitespaces.contains(utf8); }
+    bool isSpace(SkUnichar utf8) override { return fBlanks.contains(utf8); }
+    bool isHardBreak(SkUnichar utf8) override {
+        auto value = fLineBreaks.get(utf8);
+        return (value == /*MandatoryBreak*/6) ||
+               (value == /*CarriageReturn*/10) ||
+               (value == /*LineFeed*/17) ||
+               (value == /*NextLine*/29);
+    }
+    bool isEmoji(SkUnichar utf8) override { return fEmoji.contains(utf8); }
+    bool isEmojiComponent(SkUnichar utf8) override { return fEmojiComponent.contains(utf8); }
+    bool isEmojiModifierBase(SkUnichar utf8) override { return fEmojiModifierBase.contains(utf8); }
+    bool isEmojiModifier(SkUnichar utf8) override { return fEmojiModifier.contains(utf8); }
+    bool isRegionalIndicator(SkUnichar utf8) override { return fRegionalIndicator.contains(utf8); }
+    bool isIdeographic(SkUnichar utf8) override { return fIdeographic.contains(utf8); }
+
+    // TODO: is there a check for tabulation
+    bool isTabulation(SkUnichar utf8) override {
+        return utf8 == '\t';
+    }
+
+    // For SkShaper
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType breakType) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType breakType) override;
+    // For SkParagraph
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+
+        const auto bidi = ICU4XBidi::create(fDataProvider).ok().value();
+        std::string_view string_view(utf8, utf8Units);
+        auto info = bidi.for_text(string_view, dir == TextDirection::kLTR ? 0 : 1);
+        auto currentLevel = info.level_at(0);
+        size_t start = 0;
+
+        for (size_t i = 1; i < info.size(); i++) {
+            const auto level =  info.level_at(i);
+            if (level != currentLevel) {
+                (*results).emplace_back(start, i, currentLevel);
+                currentLevel = level;
+                start = i;
+            }
+        }
+        (*results).emplace_back(start, info.size(), currentLevel);
+        return true;
+    }
+
+    bool getBidiRegions(const uint16_t utf16[],
+                        int utf16Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) {
+        auto utf8 = SkUnicode::convertUtf16ToUtf8((char16_t*)utf16, utf16Units);
+        return this->getBidiRegions(utf8.data(), utf8.size(), dir, results);
+    }
+
+    bool computeCodeUnitFlags(char utf8[],
+                              int utf8Units,
+                              bool replaceTabs,
+                              skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+        this->markLineBreaks(utf8, utf8Units, /*hardLineBreaks=*/false, results);
+        this->markHardLineBreaksHack(utf8, utf8Units, results);
+        this->markGraphemes(utf8, utf8Units, results);
+        this->markCharacters(utf8, utf8Units, replaceTabs, results);
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        SkASSERT(false);
+        return true;
+    }
+
+    bool getWords(const char utf8[],
+                  int utf8Units,
+                  const char* locale,
+                  std::vector<Position>* results) override {
+        auto utf16 = SkUnicode::convertUtf8ToUtf16(utf8, utf8Units);
+        const diplomat::span<const uint16_t> span((uint16_t*)utf16.data(), utf16.size());
+        const auto segmenter = ICU4XWordSegmenter::create_dictionary(fDataProvider).ok().value();
+        auto iterator = segmenter.segment_utf16(span);
+        while (true) {
+            int32_t breakpoint = iterator.next();
+            if (breakpoint == -1) {
+                break;
+            }
+            results->emplace_back(breakpoint);
+        }
+        return true;
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return toUpper(str, "und");
+    }
+
+    SkString toUpper(const SkString& str, const char* localeStr) override {
+        auto locale = ICU4XLocale::create_from_string(localeStr).ok().value();
+        std::string std_string(str.data(), str.size());
+        // TODO: upper case
+        auto result = fCaseMapper.uppercase(std_string, locale).ok().value();
+        return SkString(result.data(), result.size());
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+
+        const auto bidi = ICU4XBidi::create(fDataProvider).ok().value();
+        const diplomat::span<const uint8_t> levels(&runLevels[0], levelsCount);
+        auto map = bidi.reorder_visual(levels);
+        SkASSERT(levelsCount == map.len());
+        std::vector<int32_t> results;
+        for (size_t i = 0; i < map.len(); i++) {
+            auto level = map.get(i);
+            logicalFromVisual[i] = SkToS32(level);
+        }
+    }
+
+private:
+    friend class SkBreakIterator_icu4x;
+    friend class SkBidiIterator_icu4x;
+
+    bool markHardLineBreaksHack(char utf8[],
+                                int utf8Units,
+                                skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        const char* end = utf8 + utf8Units;
+        const char* ch = utf8;
+        while (ch < end) {
+            auto unichar = SkUTF::NextUTF8(&ch, end);
+            if (this->isHardBreak(unichar)) {
+                (*results)[ch - utf8] |= CodeUnitFlags::kHardLineBreakBefore;
+            }
+        }
+        return true;
+    }
+
+    SkUnichar getChar32(const char* pointer, const char* end) {
+        if (pointer < end) {
+            return SkUTF::NextUTF8(&pointer, end);
+        }
+        return -1;
+    }
+
+    bool markLineBreaks(char utf8[],
+                        int utf8Units,
+                        bool hardLineBreaks,
+                        skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        if (utf8Units == 0) {
+            return true;
+        }
+        // TODO: Remove hard line break hack and detect it here
+        SkASSERT(!hardLineBreaks);
+        const auto lineBreakingOptions = hardLineBreaks
+                                              ? ICU4XLineBreakOptionsV1{ICU4XLineBreakStrictness::Strict, ICU4XLineBreakWordOption::Normal}
+                                              : ICU4XLineBreakOptionsV1{ICU4XLineBreakStrictness::Loose, ICU4XLineBreakWordOption::Normal};
+        const auto segmenter = ICU4XLineSegmenter::create_auto_with_options_v1(fDataProvider, lineBreakingOptions).ok().value();
+        std::string_view string_view(utf8, utf8Units);
+        auto iterator = segmenter.segment_utf8(string_view);
+
+        while (true) {
+            int32_t lineBreak = iterator.next();
+            if (lineBreak == -1) {
+                break;
+            }
+            if (hardLineBreaks) {
+                (*results)[lineBreak] |= CodeUnitFlags::kHardLineBreakBefore;
+            } else {
+                (*results)[lineBreak] |= CodeUnitFlags::kSoftLineBreakBefore;
+            }
+        }
+        if (!hardLineBreaks) {
+            (*results)[0] |= CodeUnitFlags::kSoftLineBreakBefore;
+            (*results)[utf8Units] |= CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        return true;
+    }
+
+    bool markGraphemes(const char utf8[],
+                       int utf8Units,
+                       skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        const auto segmenter = ICU4XGraphemeClusterSegmenter::create(fDataProvider).ok().value();
+        std::string_view string_view(utf8, utf8Units);
+        auto iterator = segmenter.segment_utf8(string_view);
+        while (true) {
+            int32_t graphemeStart = iterator.next();
+            if (graphemeStart == -1) {
+                break;
+            }
+            (*results)[graphemeStart] |= CodeUnitFlags::kGraphemeStart;
+        }
+        return true;
+    }
+
+    bool markCharacters(char utf8[],
+                        int utf8Units,
+                        bool replaceTabs,
+                        skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) {
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && SkUnicode_icu4x::isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                bool isHardBreak = this->isHardBreak(unichar);
+                bool isSpace = this->isSpace(unichar) || isHardBreak;
+                bool isWhitespace = this->isWhitespace(unichar) || isHardBreak;
+                if (isSpace) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (isWhitespace) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        SkDEBUGF("Method 'getUtf8Words' is not implemented\n");
+        return false;
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkDEBUGF("Method 'getSentences' is not implemented\n");
+        return false;
+    }
+
+    std::shared_ptr<std::vector<SkUnicode::BidiRegion>> fRegions;
+    ICU4XLocale fLocale;
+    ICU4XDataProvider fDataProvider;
+    ICU4XCaseMapper fCaseMapper;
+    ICU4XCodePointSetData fWhitespaces;
+    ICU4XCodePointSetData fSpaces;
+    ICU4XCodePointSetData fBlanks;
+    ICU4XCodePointSetData fEmoji;
+    ICU4XCodePointSetData fEmojiComponent;
+    ICU4XCodePointSetData fEmojiModifier;
+    ICU4XCodePointSetData fEmojiModifierBase;
+    ICU4XCodePointSetData fRegionalIndicator;
+    ICU4XCodePointSetData fIdeographic;
+    ICU4XCodePointSetData fControls;
+    ICU4XCodePointMapData8 fLineBreaks;
+};
+
+class SkBreakIterator_icu4x: public SkBreakIterator {
+    Position fLastResult;
+    Position fStart;
+    Position fEnd;
+public:
+    SkBreakIterator_icu4x() { }
+    Position first() override { SkASSERT(false); return -1; }
+    Position current() override { SkASSERT(false); return -1; }
+    Position next() override { SkASSERT(false); return -1; }
+    Status status() override { SkASSERT(false); return -1; }
+    bool isDone() override { SkASSERT(false); return false; }
+    bool setText(const char utftext8[], int utf8Units) override { SkASSERT(false); return false; }
+    bool setText(const char16_t utftext16[], int utf16Units) override { SkASSERT(false); return false; }
+};
+
+class SkBidiIterator_icu4x : public SkBidiIterator {
+    std::shared_ptr<std::vector<SkUnicode::BidiRegion>> fRegions;
+public:
+    explicit SkBidiIterator_icu4x(std::shared_ptr<std::vector<SkUnicode::BidiRegion>> regions)
+            : fRegions(regions) { }
+    Position getLength() override { return fRegions->size(); }
+    Level getLevelAt(Position pos) override {
+        auto found = std::lower_bound(
+                fRegions->begin(),
+                fRegions->end(),
+                SkUnicode::BidiRegion(pos, pos, 0),
+                [](const SkUnicode::BidiRegion& a, const SkUnicode::BidiRegion& b) {
+                    return a.start <= b.start && a.end <= b.end;
+                });
+        return found->level;
+    }
+};
+
+std::unique_ptr<SkBidiIterator> SkUnicode_icu4x::makeBidiIterator(const uint16_t text[], int count,
+                                                 SkBidiIterator::Direction dir) {
+    if (fRegions) {
+        fRegions->clear();
+    } else {
+        fRegions = std::make_shared<std::vector<SkUnicode::BidiRegion>>();
+    }
+
+    if (this->getBidiRegions(text, count, dir == SkBidiIterator::Direction::kLTR ? TextDirection::kLTR : TextDirection::kRTL, fRegions.get())) {
+        return std::make_unique<SkBidiIterator_icu4x>(fRegions);
+    } else {
+        return nullptr;
+    }
+}
+
+std::unique_ptr<SkBidiIterator> SkUnicode_icu4x::makeBidiIterator(const char text[],
+                                                 int count,
+                                                 SkBidiIterator::Direction dir) {
+    if (fRegions) {
+        fRegions->clear();
+    } else {
+        fRegions = std::make_shared<std::vector<SkUnicode::BidiRegion>>();
+    }
+    if (this->getBidiRegions(text, count, dir == SkBidiIterator::Direction::kLTR ? TextDirection::kLTR : TextDirection::kRTL, fRegions.get())) {
+        return std::make_unique<SkBidiIterator_icu4x>(fRegions);
+    } else {
+        return nullptr;
+    }
+}
+
+std::unique_ptr<SkBreakIterator> SkUnicode_icu4x::makeBreakIterator(const char locale[],
+                                                   BreakType breakType) {
+    SkASSERT(false); return nullptr;
+}
+
+std::unique_ptr<SkBreakIterator> SkUnicode_icu4x::makeBreakIterator(BreakType breakType) {
+    SkASSERT(false); return nullptr;
+}
+
+namespace SkUnicodes::ICU4X {
+sk_sp<SkUnicode> Make() {
+    return sk_make_sp<SkUnicode_icu4x>();
+}
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp
new file mode 100644
index 00000000..f38c0811
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.cpp
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2022 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkDebug.h"
+#include "include/private/base/SkTFitsIn.h"
+#include "src/base/SkUTF.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <utility>
+#include <vector>
+
+namespace {
+using SkUnicodeBidi = std::unique_ptr<UBiDi, SkBidiFactory::BidiCloseCallback>;
+
+class SkBidiIterator_icu : public SkBidiIterator {
+public:
+    SkBidiIterator_icu(SkUnicodeBidi bidi, sk_sp<SkBidiFactory> fact)
+            : fBidi(std::move(bidi)), fBidiFact(std::move(fact)) {}
+
+    Position getLength() override { return fBidiFact->bidi_getLength(fBidi.get()); }
+
+    Level getLevelAt(Position pos) override { return fBidiFact->bidi_getLevelAt(fBidi.get(), pos); }
+
+private:
+    SkUnicodeBidi fBidi;
+    sk_sp<SkBidiFactory> fBidiFact;
+};
+}  // namespace
+
+std::unique_ptr<SkBidiIterator> SkBidiFactory::MakeIterator(const uint16_t utf16[],
+                                                            int utf16Units,
+                                                            SkBidiIterator::Direction dir) const {
+    UErrorCode status = U_ZERO_ERROR;
+    SkUnicodeBidi bidi(this->bidi_openSized(utf16Units, 0, &status), this->bidi_close_callback());
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return nullptr;
+    }
+    SkASSERT(bidi);
+    uint8_t bidiLevel = (dir == SkBidiIterator::kLTR) ? UBIDI_LTR : UBIDI_RTL;
+    // The required lifetime of utf16 isn't well documented.
+    // It appears it isn't used after ubidi_setPara except through ubidi_getText.
+    this->bidi_setPara(bidi.get(), (const UChar*)utf16, utf16Units, bidiLevel, nullptr, &status);
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return nullptr;
+    }
+    return std::unique_ptr<SkBidiIterator>(
+            new SkBidiIterator_icu(std::move(bidi), sk_ref_sp(this)));
+}
+
+std::unique_ptr<SkBidiIterator> SkBidiFactory::MakeIterator(const char utf8[],
+                                                            int utf8Units,
+                                                            SkBidiIterator::Direction dir) const {
+    // Convert utf8 into utf16 since ubidi only accepts utf16
+    if (!SkTFitsIn<int32_t>(utf8Units)) {
+        SkDEBUGF("Bidi error: text too long");
+        return nullptr;
+    }
+
+    // Getting the length like this seems to always set U_BUFFER_OVERFLOW_ERROR
+    int utf16Units = SkUTF::UTF8ToUTF16(nullptr, 0, utf8, utf8Units);
+    if (utf16Units < 0) {
+        SkDEBUGF("Bidi error: Invalid utf8 input");
+        return nullptr;
+    }
+    std::unique_ptr<uint16_t[]> utf16(new uint16_t[utf16Units]);
+    SkDEBUGCODE(int dstLen =) SkUTF::UTF8ToUTF16(utf16.get(), utf16Units, utf8, utf8Units);
+    SkASSERT(dstLen == utf16Units);
+
+    return MakeIterator(utf16.get(), utf16Units, dir);
+}
+
+/** Replaces invalid utf-8 sequences with REPLACEMENT CHARACTER U+FFFD. */
+static inline SkUnichar utf8_next(const char** ptr, const char* end) {
+    SkUnichar val = SkUTF::NextUTF8(ptr, end);
+    return val < 0 ? 0xFFFD : val;
+}
+
+bool SkBidiFactory::ExtractBidi(const char utf8[],
+                                int utf8Units,
+                                SkUnicode::TextDirection dir,
+                                std::vector<SkUnicode::BidiRegion>* bidiRegions) const {
+    // Convert to UTF16 since for now bidi iterator only operates on utf16
+    auto utf16 = SkUnicode::convertUtf8ToUtf16(utf8, utf8Units);
+
+    // Create bidi iterator
+    UErrorCode status = U_ZERO_ERROR;
+    SkUnicodeBidi bidi(this->bidi_openSized(utf16.size(), 0, &status), this->bidi_close_callback());
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return false;
+    }
+    SkASSERT(bidi);
+    uint8_t bidiLevel = (dir == SkUnicode::TextDirection::kLTR) ? UBIDI_LTR : UBIDI_RTL;
+    // The required lifetime of utf16 isn't well documented.
+    // It appears it isn't used after ubidi_setPara except through ubidi_getText.
+    this->bidi_setPara(
+            bidi.get(), (const UChar*)utf16.c_str(), utf16.size(), bidiLevel, nullptr, &status);
+    if (U_FAILURE(status)) {
+        SkDEBUGF("Bidi error: %s", this->errorName(status));
+        return false;
+    }
+
+    // Iterate through bidi regions and the result positions into utf8
+    const char* start8 = utf8;
+    const char* end8 = utf8 + utf8Units;
+    SkUnicode::BidiLevel currentLevel = 0;
+
+    SkUnicode::Position pos8 = 0;
+    SkUnicode::Position pos16 = 0;
+    SkUnicode::Position end16 = this->bidi_getLength(bidi.get());
+
+    if (end16 == 0) {
+        return true;
+    }
+    if (this->bidi_getDirection(bidi.get()) != UBIDI_MIXED) {
+        // The entire paragraph is unidirectional.
+        bidiRegions->emplace_back(0, utf8Units, this->bidi_getLevelAt(bidi.get(), 0));
+        return true;
+    }
+
+    while (pos16 < end16) {
+        auto level = this->bidi_getLevelAt(bidi.get(), pos16);
+        if (pos16 == 0) {
+            currentLevel = level;
+        } else if (level != currentLevel) {
+            SkUnicode::Position end = start8 - utf8;
+            bidiRegions->emplace_back(pos8, end, currentLevel);
+            currentLevel = level;
+            pos8 = end;
+        }
+        SkUnichar u = utf8_next(&start8, end8);
+        pos16 += SkUTF::ToUTF16(u);
+    }
+    SkUnicode::Position end = start8 - utf8;
+    if (end != pos8) {
+        bidiRegions->emplace_back(pos8, end, currentLevel);
+    }
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h
new file mode 100644
index 00000000..a9e1f4be
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_bidi.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2023 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_icu_bidi_DEFINED
+#define SkUnicode_icu_bidi_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/skunicode/include/SkUnicode.h"
+
+#include <unicode/ubidi.h>
+#include <unicode/umachine.h>
+#include <unicode/utypes.h>
+#include <cstdint>
+#include <memory>
+#include <vector>
+
+// Some versions of SkUnicode need a small subset of ICU to do bidi things. This
+// allows us to have the same API for the subset as well as the full ICU.
+class SkBidiFactory : public SkRefCnt {
+public:
+    std::unique_ptr<SkBidiIterator> MakeIterator(const uint16_t utf16[],
+                                                 int utf16Units,
+                                                 SkBidiIterator::Direction dir) const;
+    std::unique_ptr<SkBidiIterator> MakeIterator(const char utf8[],
+                                                 int utf8Units,
+                                                 SkBidiIterator::Direction dir) const;
+    bool ExtractBidi(const char utf8[],
+                     int utf8Units,
+                     SkUnicode::TextDirection dir,
+                     std::vector<SkUnicode::BidiRegion>* bidiRegions) const;
+
+    virtual const char* errorName(UErrorCode status) const = 0;
+
+using BidiCloseCallback = void(*)(UBiDi* bidi);
+    virtual BidiCloseCallback bidi_close_callback() const = 0;
+    virtual UBiDiDirection bidi_getDirection(const UBiDi* bidi) const = 0;
+    virtual SkBidiIterator::Position bidi_getLength(const UBiDi* bidi) const = 0;
+    virtual SkBidiIterator::Level bidi_getLevelAt(const UBiDi* bidi, int pos) const = 0;
+    virtual UBiDi* bidi_openSized(int32_t maxLength,
+                                  int32_t maxRunCount,
+                                  UErrorCode* pErrorCode) const = 0;
+    virtual void bidi_setPara(UBiDi* bidi,
+                              const UChar* text,
+                              int32_t length,
+                              UBiDiLevel paraLevel,
+                              UBiDiLevel* embeddingLevels,
+                              UErrorCode* status) const = 0;
+    virtual void bidi_reorderVisual(const SkUnicode::BidiLevel runLevels[],
+                                    int levelsCount,
+                                    int32_t logicalFromVisual[]) const = 0;
+};
+
+#endif // SkUnicode_icu_bidi_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp
new file mode 100644
index 00000000..e861243d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_builtin.cpp
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/private/base/SkFeatures.h"  // IWYU pragma: keep
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+
+#include <memory>
+#include <type_traits>
+#include <utility>
+
+#include <unicode/ubrk.h>
+#include <unicode/uloc.h>
+#include <unicode/utypes.h>
+
+namespace {
+
+// ubrk_clone added as draft in ICU69 and Android API 31 (first ICU NDK).
+// ubrk_safeClone deprecated in ICU69 and not exposed by Android.
+template<typename T, typename = void>
+struct SkUbrkClone {
+    static UBreakIterator* clone(T bi, UErrorCode* status) {
+        return ubrk_safeClone(bi, nullptr, nullptr, status);
+    }
+};
+template<typename T>
+struct SkUbrkClone<T, std::void_t<decltype(ubrk_clone(std::declval<T>(), nullptr))>> {
+    static UBreakIterator* clone(T bi, UErrorCode* status) {
+        return ubrk_clone(bi, status);
+    }
+};
+
+// ubrk_getLocaleByType has been in ICU since version 2.8
+// However, it was not included in the Android NDK
+template<typename T, typename = void>
+struct SkUbrkGetLocaleByType {
+    static const char* getLocaleByType(T bi, ULocDataLocaleType type, UErrorCode* status) {
+        *status = U_UNSUPPORTED_ERROR;
+        return nullptr;
+    }
+};
+template<typename T>
+struct SkUbrkGetLocaleByType<
+    T,
+    std::void_t<decltype(ubrk_getLocaleByType(std::declval<T>(),
+                                              std::declval<ULocDataLocaleType>(),
+                                              nullptr))>>
+{
+    static const char* getLocaleByType(T bi, ULocDataLocaleType type, UErrorCode* status) {
+        return ubrk_getLocaleByType(bi, type, status);
+    }
+};
+
+}  // namespace
+
+#define SKICU_FUNC(funcname) funcname,
+std::unique_ptr<SkICULib> SkLoadICULib() {
+    return std::make_unique<SkICULib>(SkICULib{
+        SKICU_EMIT_FUNCS
+        &SkUbrkClone<const UBreakIterator*>::clone,
+        nullptr,
+        &SkUbrkGetLocaleByType<const UBreakIterator*>::getLocaleByType,
+    });
+}
+
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp
new file mode 100644
index 00000000..90eacec1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icu_runtime.cpp
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "modules/skunicode/src/SkUnicode_icupriv.h"
+
+#include <dlfcn.h>
+
+#define SK_RUNTIME_ICU_PATHS "libicuuc.so"
+
+std::unique_ptr<SkICULib> SkLoadICULib() {
+    static constexpr char const* gLibPaths[] = { SK_RUNTIME_ICU_PATHS };
+
+    void* dlhnd = nullptr;
+    for (const auto path : gLibPaths) {
+        dlhnd = dlopen(path, RTLD_LAZY);
+        if (dlhnd) {
+            break;
+        }
+    }
+
+    if (!dlhnd) {
+        SkDEBUGF("ICU loader: failed to open libicuuc.\n");
+        return nullptr;
+    }
+
+    int icu_ver = -1;
+
+    bool resolved_required_syms = true;
+
+    auto resolve_sym = [&](void* hnd, const char name[], bool required = false) -> void* {
+        static constexpr int kMinVer =  44,
+                             kMaxVer = 100;
+
+        // First call performs a search to determine the actual lib version.
+        // Subsequent calls are pinned to the version found.
+        const auto search_to = icu_ver > 0 ? icu_ver : kMaxVer;
+        icu_ver              = icu_ver > 0 ? icu_ver : kMinVer;
+
+        for (;;) {
+            const auto sym = SkStringPrintf("%s_%d", name, icu_ver);
+            if (auto* addr = dlsym(dlhnd, sym.c_str())) {
+                return addr;
+            }
+
+            if (icu_ver == search_to) {
+                break;
+            }
+
+            icu_ver++;
+        }
+
+        if (required) {
+            resolved_required_syms = false;
+        }
+        return nullptr;
+    };
+
+    SkICULib lib {};
+
+    // When using dlsym
+    // *(void**)(&procPtr) = dlsym(self, "proc");
+    // is non-standard, but safe for POSIX. Cannot write
+    // *reinterpret_cast<void**>(&procPtr) = dlsym(self, "proc");
+    // because clang has not implemented DR573. See http://clang.llvm.org/cxx_dr_status.html .
+    #define SKICU_FUNC(fname) *(void**)(&lib.f_##fname) = resolve_sym(dlhnd, #fname, true);
+    SKICU_EMIT_FUNCS
+
+    *(void**)(&lib.f_ubrk_clone_)     = resolve_sym(dlhnd, "ubrk_clone");
+    *(void**)(&lib.f_ubrk_safeClone_) = resolve_sym(dlhnd, "ubrk_safeClone");
+    *(void**)(&lib.f_ubrk_getLocaleByType) = resolve_sym(dlhnd, "ubrk_getLocaleByType");
+
+    if (!resolved_required_syms || (!lib.f_ubrk_clone_ && !lib.f_ubrk_safeClone_)) {
+        SkDEBUGF("ICU loader: failed to resolve required symbols.");
+        dlclose(dlhnd);
+        return nullptr;
+    }
+
+    return std::make_unique<SkICULib>(lib);
+}
+
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h
new file mode 100644
index 00000000..4f663817
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_icupriv.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#ifndef SkUnicode_icupriv_DEFINED
+#define SkUnicode_icupriv_DEFINED
+
+#include <unicode/ubidi.h>
+#include <unicode/ubrk.h>
+#include <unicode/uchar.h>
+#include <unicode/uloc.h>
+#include <unicode/uscript.h>
+#include <unicode/ustring.h>
+#include <unicode/utext.h>
+#include <unicode/utypes.h>
+#include <cstdint>
+#include <memory>
+
+#define SKICU_EMIT_FUNCS              \
+    SKICU_FUNC(u_errorName)           \
+    SKICU_FUNC(u_hasBinaryProperty)   \
+    SKICU_FUNC(u_getIntPropertyValue) \
+    SKICU_FUNC(u_iscntrl)             \
+    SKICU_FUNC(u_isspace)             \
+    SKICU_FUNC(u_isWhitespace)        \
+    SKICU_FUNC(u_strToUpper)          \
+    SKICU_FUNC(ubidi_close)           \
+    SKICU_FUNC(ubidi_getDirection)    \
+    SKICU_FUNC(ubidi_getLength)       \
+    SKICU_FUNC(ubidi_getLevelAt)      \
+    SKICU_FUNC(ubidi_openSized)       \
+    SKICU_FUNC(ubidi_reorderVisual)   \
+    SKICU_FUNC(ubidi_setPara)         \
+    SKICU_FUNC(ubrk_close)            \
+    SKICU_FUNC(ubrk_current)          \
+    SKICU_FUNC(ubrk_first)            \
+    SKICU_FUNC(ubrk_following)        \
+    SKICU_FUNC(ubrk_getRuleStatus)    \
+    SKICU_FUNC(ubrk_next)             \
+    SKICU_FUNC(ubrk_open)             \
+    SKICU_FUNC(ubrk_preceding)        \
+    SKICU_FUNC(ubrk_setText)          \
+    SKICU_FUNC(ubrk_setUText)         \
+    SKICU_FUNC(uloc_forLanguageTag)   \
+    SKICU_FUNC(uloc_getDefault)       \
+    SKICU_FUNC(uscript_getScript)     \
+    SKICU_FUNC(utext_close)           \
+    SKICU_FUNC(utext_openUChars)      \
+    SKICU_FUNC(utext_openUTF8)        \
+
+#define SKICU_FUNC(funcname) decltype(funcname)* f_##funcname;
+struct SkICULib {
+    SKICU_EMIT_FUNCS
+
+    // ubrk_clone added as draft in ICU69 and Android API 31 (first ICU NDK).
+    // ubrk_safeClone deprecated in ICU69 and not exposed by Android.
+    UBreakIterator* (*f_ubrk_clone_)(const UBreakIterator*, UErrorCode*);
+    UBreakIterator* (*f_ubrk_safeClone_)(const UBreakIterator*, void*, int32_t*, UErrorCode*);
+
+    // ubrk_getLocaleByType not exposed by Android.
+    const char* (*f_ubrk_getLocaleByType)(const UBreakIterator*, ULocDataLocaleType, UErrorCode*);
+};
+#undef SKICU_FUNC
+
+// Platform/config specific ICU factory.
+std::unique_ptr<SkICULib> SkLoadICULib();
+
+// Get cached already loaded ICU library.
+const SkICULib* SkGetICULib();
+
+#endif // SkUnicode_icupriv_DEFINED
diff --git a/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp
new file mode 100644
index 00000000..5c9f168e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/src/SkUnicode_libgrapheme.cpp
@@ -0,0 +1,303 @@
+/*
+* Copyright 2022 Google Inc.
+*
+* Use of this source code is governed by a BSD-style license that can be
+* found in the LICENSE file.
+*/
+
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkTArray.h"
+#include "modules/skunicode/include/SkUnicode.h"
+#include "modules/skunicode/src/SkBidiFactory_icu_subset.h"
+#include "modules/skunicode/src/SkUnicode_hardcoded.h"
+#include "modules/skunicode/src/SkUnicode_icu_bidi.h"
+#include "src/base/SkBitmaskEnum.h"
+
+extern "C" {
+#include <grapheme.h>
+}
+#include <array>
+#include <memory>
+#include <vector>
+#include <unordered_map>
+
+using namespace skia_private;
+
+class SkUnicode_libgrapheme : public SkUnicodeHardCodedCharProperties {
+public:
+    SkUnicode_libgrapheme() { }
+
+    ~SkUnicode_libgrapheme() override = default;
+
+    // For SkShaper
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const uint16_t text[], int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBidiIterator> makeBidiIterator(const char text[],
+                                                     int count,
+                                                     SkBidiIterator::Direction dir) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(const char locale[],
+                                                       BreakType breakType) override;
+    std::unique_ptr<SkBreakIterator> makeBreakIterator(BreakType breakType) override;
+    bool getBidiRegions(const char utf8[],
+                        int utf8Units,
+                        TextDirection dir,
+                        std::vector<BidiRegion>* results) override {
+        return fBidiFact->ExtractBidi(utf8, utf8Units, dir, results);
+    }
+
+    bool getSentences(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<SkUnicode::Position>* results) override {
+        SkDEBUGF("Method 'getSentences' is not implemented\n");
+        return false;
+    }
+
+    bool computeCodeUnitFlags(char utf8[],
+                              int utf8Units,
+                              bool replaceTabs,
+                              skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        results->clear();
+        results->push_back_n(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        size_t lineBreak = 0;
+        (*results)[lineBreak] |= CodeUnitFlags::kSoftLineBreakBefore;
+        while (lineBreak < utf8Units) {
+            lineBreak += grapheme_next_line_break_utf8(utf8 + lineBreak, utf8Units - lineBreak);
+            // Check if the previous code unit is a hard break.
+            auto codePoint = utf8[lineBreak - 1];
+            (*results)[lineBreak] |= this->isHardBreak(codePoint)
+                                    ? CodeUnitFlags::kHardLineBreakBefore
+                                    : CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        (*results)[utf8Units] |= CodeUnitFlags::kSoftLineBreakBefore;
+
+        size_t graphemeBreak = 0;
+        (*results)[graphemeBreak] |= CodeUnitFlags::kGraphemeStart;
+        while (graphemeBreak < utf8Units) {
+            graphemeBreak += grapheme_next_character_break_utf8(utf8 + graphemeBreak, utf8Units - graphemeBreak);
+            (*results)[graphemeBreak] |= CodeUnitFlags::kGraphemeStart;
+        }
+
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto before = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (unichar < 0) unichar = 0xFFFD;
+            auto after = current - utf8;
+            if (replaceTabs && this->isTabulation(unichar)) {
+                results->at(before) |= SkUnicode::kTabulation;
+                if (replaceTabs) {
+                    unichar = ' ';
+                    utf8[before] = ' ';
+                }
+            }
+            for (auto i = before; i < after; ++i) {
+                if (this->isSpace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfIntraWordBreak;
+                }
+                if (this->isWhitespace(unichar)) {
+                    results->at(i) |= SkUnicode::kPartOfWhiteSpaceBreak;
+                }
+                if (this->isControl(unichar)) {
+                    results->at(i) |= SkUnicode::kControl;
+                }
+            }
+        }
+        return true;
+    }
+
+    bool computeCodeUnitFlags(char16_t utf16[], int utf16Units, bool replaceTabs,
+                          skia_private::TArray<SkUnicode::CodeUnitFlags, true>* results) override {
+        SkASSERT(false);
+        return false;
+    }
+
+    bool getUtf8To16Mapping(const char utf8[], int utf8Units, std::unordered_map<Position, Position>* results) {
+        int utf16Units = 0;
+        const char* ptr8 = utf8;
+        const char* end8 = utf8 + utf8Units;
+        while (ptr8 < end8) {
+            results->emplace(ptr8 - utf8, utf16Units);
+            SkUnichar uni = SkUTF::NextUTF8(&ptr8, end8);
+            if (uni < 0) {
+                return false;
+            }
+
+            uint16_t utf16[2];
+            size_t count = SkUTF::ToUTF16(uni, utf16);
+            if (count == 0) {
+                return false;
+            }
+            utf16Units += count;
+        }
+        results->emplace(utf8Units, utf16Units);
+        return true;
+    }
+
+    bool getWords(const char utf8[], int utf8Units, const char* locale, std::vector<Position>* results) override {
+        std::unordered_map<Position, Position> mapping;
+        if (!getUtf8To16Mapping(utf8, utf8Units, &mapping)) {
+            return false;
+        }
+        size_t wordBreak = 0;
+        while (wordBreak < utf8Units) {
+            wordBreak += grapheme_next_word_break_utf8(utf8 + wordBreak, utf8Units - wordBreak);
+            if (mapping.find(wordBreak) == mapping.end()) {
+                return false;
+            }
+            results->emplace_back(mapping[wordBreak]);
+        }
+        return true;
+    }
+
+    bool getUtf8Words(const char utf8[],
+                      int utf8Units,
+                      const char* locale,
+                      std::vector<Position>* results) override {
+        // Let's consider sort line breaks, whitespaces and CJK codepoints instead
+        std::vector<CodeUnitFlags> breaks(utf8Units + 1, CodeUnitFlags::kNoCodeUnitFlag);
+
+        size_t lineBreak = 0;
+        breaks[lineBreak] = CodeUnitFlags::kSoftLineBreakBefore;
+        while (lineBreak < utf8Units) {
+            lineBreak += grapheme_next_line_break_utf8(utf8 + lineBreak, utf8Units - lineBreak);
+            breaks[lineBreak] = CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        breaks[lineBreak] = CodeUnitFlags::kSoftLineBreakBefore;
+
+        const char* current = utf8;
+        const char* end = utf8 + utf8Units;
+        while (current < end) {
+            auto index = current - utf8;
+            SkUnichar unichar = SkUTF::NextUTF8(&current, end);
+            if (this->isWhitespace(unichar)) {
+                breaks[index] = CodeUnitFlags::kPartOfWhiteSpaceBreak;
+            } else if (this->isIdeographic(unichar)) {
+                breaks[index] = CodeUnitFlags::kIdeographic;
+            }
+        }
+
+        bool whitespaces = false;
+        for (size_t i = 0; i < breaks.size(); ++i) {
+            auto b = breaks[i];
+            if (b == CodeUnitFlags::kSoftLineBreakBefore) {
+                results->emplace_back(i);
+                whitespaces = false;
+            } else if (b == CodeUnitFlags::kIdeographic) {
+                results->emplace_back(i);
+                whitespaces = false;
+            } else if (b == CodeUnitFlags::kPartOfWhiteSpaceBreak) {
+                if (!whitespaces) {
+                    results->emplace_back(i);
+                }
+                whitespaces = true;
+            } else {
+                whitespaces = false;
+            }
+        }
+
+        return true;
+
+        /*
+        size_t wordBreak = 0;
+        while (wordBreak < utf8Units) {
+            wordBreak += grapheme_next_word_break_utf8(utf8 + wordBreak, utf8Units - wordBreak);
+            results->emplace_back(wordBreak);
+        }
+        return true;
+        */
+    }
+
+    SkString toUpper(const SkString& str) override {
+        return this->toUpper(str, nullptr);
+    }
+
+    SkString toUpper(const SkString& str, const char* locale) override {
+        SkString res(" ", str.size());
+        grapheme_to_uppercase_utf8(str.data(), str.size(), res.data(), res.size());
+        return res;
+    }
+
+    void reorderVisual(const BidiLevel runLevels[],
+                       int levelsCount,
+                       int32_t logicalFromVisual[]) override {
+        fBidiFact->bidi_reorderVisual(runLevels, levelsCount, logicalFromVisual);
+    }
+private:
+    friend class SkBreakIterator_libgrapheme;
+
+    sk_sp<SkBidiFactory> fBidiFact = sk_make_sp<SkBidiSubsetFactory>();
+};
+
+class SkBreakIterator_libgrapheme: public SkBreakIterator {
+    SkUnicode_libgrapheme* fUnicode;
+    std::vector<SkUnicode::LineBreakBefore> fLineBreaks;
+    Position fLineBreakIndex;
+    static constexpr const int kDone = -1;
+public:
+    explicit SkBreakIterator_libgrapheme(SkUnicode_libgrapheme* unicode) : fUnicode(unicode) { }
+    Position first() override
+      { return fLineBreaks[(fLineBreakIndex = 0)].pos; }
+    Position current() override
+      { return fLineBreaks[fLineBreakIndex].pos; }
+    Position next() override
+      { return fLineBreaks[++fLineBreakIndex].pos; }
+    Status status() override {
+        return fLineBreaks[fLineBreakIndex].breakType ==
+                       SkUnicode::LineBreakType::kHardLineBreak
+                       ? SkUnicode::CodeUnitFlags::kHardLineBreakBefore
+                       : SkUnicode::CodeUnitFlags::kSoftLineBreakBefore;
+    }
+    bool isDone() override { return fLineBreaks[fLineBreakIndex].pos == kDone; }
+    bool setText(const char utftext8[], int utf8Units) override {
+        fLineBreaks.clear();
+        size_t lineBreak = 0;
+        // first() must always go to the beginning of the string.
+        fLineBreaks.emplace_back(0, SkUnicode::LineBreakType::kHardLineBreak);
+        for (size_t pos = 0; pos < utf8Units;) {
+            pos += grapheme_next_line_break_utf8(utftext8 + pos, utf8Units - pos);
+            auto codePoint = utftext8[pos];
+            fLineBreaks.emplace_back(pos,
+                                     fUnicode->isHardBreak(codePoint)
+                                    ? SkUnicode::LineBreakType::kHardLineBreak
+                                    : SkUnicode::LineBreakType::kSoftLineBreak);
+        }
+        // There is always an "end" which signals "done".
+        fLineBreaks.emplace_back(kDone, SkUnicode::LineBreakType::kHardLineBreak);
+        fLineBreakIndex = 0;
+        return true;
+    }
+    bool setText(const char16_t utftext16[], int utf16Units) override {
+        SkASSERT(false);
+        return false;
+    }
+};
+
+std::unique_ptr<SkBidiIterator> SkUnicode_libgrapheme::makeBidiIterator(const uint16_t text[], int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBidiIterator> SkUnicode_libgrapheme::makeBidiIterator(const char text[],
+                                                 int count,
+                                                 SkBidiIterator::Direction dir) {
+    return fBidiFact->MakeIterator(text, count, dir);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_libgrapheme::makeBreakIterator(const char locale[],
+                                                   BreakType breakType) {
+    return std::make_unique<SkBreakIterator_libgrapheme>(this);
+}
+std::unique_ptr<SkBreakIterator> SkUnicode_libgrapheme::makeBreakIterator(BreakType breakType) {
+    return std::make_unique<SkBreakIterator_libgrapheme>(this);
+}
+
+namespace SkUnicodes::Libgrapheme {
+sk_sp<SkUnicode> Make() {
+    return sk_make_sp<SkUnicode_libgrapheme>();
+}
+}
diff --git a/Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel b/Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel
new file mode 100644
index 00000000..8cb44871
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/tests/BUILD.bazel
@@ -0,0 +1,12 @@
+load("//bazel:macros.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_filegroup(
+    name = "tests",
+    srcs = ["SkUnicodeTest.cpp"],
+)
diff --git a/Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp b/Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp
new file mode 100644
index 00000000..500ebee6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/skunicode/tests/SkUnicodeTest.cpp
@@ -0,0 +1,368 @@
+
+/*
+ * Copyright 2023 Google LLC
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "include/core/SkSpan.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypeface.h"
+#include "src/base/SkBitmaskEnum.h"
+#include "tests/Test.h"
+
+#include "modules/skunicode/include/SkUnicode.h"
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu.h"
+#endif
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_libgrapheme.h"
+#endif
+#if defined(SK_UNICODE_ICU4X_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_icu4x.h"
+#endif
+#if defined(SK_UNICODE_CLIENT_IMPLEMENTATION)
+#include "modules/skunicode/include/SkUnicode_client.h"
+#endif
+
+#include <vector>
+
+#ifdef SK_UNICODE_ICU_IMPLEMENTATION
+#define DEF_TEST_ICU(name, reporter) \
+    DEF_TEST(name##ICU, reporter) { name(reporter, SkUnicodes::ICU::Make()); }
+#else
+#define DEF_TEST_ICU(name, reporter)
+#endif
+
+#ifdef SK_UNICODE_ICU4X_IMPLEMENTATION
+#define DEF_TEST_ICU4X(name, reporter) \
+    DEF_TEST(name##ICU4X, reporter) { name(reporter, SkUnicodes::ICU4X::Make()); }
+#else
+#define DEF_TEST_ICU4X(name, reporter)
+#endif
+
+#ifdef SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION
+#define DEF_TEST_LIBGRAPHEME(name, reporter) \
+    DEF_TEST(name##LIBGRAPHEME, reporter) { name(reporter, SkUnicodes::Libgrapheme::Make()); }
+#else
+#define DEF_TEST_LIBGRAPHEME(name, reporter)
+#endif
+
+#define DEF_TEST_NOIMPL(name, reporter)
+
+#define DEF_TEST_UNICODES(name, reporter) \
+    static void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode); \
+    DEF_TEST_ICU(name, reporter) \
+    DEF_TEST_ICU4X(name, reporter) \
+    DEF_TEST_LIBGRAPHEME(name, reporter) \
+    DEF_TEST_NOIMPL(name, reporter) \
+    void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode)
+
+#define DEF_TEST_ICU_UNICODES(name, reporter) \
+    static void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode); \
+    DEF_TEST_ICU(name, reporter) \
+    DEF_TEST_ICU4X(name, reporter) \
+    DEF_TEST_NOIMPL(name, reporter) \
+    void name(skiatest::Reporter* reporter, sk_sp<SkUnicode> unicode)
+
+using namespace skia_private;
+
+#ifdef SK_UNICODE_CLIENT_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_Client, reporter) {
+    std::u16string text = u"\U000f2008";
+    auto utf8 = SkUnicode::convertUtf16ToUtf8(text.data(), text.size());
+    auto client = SkUnicodes::Client::Make
+                  (SkSpan<char>(&utf8[0], utf8.size()), {}, {}, {});
+    skia_private::TArray<SkUnicode::CodeUnitFlags, true> results;
+    client->computeCodeUnitFlags(utf8.data(), utf8.size(), false, &results);
+
+    for (auto flag : results) {
+        REPORTER_ASSERT(reporter, !SkUnicode::hasPartOfWhiteSpaceBreakFlag(flag));
+    }
+}
+#endif
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+UNIX_ONLY_TEST(SkUnicode_Compiled_Native, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    std::u16string text = u"\U000f2008";
+    auto utf8 = SkUnicode::convertUtf16ToUtf8(text.data(), text.size());
+    skia_private::TArray<SkUnicode::CodeUnitFlags, true> results;
+    icu->computeCodeUnitFlags(utf8.data(), utf8.size(), false, &results);
+    for (auto flag : results) {
+        REPORTER_ASSERT(reporter, !SkUnicode::hasPartOfWhiteSpaceBreakFlag(flag));
+    }
+}
+#endif
+
+#if defined(SK_UNICODE_LIBGRAPHEME_IMPLEMENTATION)
+UNIX_ONLY_TEST(SkUnicode_GetUtf8Words, reporter) {
+    SkString text("1 22 333 4444 55555 666666 7777777");
+    std::vector<SkUnicode::Position> expected = { 0, 1, 2, 4, 5, 8, 9, 13, 14, 19, 20, 26, 27, 34 };
+    auto libgrapheme = SkUnicodes::Libgrapheme::Make();
+    std::vector<SkUnicode::Position> results;
+    auto result = libgrapheme->getUtf8Words(text.data(), text.size(), "en", &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+        REPORTER_ASSERT(reporter, results[i] == expected[i]);
+    }
+}
+#endif
+
+#if defined(SK_UNICODE_ICU_IMPLEMENTATION)
+UNIX_ONLY_TEST(SkUnicode_Compiled_GetSentences, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkString text("Hello world! Hello world? Hello world... Not a sentence end: 3.1415926");
+    std::vector<SkUnicode::Position> expected = {0, 13, 26, 41, 70};
+    std::vector<SkUnicode::Position> results;
+    auto result = icu->getSentences(text.data(), text.size(), nullptr, &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+        REPORTER_ASSERT(reporter, results[i] == expected[i]);
+    }
+}
+#endif
+
+bool hasWordFlag(SkUnicode::CodeUnitFlags flags) {
+    return (flags & SkUnicode::kWordBreak) == SkUnicode::kWordBreak;
+}
+
+// On Windows libgrapheme produces different results
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsLTR, reporter) {
+    if (!unicode) {
+        return;
+    }
+    SkString text("1 22 333 4444 55555 666666 7777777");
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kLTR,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == 1);
+    REPORTER_ASSERT(reporter, results[0].start == 0 &&
+                              results[0].end == text.size() &&
+                              results[0].level == 0);
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsRTL, reporter) {
+    if (!unicode) {
+        return;
+    }
+    SkString text("          .");
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kRTL,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == 1);
+    REPORTER_ASSERT(reporter, results[0].start == 0 &&
+                              results[0].end == text.size() &&
+                              results[0].level == 1);
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsMix1, reporter) {
+    if (!unicode) {
+        return;
+    }
+    // Spaces become Arabic (RTL) but numbers remain English (LTR)
+    SkString text("1 22 333 4444 55555 666666 7777777");
+    std::vector<SkUnicode::BidiRegion> expected = {
+        {0, 1, 2},
+        {1, 2, 1},
+        {2, 4, 2},
+        {4, 5, 1},
+        {5, 8, 2},
+        {8, 9, 1},
+        {9, 13, 2},
+        {13, 14, 1},
+        {14, 19, 2},
+        {19, 20, 1},
+        {20, 26, 2},
+        {26, 27, 1},
+        {27, 34, 2},
+    };
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kRTL,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+      REPORTER_ASSERT(reporter, results[i].start == expected[i].start &&
+                                results[i].end == expected[i].end &&
+                                results[i].level == expected[i].level);
+    }
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_GetBidiRegionsMix2, reporter) {
+    if (!unicode) {
+      return;
+    }
+    // Few Russian/English words () in the mix
+    SkString text("World  Domination        World  Optimization.");
+    std::vector<SkUnicode::BidiRegion> expected = {
+        { 0, 24, 0},
+        { 24, 80, 1},
+        { 80, 107, 0},
+    };
+    std::vector<SkUnicode::BidiRegion> results;
+    auto result = unicode->getBidiRegions(text.data(),
+                                          text.size(),
+                                          SkUnicode::TextDirection::kLTR,
+                                          &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == expected.size());
+    for (auto i = 0ul; i < results.size(); ++i) {
+        REPORTER_ASSERT(reporter, results[i].start == expected[i].start &&
+                                  results[i].end == expected[i].end &&
+                                  results[i].level == expected[i].level);
+    }
+}
+
+// Currently, libgrapheme uses different default rules and produces slightly
+// different results; it does not matter for text shaping
+DEF_TEST_ICU_UNICODES(SkUnicode_ToUpper, reporter) {
+    if (!unicode) {
+        return;
+    }
+    SkString lower("abcdefghijklmnopqrstuvwxyz");
+    SkString upper("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
+    auto icu_result1 = unicode->toUpper(lower);
+    REPORTER_ASSERT(reporter, icu_result1.equals(upper));
+    auto icu_result2 = unicode->toUpper(upper);
+    REPORTER_ASSERT(reporter, icu_result2.equals(upper));
+}
+
+DEF_TEST_ICU_UNICODES(SkUnicode_ComputeCodeUnitFlags, reporter) {
+    if (!unicode) {
+        return;
+    }
+    //SkString text("World domination is such an ugly phrase - I prefer to call it world optimisation");
+    SkString text("1\n22 333 4444 55555 666666 7777777");
+    // 4 8 13 19 24
+    TArray<SkUnicode::CodeUnitFlags> results;
+    auto result = unicode->computeCodeUnitFlags(text.data(),
+                                                text.size(),
+                                                /*replaceTabs=*/true,
+                                                &results);
+    REPORTER_ASSERT(reporter, result);
+    REPORTER_ASSERT(reporter, results.size() == SkToS16(text.size() + 1));
+    for (auto i = 0; i < results.size(); ++i) {
+        auto flags = results[i];
+        auto expected = SkUnicode::CodeUnitFlags::kGraphemeStart;
+        if (i == 1) {
+            expected |= SkUnicode::CodeUnitFlags::kControl;
+        }
+        if (i == 2) {
+            expected |= SkUnicode::CodeUnitFlags::kHardLineBreakBefore;
+        }
+        if (i == 1 || i == 4 || i == 8 || i == 13 || i == 19 || i == 26) {
+            expected |= SkUnicode::CodeUnitFlags::kPartOfWhiteSpaceBreak;
+            expected |= SkUnicode::CodeUnitFlags::kPartOfIntraWordBreak;
+        }
+        if (i == 0 || i == 2 || i == 5 || i == 9 || i == 14 || i == 20
+                                                 || i == 27 || i == 34) {
+            expected |= SkUnicode::CodeUnitFlags::kSoftLineBreakBefore;
+        }
+        REPORTER_ASSERT(reporter, flags == expected);
+    }
+}
+
+DEF_TEST_UNICODES(SkUnicode_ReorderVisual, reporter) {
+    if (!unicode) {
+        return;
+    }
+    auto reorder = [&](std::vector<SkUnicode::BidiLevel> levels,
+                       std::vector<int32_t> expected) {
+            std::vector<int32_t> logicalOrder(levels.size());
+            unicode->reorderVisual(levels.data(), levels.size(), logicalOrder.data());
+            for (auto i = 0ul; i < levels.size(); ++i) {
+                REPORTER_ASSERT(reporter, expected[i] == logicalOrder[i]);
+            }
+        };
+    reorder({}, {});
+    reorder({0}, {0});
+    reorder({1}, {0});
+    reorder({0, 1, 0, 1}, {0, 1, 2, 3});
+}
+
+[[maybe_unused]] static void SkUnicode_Emoji(SkUnicode* icu, skiatest::Reporter* reporter) {
+    std::u32string emojis(U"");
+    std::u32string not_emojis(U"");
+    for (auto e : emojis) {
+        REPORTER_ASSERT(reporter, icu->isEmoji(e));
+    }
+    for (auto n: not_emojis) {
+        REPORTER_ASSERT(reporter, !icu->isEmoji(n));
+    }
+}
+
+#ifdef SK_UNICODE_ICU_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_Compiled_Emoji, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Emoji(icu.get(), reporter);
+}
+#endif
+
+#ifdef SK_UNICODE_ICU4X_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_ICU4X_Emoji, reporter) {
+    auto icu = SkUnicodes::ICU4X::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Emoji(icu.get(), reporter);
+}
+#endif
+
+[[maybe_unused]] static void SkUnicode_Ideographic(SkUnicode* icu, skiatest::Reporter* reporter) {
+    std::u32string ideographic(U"");
+    std::u32string not_ideographic(U"");
+    for (auto i : ideographic) {
+        REPORTER_ASSERT(reporter, icu->isIdeographic(i));
+    }
+    for (auto n: not_ideographic) {
+        REPORTER_ASSERT(reporter, !icu->isIdeographic(n));
+    }
+}
+
+#ifdef SK_UNICODE_ICU_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_Compiled_Ideographic, reporter) {
+    auto icu = SkUnicodes::ICU::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Ideographic(icu.get(), reporter);
+}
+#endif
+
+#ifdef SK_UNICODE_ICU4X_IMPLEMENTATION
+UNIX_ONLY_TEST(SkUnicode_ICU4X_Ideographic, reporter) {
+    auto icu = SkUnicodes::ICU4X::Make();
+    if (!icu) {
+        REPORTER_ASSERT(reporter, icu);
+        return;
+    }
+    SkUnicode_Ideographic(icu.get(), reporter);
+}
+#endif
diff --git a/Source/ThirdParty/skia/modules/svg/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/BUILD.bazel
new file mode 100644
index 00000000..c5bcb0a1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/BUILD.bazel
@@ -0,0 +1,29 @@
+load("//bazel:skia_rules.bzl", "skia_cc_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+skia_cc_library(
+    name = "svg_renderer",
+    srcs = [
+        "//modules/svg/src:private_hdrs",
+        "//modules/svg/src:srcs",
+    ],
+    hdrs = ["//modules/svg/include:public_hdrs"],
+    features = ["layering_check"],
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//:core",
+        "//:jpeg_decode_codec",
+        "//:pathops",
+        "//:png_decode_codec",
+        "//modules/skresources",
+        "//modules/skshaper:skshaper_core",
+        "//src/base",
+        "//src/core:core_priv",
+        "//src/xml",
+    ],
+)
diff --git a/Source/ThirdParty/skia/modules/svg/BUILD.gn b/Source/ThirdParty/skia/modules/svg/BUILD.gn
new file mode 100644
index 00000000..b0fee5da
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/BUILD.gn
@@ -0,0 +1,70 @@
+# Copyright 2020 Google Inc.
+#
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+
+import("../../gn/skia.gni")
+
+if (skia_enable_svg && skia_use_expat) {
+  config("public_config") {
+    defines = [ "SK_ENABLE_SVG" ]
+    include_dirs = [ "include" ]
+  }
+
+  skia_component("svg") {
+    check_includes = false
+    import("svg.gni")
+    public_configs = [ ":public_config" ]
+    public = skia_svg_public
+    sources = skia_svg_sources
+    configs = [ "../../:skia_private" ]
+    deps = [
+      "../..:skia",
+      "../skresources",
+      "../skshaper",
+      "../skunicode",
+    ]
+  }
+
+  if (skia_enable_tools) {
+    if (defined(is_skia_standalone)) {
+      skia_source_set("tool") {
+        check_includes = false
+        testonly = true
+
+        configs = [ "../..:skia_private" ]
+        sources = [ "utils/SvgTool.cpp" ]
+
+        deps = [
+          "../..:flags",
+          "../..:skia",
+          "../..:tool_utils",
+        ]
+
+        public_deps = [ ":svg" ]
+      }
+    }
+
+    skia_source_set("tests") {
+      testonly = true
+
+      configs = [ "../..:skia_private" ]
+      sources = [
+        "tests/Filters.cpp",
+        "tests/Text.cpp",
+      ]
+
+      deps = [
+        ":svg",
+        "../..:skia",
+        "../..:test",
+        "../skshaper",
+      ]
+    }
+  }
+} else {
+  group("svg") {
+  }
+  group("tests") {
+  }
+}
diff --git a/Source/ThirdParty/skia/modules/svg/include/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/include/BUILD.bazel
new file mode 100644
index 00000000..bb19778e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/BUILD.bazel
@@ -0,0 +1,64 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+# This group is exported as //modules/svg/svg.gni:skia_svg_public
+skia_filegroup(
+    name = "public_hdrs",
+    srcs = [
+        "SkSVGAttribute.h",
+        "SkSVGAttributeParser.h",
+        "SkSVGCircle.h",
+        "SkSVGClipPath.h",
+        "SkSVGContainer.h",
+        "SkSVGDOM.h",
+        "SkSVGDefs.h",
+        "SkSVGEllipse.h",
+        "SkSVGFe.h",
+        "SkSVGFeBlend.h",
+        "SkSVGFeColorMatrix.h",
+        "SkSVGFeComponentTransfer.h",
+        "SkSVGFeComposite.h",
+        "SkSVGFeDisplacementMap.h",
+        "SkSVGFeFlood.h",
+        "SkSVGFeGaussianBlur.h",
+        "SkSVGFeImage.h",
+        "SkSVGFeLightSource.h",
+        "SkSVGFeLighting.h",
+        "SkSVGFeMerge.h",
+        "SkSVGFeMorphology.h",
+        "SkSVGFeOffset.h",
+        "SkSVGFeTurbulence.h",
+        "SkSVGFilter.h",
+        "SkSVGFilterContext.h",
+        "SkSVGG.h",
+        "SkSVGGradient.h",
+        "SkSVGHiddenContainer.h",
+        "SkSVGIDMapper.h",
+        "SkSVGImage.h",
+        "SkSVGLine.h",
+        "SkSVGLinearGradient.h",
+        "SkSVGMask.h",
+        "SkSVGNode.h",
+        "SkSVGOpenTypeSVGDecoder.h",
+        "SkSVGPath.h",
+        "SkSVGPattern.h",
+        "SkSVGPoly.h",
+        "SkSVGRadialGradient.h",
+        "SkSVGRect.h",
+        "SkSVGRenderContext.h",
+        "SkSVGSVG.h",
+        "SkSVGShape.h",
+        "SkSVGStop.h",
+        "SkSVGText.h",
+        "SkSVGTransformableNode.h",
+        "SkSVGTypes.h",
+        "SkSVGUse.h",
+        "SkSVGValue.h",
+    ],
+    visibility = ["//modules/svg:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h
new file mode 100644
index 00000000..8e4d56ca
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttribute.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGAttribute_DEFINED
+#define SkSVGAttribute_DEFINED
+
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkTLazy.h"
+
+class SkSVGRenderContext;
+
+enum class SkSVGAttribute {
+    kClipRule,
+    kColor,
+    kColorInterpolation,
+    kColorInterpolationFilters,
+    kCx, // <circle>, <ellipse>, <radialGradient>: center x position
+    kCy, // <circle>, <ellipse>, <radialGradient>: center y position
+    kFill,
+    kFillOpacity,
+    kFillRule,
+    kFilter,
+    kFilterUnits,
+    kFontFamily,
+    kFontSize,
+    kFontStyle,
+    kFontWeight,
+    kFx, // <radialGradient>: focal point x position
+    kFy, // <radialGradient>: focal point y position
+    kGradientUnits,
+    kGradientTransform,
+    kHeight,
+    kHref,
+    kOpacity,
+    kPoints,
+    kPreserveAspectRatio,
+    kR,  // <circle>, <radialGradient>: radius
+    kRx, // <ellipse>,<rect>: horizontal (corner) radius
+    kRy, // <ellipse>,<rect>: vertical (corner) radius
+    kSpreadMethod,
+    kStroke,
+    kStrokeDashArray,
+    kStrokeDashOffset,
+    kStrokeOpacity,
+    kStrokeLineCap,
+    kStrokeLineJoin,
+    kStrokeMiterLimit,
+    kStrokeWidth,
+    kTransform,
+    kText,
+    kTextAnchor,
+    kViewBox,
+    kVisibility,
+    kWidth,
+    kX,
+    kX1, // <line>: first endpoint x
+    kX2, // <line>: second endpoint x
+    kY,
+    kY1, // <line>: first endpoint y
+    kY2, // <line>: second endpoint y
+
+    kUnknown,
+};
+
+struct SkSVGPresentationAttributes {
+    static SkSVGPresentationAttributes MakeInitial();
+
+    // TODO: SkSVGProperty adds an extra ptr per attribute; refactor to reduce overhead.
+
+    SkSVGProperty<SkSVGPaint     , true> fFill;
+    SkSVGProperty<SkSVGNumberType, true> fFillOpacity;
+    SkSVGProperty<SkSVGFillRule  , true> fFillRule;
+    SkSVGProperty<SkSVGFillRule  , true> fClipRule;
+
+    SkSVGProperty<SkSVGPaint     , true> fStroke;
+    SkSVGProperty<SkSVGDashArray , true> fStrokeDashArray;
+    SkSVGProperty<SkSVGLength    , true> fStrokeDashOffset;
+    SkSVGProperty<SkSVGLineCap   , true> fStrokeLineCap;
+    SkSVGProperty<SkSVGLineJoin  , true> fStrokeLineJoin;
+    SkSVGProperty<SkSVGNumberType, true> fStrokeMiterLimit;
+    SkSVGProperty<SkSVGNumberType, true> fStrokeOpacity;
+    SkSVGProperty<SkSVGLength    , true> fStrokeWidth;
+
+    SkSVGProperty<SkSVGVisibility, true> fVisibility;
+
+    SkSVGProperty<SkSVGColorType , true> fColor;
+    SkSVGProperty<SkSVGColorspace, true> fColorInterpolation;
+    SkSVGProperty<SkSVGColorspace, true> fColorInterpolationFilters;
+
+    SkSVGProperty<SkSVGFontFamily, true> fFontFamily;
+    SkSVGProperty<SkSVGFontStyle , true> fFontStyle;
+    SkSVGProperty<SkSVGFontSize  , true> fFontSize;
+    SkSVGProperty<SkSVGFontWeight, true> fFontWeight;
+    SkSVGProperty<SkSVGTextAnchor, true> fTextAnchor;
+
+    // uninherited
+    SkSVGProperty<SkSVGNumberType, false> fOpacity;
+    SkSVGProperty<SkSVGFuncIRI   , false> fClipPath;
+    SkSVGProperty<SkSVGDisplay   , false> fDisplay;
+    SkSVGProperty<SkSVGFuncIRI   , false> fMask;
+    SkSVGProperty<SkSVGFuncIRI   , false> fFilter;
+    SkSVGProperty<SkSVGColor     , false> fStopColor;
+    SkSVGProperty<SkSVGNumberType, false> fStopOpacity;
+    SkSVGProperty<SkSVGColor     , false> fFloodColor;
+    SkSVGProperty<SkSVGNumberType, false> fFloodOpacity;
+    SkSVGProperty<SkSVGColor     , false> fLightingColor;
+};
+
+#endif // SkSVGAttribute_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h
new file mode 100644
index 00000000..ce66852e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGAttributeParser.h
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGAttributeParser_DEFINED
+#define SkSVGAttributeParser_DEFINED
+
+#include <vector>
+
+#include "include/private/base/SkNoncopyable.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkTLazy.h"
+
+class SkSVGAttributeParser : public SkNoncopyable {
+public:
+    SkSVGAttributeParser(const char[]);
+
+    bool parseInteger(SkSVGIntegerType*);
+    bool parseViewBox(SkSVGViewBoxType*);
+    bool parsePreserveAspectRatio(SkSVGPreserveAspectRatio*);
+
+    // TODO: Migrate all parse*() functions to this style (and delete the old version)
+    //      so they can be used by parse<T>():
+    bool parse(SkSVGIntegerType* v) { return parseInteger(v); }
+
+    template <typename T> using ParseResult = SkTLazy<T>;
+
+    template <typename T> static ParseResult<T> parse(const char* value) {
+        ParseResult<T> result;
+        T parsedValue;
+        if (SkSVGAttributeParser(value).parse(&parsedValue)) {
+            result.set(std::move(parsedValue));
+        }
+        return result;
+    }
+
+    template <typename T>
+    static ParseResult<T> parse(const char* expectedName,
+                                const char* name,
+                                const char* value) {
+        if (!strcmp(name, expectedName)) {
+            return parse<T>(value);
+        }
+
+        return ParseResult<T>();
+    }
+
+    template <typename PropertyT>
+    static ParseResult<PropertyT> parseProperty(const char* expectedName,
+                                                const char* name,
+                                                const char* value) {
+        if (strcmp(name, expectedName) != 0) {
+            return ParseResult<PropertyT>();
+        }
+
+        if (!strcmp(value, "inherit")) {
+            PropertyT result(SkSVGPropertyState::kInherit);
+            return ParseResult<PropertyT>(&result);
+        }
+
+        auto pr = parse<typename PropertyT::ValueT>(value);
+        if (pr.isValid()) {
+            PropertyT result(*pr);
+            return ParseResult<PropertyT>(&result);
+        }
+
+        return ParseResult<PropertyT>();
+    }
+
+private:
+    class RestoreCurPos {
+    public:
+        explicit RestoreCurPos(SkSVGAttributeParser* self)
+            : fSelf(self), fCurPos(self->fCurPos) {}
+
+        ~RestoreCurPos() {
+            if (fSelf) {
+                fSelf->fCurPos = this->fCurPos;
+            }
+        }
+
+        void clear() { fSelf = nullptr; }
+    private:
+        SkSVGAttributeParser* fSelf;
+        const char* fCurPos;
+
+        RestoreCurPos(           const RestoreCurPos&) = delete;
+        RestoreCurPos& operator=(const RestoreCurPos&) = delete;
+    };
+
+    // Stack-only
+    void* operator new(size_t) = delete;
+    void* operator new(size_t, void*) = delete;
+
+    template <typename T>
+    bool parse(T*);
+
+    template <typename F>
+    bool advanceWhile(F func);
+
+    bool matchStringToken(const char* token, const char** newPos = nullptr) const;
+    bool matchHexToken(const char** newPos) const;
+
+    bool parseWSToken();
+    bool parseEOSToken();
+    bool parseSepToken();
+    bool parseCommaWspToken();
+    bool parseExpectedStringToken(const char*);
+    bool parseScalarToken(SkScalar*);
+    bool parseInt32Token(int32_t*);
+    bool parseEscape(SkUnichar*);
+    bool parseIdentToken(SkString*);
+    bool parseLengthUnitToken(SkSVGLength::Unit*);
+    bool parseNamedColorToken(SkColor*);
+    bool parseHexColorToken(SkColor*);
+    bool parseColorComponentScalarToken(int32_t*);
+    bool parseColorComponentIntegralToken(int32_t*);
+    bool parseColorComponentFractionalToken(int32_t*);
+    bool parseColorComponentToken(int32_t*);
+    bool parseColorToken(SkColor*);
+    bool parseRGBColorToken(SkColor*);
+    bool parseRGBAColorToken(SkColor*);
+    bool parseSVGColor(SkSVGColor*, SkSVGColor::Vars&&);
+    bool parseSVGColorType(SkSVGColorType*);
+    bool parseFuncIRI(SkSVGFuncIRI*);
+
+    // Transform helpers
+    bool parseMatrixToken(SkMatrix*);
+    bool parseTranslateToken(SkMatrix*);
+    bool parseScaleToken(SkMatrix*);
+    bool parseRotateToken(SkMatrix*);
+    bool parseSkewXToken(SkMatrix*);
+    bool parseSkewYToken(SkMatrix*);
+
+    // Parses a sequence of 'WS* <prefix> WS* (<nested>)', where the nested sequence
+    // is handled by the passed functor.
+    template <typename Func, typename T>
+    bool parseParenthesized(const char* prefix, Func, T* result);
+
+    template <typename T>
+    bool parseList(std::vector<T>*);
+
+    template <typename T, typename TArray>
+    bool parseEnumMap(const TArray& arr, T* result) {
+        for (size_t i = 0; i < std::size(arr); ++i) {
+            if (this->parseExpectedStringToken(std::get<0>(arr[i]))) {
+                *result = std::get<1>(arr[i]);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // The current position in the input string.
+    const char* fCurPos;
+    const char* fEndPos;
+
+    using INHERITED = SkNoncopyable;
+};
+
+#endif // SkSVGAttributeParser_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h
new file mode 100644
index 00000000..83683b8b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGCircle.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGCircle_DEFINED
+#define SkSVGCircle_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+struct SkPoint;
+
+class SK_API SkSVGCircle final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGCircle> Make() { return sk_sp<SkSVGCircle>(new SkSVGCircle()); }
+
+    SVG_ATTR(Cx, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Cy, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(R , SkSVGLength, SkSVGLength(0))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGCircle();
+
+    // resolve and return the center and radius values
+    std::tuple<SkPoint, SkScalar> resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGCircle_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h
new file mode 100644
index 00000000..a981b879
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGClipPath.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGClipPath_DEFINED
+#define SkSVGClipPath_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGClipPath final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGClipPath> Make() {
+        return sk_sp<SkSVGClipPath>(new SkSVGClipPath());
+    }
+
+    SVG_ATTR(ClipPathUnits, SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse))
+
+private:
+    friend class SkSVGRenderContext;
+
+    SkSVGClipPath();
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    SkPath resolveClip(const SkSVGRenderContext&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGClipPath_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h
new file mode 100644
index 00000000..9449cd22
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGContainer.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGContainer_DEFINED
+#define SkSVGContainer_DEFINED
+
+#include "include/private/base/SkTArray.h"
+#include "modules/svg/include/SkSVGTransformableNode.h"
+
+class SK_API SkSVGContainer : public SkSVGTransformableNode {
+public:
+    void appendChild(sk_sp<SkSVGNode>) override;
+
+protected:
+    explicit SkSVGContainer(SkSVGTag);
+
+    void onRender(const SkSVGRenderContext&) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+    bool hasChildren() const final;
+
+    template <typename NodeType, typename Func>
+    void forEachChild(Func func) const {
+        for (const auto& child : fChildren) {
+            if (child->tag() == NodeType::tag) {
+                func(static_cast<const NodeType*>(child.get()));
+            }
+        }
+    }
+
+    // TODO: convert remaining direct users to iterators, and make the container private.
+    skia_private::STArray<1, sk_sp<SkSVGNode>, true> fChildren;
+
+private:
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif // SkSVGContainer_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h
new file mode 100644
index 00000000..87fc347e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGDOM.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGDOM_DEFINED
+#define SkSVGDOM_DEFINED
+
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkSize.h"
+#include "include/private/base/SkTemplates.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+#include "modules/svg/include/SkSVGIDMapper.h"
+
+class SkCanvas;
+class SkDOM;
+class SkStream;
+class SkSVGNode;
+struct SkSVGPresentationContext;
+class SkSVGSVG;
+
+class SK_API SkSVGDOM : public SkRefCnt {
+public:
+    class Builder final {
+    public:
+        /**
+         * Specify a font manager for loading fonts (e.g. from the system) to render <text>
+         * SVG nodes.
+         * If this is not set, but a font is required as part of rendering, the text will
+         * not be displayed.
+         */
+        Builder& setFontManager(sk_sp<SkFontMgr>);
+
+        /**
+         * Specify a resource provider for loading images etc.
+         */
+        Builder& setResourceProvider(sk_sp<skresources::ResourceProvider>);
+
+        /**
+         * Specify the callbacks for dealing with shaping text. See also
+         * modules/skshaper/utils/FactoryHelpers.h
+         */
+        Builder& setTextShapingFactory(sk_sp<SkShapers::Factory>);
+
+        sk_sp<SkSVGDOM> make(SkStream&) const;
+
+    private:
+        sk_sp<SkFontMgr>                             fFontMgr;
+        sk_sp<skresources::ResourceProvider>         fResourceProvider;
+        sk_sp<SkShapers::Factory>                    fTextShapingFactory;
+    };
+
+    static sk_sp<SkSVGDOM> MakeFromStream(SkStream& str) {
+        return Builder().make(str);
+    }
+
+    /**
+     * Returns the root (outermost) SVG element.
+     */
+    SkSVGSVG* getRoot() const { return fRoot.get(); }
+
+    /**
+     * Specify a "container size" for the SVG dom.
+     *
+     * This is used to resolve the initial viewport when the root SVG width/height are specified
+     * in relative units.
+     *
+     * If the root dimensions are in absolute units, then the container size has no effect since
+     * the initial viewport is fixed.
+     */
+    void setContainerSize(const SkSize&);
+
+    /**
+     * DEPRECATED: use getRoot()->intrinsicSize() to query the root element intrinsic size.
+     *
+     * Returns the SVG dom container size.
+     *
+     * If the client specified a container size via setContainerSize(), then the same size is
+     * returned.
+     *
+     * When unspecified by clients, this returns the intrinsic size of the root element, as defined
+     * by its width/height attributes.  If either width or height is specified in relative units
+     * (e.g. "100%"), then the corresponding intrinsic size dimension is zero.
+     */
+    const SkSize& containerSize() const;
+
+    // Returns the node with the given id, or nullptr if not found.
+    sk_sp<SkSVGNode>* findNodeById(const char* id);
+
+    void render(SkCanvas*) const;
+
+    /** Render the node with the given id as if it were the only child of the root. */
+    void renderNode(SkCanvas*, SkSVGPresentationContext&, const char* id) const;
+
+private:
+    SkSVGDOM(sk_sp<SkSVGSVG>,
+             sk_sp<SkFontMgr>,
+             sk_sp<skresources::ResourceProvider>,
+             SkSVGIDMapper&&,
+             sk_sp<SkShapers::Factory>);
+
+    const sk_sp<SkSVGSVG>                       fRoot;
+    const sk_sp<SkFontMgr>                      fFontMgr;
+    const sk_sp<SkShapers::Factory>             fTextShapingFactory;
+    const sk_sp<skresources::ResourceProvider>  fResourceProvider;
+    const SkSVGIDMapper                         fIDMapper;
+    SkSize                                      fContainerSize;
+};
+
+#endif // SkSVGDOM_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h
new file mode 100644
index 00000000..0e63b0fc
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGDefs.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGDefs_DEFINED
+#define SkSVGDefs_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+
+class SK_API SkSVGDefs : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGDefs> Make() { return sk_sp<SkSVGDefs>(new SkSVGDefs()); }
+
+private:
+    SkSVGDefs() : INHERITED(SkSVGTag::kDefs) {}
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGDefs_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h
new file mode 100644
index 00000000..eb2eb513
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGEllipse.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGEllipse_DEFINED
+#define SkSVGEllipse_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+struct SkRect;
+
+class SK_API SkSVGEllipse final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGEllipse> Make() { return sk_sp<SkSVGEllipse>(new SkSVGEllipse()); }
+
+    SVG_ATTR(Cx, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Cy, SkSVGLength, SkSVGLength(0))
+
+    SVG_OPTIONAL_ATTR(Rx, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Ry, SkSVGLength)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGEllipse();
+
+    SkRect resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGEllipse_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h
new file mode 100644
index 00000000..ba0e3300
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFe.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFe_DEFINED
+#define SkSVGFe_DEFINED
+
+#include <vector>
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+
+class SkImageFilter;
+class SkSVGFilterContext;
+
+class SK_API SkSVGFe : public SkSVGHiddenContainer {
+public:
+    static bool IsFilterEffect(const sk_sp<SkSVGNode>& node) {
+        switch (node->tag()) {
+            case SkSVGTag::kFeBlend:
+            case SkSVGTag::kFeColorMatrix:
+            case SkSVGTag::kFeComponentTransfer:
+            case SkSVGTag::kFeComposite:
+            case SkSVGTag::kFeDiffuseLighting:
+            case SkSVGTag::kFeDisplacementMap:
+            case SkSVGTag::kFeFlood:
+            case SkSVGTag::kFeGaussianBlur:
+            case SkSVGTag::kFeImage:
+            case SkSVGTag::kFeMerge:
+            case SkSVGTag::kFeMorphology:
+            case SkSVGTag::kFeOffset:
+            case SkSVGTag::kFeSpecularLighting:
+            case SkSVGTag::kFeTurbulence:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    sk_sp<SkImageFilter> makeImageFilter(const SkSVGRenderContext& ctx,
+                                         const SkSVGFilterContext& fctx) const;
+
+    // https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveSubRegion
+    SkRect resolveFilterSubregion(const SkSVGRenderContext&, const SkSVGFilterContext&) const;
+
+    /**
+     * Resolves the colorspace within which this filter effect should be applied.
+     * Spec: https://www.w3.org/TR/SVG11/painting.html#ColorInterpolationProperties
+     * 'color-interpolation-filters' property.
+     */
+    virtual SkSVGColorspace resolveColorspace(const SkSVGRenderContext&,
+                                              const SkSVGFilterContext&) const;
+
+    /** Propagates any inherited presentation attributes in the given context. */
+    void applyProperties(SkSVGRenderContext*) const;
+
+    SVG_ATTR(In, SkSVGFeInputType, SkSVGFeInputType())
+    SVG_ATTR(Result, SkSVGStringType, SkSVGStringType())
+    SVG_OPTIONAL_ATTR(X, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Y, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Width, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Height, SkSVGLength)
+
+protected:
+    explicit SkSVGFe(SkSVGTag t) : INHERITED(t) {}
+
+    virtual sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                                   const SkSVGFilterContext&) const = 0;
+
+    virtual std::vector<SkSVGFeInputType> getInputs() const = 0;
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    /**
+     * Resolves the rect specified by the x, y, width and height attributes (if specified) on this
+     * filter effect. These attributes are resolved according to the given length context and
+     * the value of 'primitiveUnits' on the parent <filter> element.
+     */
+    SkRect resolveBoundaries(const SkSVGRenderContext&, const SkSVGFilterContext&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif  // SkSVGFe_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h
new file mode 100644
index 00000000..414a9559
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeBlend.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeBlend_DEFINED
+#define SkSVGFeBlend_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeBlend : public SkSVGFe {
+public:
+    enum class Mode {
+        kNormal,
+        kMultiply,
+        kScreen,
+        kDarken,
+        kLighten,
+    };
+
+    static sk_sp<SkSVGFeBlend> Make() { return sk_sp<SkSVGFeBlend>(new SkSVGFeBlend()); }
+
+    SVG_ATTR(Mode, Mode, Mode::kNormal)
+    SVG_ATTR(In2, SkSVGFeInputType, SkSVGFeInputType())
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override {
+        return {this->getIn(), this->getIn2()};
+    }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeBlend() : INHERITED(SkSVGTag::kFeBlend) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeBlend_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h
new file mode 100644
index 00000000..908a6bfb
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeColorMatrix.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeColorMatrix_DEFINED
+#define SkSVGFeColorMatrix_DEFINED
+
+#include "include/effects/SkColorMatrix.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeColorMatrix final : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeColorMatrix> Make() {
+        return sk_sp<SkSVGFeColorMatrix>(new SkSVGFeColorMatrix());
+    }
+
+    SVG_ATTR(Type, SkSVGFeColorMatrixType, SkSVGFeColorMatrixType(SkSVGFeColorMatrixType::kMatrix))
+    SVG_ATTR(Values, SkSVGFeColorMatrixValues, SkSVGFeColorMatrixValues())
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeColorMatrix() : INHERITED(SkSVGTag::kFeColorMatrix) {}
+
+    SkColorMatrix makeMatrixForType() const;
+
+    static SkColorMatrix MakeSaturate(SkSVGNumberType s);
+
+    static SkColorMatrix MakeHueRotate(SkSVGNumberType degrees);
+
+    static SkColorMatrix MakeLuminanceToAlpha();
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeColorMatrix_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h
new file mode 100644
index 00000000..696b3824
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComponentTransfer.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeComponentTransfer_DEFINED
+#define SkSVGFeComponentTransfer_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+#include <cstdint>
+
+class SkSVGFeFunc final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGFeFunc> MakeFuncA() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncA));
+    }
+
+    static sk_sp<SkSVGFeFunc> MakeFuncR() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncR));
+    }
+
+    static sk_sp<SkSVGFeFunc> MakeFuncG() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncG));
+    }
+
+    static sk_sp<SkSVGFeFunc> MakeFuncB() {
+        return sk_sp<SkSVGFeFunc>(new SkSVGFeFunc(SkSVGTag::kFeFuncB));
+    }
+
+    SVG_ATTR(Amplitude  , SkSVGNumberType,                          1)
+    SVG_ATTR(Exponent   , SkSVGNumberType,                          1)
+    SVG_ATTR(Intercept  , SkSVGNumberType,                          0)
+    SVG_ATTR(Offset     , SkSVGNumberType,                          0)
+    SVG_ATTR(Slope      , SkSVGNumberType,                          1)
+    SVG_ATTR(TableValues, std::vector<SkSVGNumberType>,            {})
+    SVG_ATTR(Type       , SkSVGFeFuncType, SkSVGFeFuncType::kIdentity)
+
+    std::vector<uint8_t> getTable() const;
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeFunc(SkSVGTag tag) : INHERITED(tag) {}
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+class SK_API SkSVGFeComponentTransfer final : public SkSVGFe {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kFeComponentTransfer;
+
+    static sk_sp<SkSVGFeComponentTransfer> Make() {
+        return sk_sp<SkSVGFeComponentTransfer>(new SkSVGFeComponentTransfer());
+    }
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+private:
+    SkSVGFeComponentTransfer() : INHERITED(tag) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif //  SkSVGFeComponentTransfer_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h
new file mode 100644
index 00000000..42cbf18a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeComposite.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeComposite_DEFINED
+#define SkSVGFeComposite_DEFINED
+
+#include "include/core/SkBlendMode.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeComposite final : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeComposite> Make() {
+        return sk_sp<SkSVGFeComposite>(new SkSVGFeComposite());
+    }
+
+    SVG_ATTR(In2, SkSVGFeInputType, SkSVGFeInputType())
+    SVG_ATTR(K1, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(K2, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(K3, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(K4, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(Operator, SkSVGFeCompositeOperator, SkSVGFeCompositeOperator::kOver)
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override {
+        return {this->getIn(), this->getIn2()};
+    }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeComposite() : INHERITED(SkSVGTag::kFeComposite) {}
+
+    static SkBlendMode BlendModeForOperator(SkSVGFeCompositeOperator);
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeComposite_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h
new file mode 100644
index 00000000..8d2ef8a2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeDisplacementMap.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeDisplacementMap_DEFINED
+#define SkSVGFeDisplacementMap_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeDisplacementMap : public SkSVGFe {
+public:
+    using ChannelSelector = SkColorChannel;
+
+    static sk_sp<SkSVGFeDisplacementMap> Make() {
+        return sk_sp<SkSVGFeDisplacementMap>(new SkSVGFeDisplacementMap());
+    }
+
+    SkSVGColorspace resolveColorspace(const SkSVGRenderContext&,
+                                      const SkSVGFilterContext&) const final;
+
+    SVG_ATTR(In2             , SkSVGFeInputType, SkSVGFeInputType())
+    SVG_ATTR(XChannelSelector, ChannelSelector , ChannelSelector::kA)
+    SVG_ATTR(YChannelSelector, ChannelSelector , ChannelSelector::kA)
+    SVG_ATTR(Scale           , SkSVGNumberType , SkSVGNumberType(0))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override {
+        return {this->getIn(), this->getIn2()};
+    }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeDisplacementMap() : INHERITED(SkSVGTag::kFeDisplacementMap) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeDisplacementMap_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h
new file mode 100644
index 00000000..dbcaaec9
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeFlood.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeFlood_DEFINED
+#define SkSVGFeFlood_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeFlood : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeFlood> Make() { return sk_sp<SkSVGFeFlood>(new SkSVGFeFlood()); }
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {}; }
+
+private:
+    SkSVGFeFlood() : INHERITED(SkSVGTag::kFeFlood) {}
+
+    SkColor resolveFloodColor(const SkSVGRenderContext&) const;
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeFlood_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h
new file mode 100644
index 00000000..b053956a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeGaussianBlur.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeGaussianBlur_DEFINED
+#define SkSVGFeGaussianBlur_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeGaussianBlur : public SkSVGFe {
+public:
+    struct StdDeviation {
+        SkSVGNumberType fX;
+        SkSVGNumberType fY;
+    };
+
+    static sk_sp<SkSVGFeGaussianBlur> Make() {
+        return sk_sp<SkSVGFeGaussianBlur>(new SkSVGFeGaussianBlur());
+    }
+
+    SVG_ATTR(StdDeviation, StdDeviation, StdDeviation({0, 0}))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeGaussianBlur() : INHERITED(SkSVGTag::kFeGaussianBlur) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeGaussianBlur_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h
new file mode 100644
index 00000000..7cc123d4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeImage.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeImage_DEFINED
+#define SkSVGFeImage_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeImage : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeImage> Make() { return sk_sp<SkSVGFeImage>(new SkSVGFeImage()); }
+
+    SVG_ATTR(Href               , SkSVGIRI                , SkSVGIRI())
+    SVG_ATTR(PreserveAspectRatio, SkSVGPreserveAspectRatio, SkSVGPreserveAspectRatio())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {}; }
+
+private:
+    SkSVGFeImage() : INHERITED(SkSVGTag::kFeImage) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeImage_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h
new file mode 100644
index 00000000..8be65c51
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLightSource.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeLightSource_DEFINED
+#define SkSVGFeLightSource_DEFINED
+
+#include "include/core/SkPoint3.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeLightSource : public SkSVGHiddenContainer {
+public:
+    void appendChild(sk_sp<SkSVGNode>) final {
+        SkDebugf("cannot append child nodes to an SVG light source.\n");
+    }
+
+protected:
+    explicit SkSVGFeLightSource(SkSVGTag tag) : INHERITED(tag) {}
+
+private:
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+class SkSVGFeDistantLight final : public SkSVGFeLightSource {
+public:
+    static sk_sp<SkSVGFeDistantLight> Make() {
+        return sk_sp<SkSVGFeDistantLight>(new SkSVGFeDistantLight());
+    }
+
+    SkPoint3 computeDirection() const;
+
+    SVG_ATTR(Azimuth  , SkSVGNumberType, 0)
+    SVG_ATTR(Elevation, SkSVGNumberType, 0)
+
+private:
+    SkSVGFeDistantLight() : INHERITED(SkSVGTag::kFeDistantLight) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGFeLightSource;
+};
+
+class SkSVGFePointLight final : public SkSVGFeLightSource {
+public:
+    static sk_sp<SkSVGFePointLight> Make() {
+        return sk_sp<SkSVGFePointLight>(new SkSVGFePointLight());
+    }
+
+    SVG_ATTR(X, SkSVGNumberType, 0)
+    SVG_ATTR(Y, SkSVGNumberType, 0)
+    SVG_ATTR(Z, SkSVGNumberType, 0)
+
+private:
+    SkSVGFePointLight() : INHERITED(SkSVGTag::kFePointLight) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGFeLightSource;
+};
+
+class SkSVGFeSpotLight final : public SkSVGFeLightSource {
+public:
+    static sk_sp<SkSVGFeSpotLight> Make() {
+        return sk_sp<SkSVGFeSpotLight>(new SkSVGFeSpotLight());
+    }
+
+    SVG_ATTR(X               , SkSVGNumberType, 0)
+    SVG_ATTR(Y               , SkSVGNumberType, 0)
+    SVG_ATTR(Z               , SkSVGNumberType, 0)
+    SVG_ATTR(PointsAtX       , SkSVGNumberType, 0)
+    SVG_ATTR(PointsAtY       , SkSVGNumberType, 0)
+    SVG_ATTR(PointsAtZ       , SkSVGNumberType, 0)
+    SVG_ATTR(SpecularExponent, SkSVGNumberType, 1)
+
+    SVG_OPTIONAL_ATTR(LimitingConeAngle, SkSVGNumberType)
+
+private:
+    SkSVGFeSpotLight() : INHERITED(SkSVGTag::kFeSpotLight) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGFeLightSource;
+};
+
+#endif  // SkSVGFeLightSource_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h
new file mode 100644
index 00000000..5321ca3e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeLighting.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeLighting_DEFINED
+#define SkSVGFeLighting_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGFeDistantLight;
+class SkSVGFePointLight;
+class SkSVGFeSpotLight;
+
+class SK_API SkSVGFeLighting : public SkSVGFe {
+public:
+    struct KernelUnitLength {
+        SkSVGNumberType fDx;
+        SkSVGNumberType fDy;
+    };
+
+    SVG_ATTR(SurfaceScale, SkSVGNumberType, 1)
+    SVG_OPTIONAL_ATTR(KernelUnitLength, KernelUnitLength)
+
+protected:
+    explicit SkSVGFeLighting(SkSVGTag t) : INHERITED(t) {}
+
+    std::vector<SkSVGFeInputType> getInputs() const final { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const final;
+
+    virtual sk_sp<SkImageFilter> makeDistantLight(const SkSVGRenderContext&,
+                                                  const SkSVGFilterContext&,
+                                                  const SkSVGFeDistantLight*) const = 0;
+
+    virtual sk_sp<SkImageFilter> makePointLight(const SkSVGRenderContext&,
+                                                const SkSVGFilterContext&,
+                                                const SkSVGFePointLight*) const = 0;
+
+    virtual sk_sp<SkImageFilter> makeSpotLight(const SkSVGRenderContext&,
+                                               const SkSVGFilterContext&,
+                                               const SkSVGFeSpotLight*) const = 0;
+
+    SkColor resolveLightingColor(const SkSVGRenderContext&) const;
+
+    SkPoint3 resolveXYZ(const SkSVGRenderContext&,
+                        const SkSVGFilterContext&,
+                        SkSVGNumberType,
+                        SkSVGNumberType,
+                        SkSVGNumberType) const;
+
+private:
+    using INHERITED = SkSVGFe;
+};
+
+class SkSVGFeSpecularLighting final : public SkSVGFeLighting {
+public:
+    static sk_sp<SkSVGFeSpecularLighting> Make() {
+        return sk_sp<SkSVGFeSpecularLighting>(new SkSVGFeSpecularLighting());
+    }
+
+    SVG_ATTR(SpecularConstant, SkSVGNumberType, 1)
+    SVG_ATTR(SpecularExponent, SkSVGNumberType, 1)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> makeDistantLight(const SkSVGRenderContext&,
+                                          const SkSVGFilterContext&,
+                                          const SkSVGFeDistantLight*) const final;
+
+    sk_sp<SkImageFilter> makePointLight(const SkSVGRenderContext&,
+                                        const SkSVGFilterContext&,
+                                        const SkSVGFePointLight*) const final;
+
+    sk_sp<SkImageFilter> makeSpotLight(const SkSVGRenderContext&,
+                                       const SkSVGFilterContext&,
+                                       const SkSVGFeSpotLight*) const final;
+
+private:
+    SkSVGFeSpecularLighting() : INHERITED(SkSVGTag::kFeSpecularLighting) {}
+
+    using INHERITED = SkSVGFeLighting;
+};
+
+class SkSVGFeDiffuseLighting final : public SkSVGFeLighting {
+public:
+    static sk_sp<SkSVGFeDiffuseLighting> Make() {
+        return sk_sp<SkSVGFeDiffuseLighting>(new SkSVGFeDiffuseLighting());
+    }
+
+    SVG_ATTR(DiffuseConstant, SkSVGNumberType, 1)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkImageFilter> makeDistantLight(const SkSVGRenderContext&,
+                                          const SkSVGFilterContext&,
+                                          const SkSVGFeDistantLight*) const final;
+
+    sk_sp<SkImageFilter> makePointLight(const SkSVGRenderContext&,
+                                        const SkSVGFilterContext&,
+                                        const SkSVGFePointLight*) const final;
+
+    sk_sp<SkImageFilter> makeSpotLight(const SkSVGRenderContext&,
+                                       const SkSVGFilterContext&,
+                                       const SkSVGFeSpotLight*) const final;
+
+private:
+    SkSVGFeDiffuseLighting() : INHERITED(SkSVGTag::kFeDiffuseLighting) {}
+
+    using INHERITED = SkSVGFeLighting;
+};
+
+#endif  // SkSVGFeLighting_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h
new file mode 100644
index 00000000..0c5e317b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMerge.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeMerge_DEFINED
+#define SkSVGFeMerge_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+// https://www.w3.org/TR/SVG11/filters.html#feMergeNodeElement
+class SK_API SkSVGFeMergeNode : public SkSVGHiddenContainer {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kFeMergeNode;
+
+    static sk_sp<SkSVGFeMergeNode> Make() {
+        return sk_sp<SkSVGFeMergeNode>(new SkSVGFeMergeNode());
+    }
+
+    SVG_ATTR(In, SkSVGFeInputType, SkSVGFeInputType())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeMergeNode() : INHERITED(tag) {}
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+// https://www.w3.org/TR/SVG11/filters.html#feMergeElement
+class SK_API SkSVGFeMerge : public SkSVGFe {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kFeMerge;
+
+    static sk_sp<SkSVGFeMerge> Make() { return sk_sp<SkSVGFeMerge>(new SkSVGFeMerge()); }
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override;
+
+private:
+    SkSVGFeMerge() : INHERITED(tag) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif //  SkSVGFeMerge_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h
new file mode 100644
index 00000000..172460f7
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeMorphology.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeMorphology_DEFINED
+#define SkSVGFeMorphology_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGFeMorphology : public SkSVGFe {
+public:
+    struct Radius {
+        SkSVGNumberType fX;
+        SkSVGNumberType fY;
+    };
+
+    enum class Operator {
+        kErode,
+        kDilate,
+    };
+
+    static sk_sp<SkSVGFeMorphology> Make() {
+        return sk_sp<SkSVGFeMorphology>(new SkSVGFeMorphology());
+    }
+
+    SVG_ATTR(Operator, Operator, Operator::kErode)
+    SVG_ATTR(Radius  , Radius  , Radius({0, 0}))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeMorphology() : INHERITED(SkSVGTag::kFeMorphology) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeMorphology_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h
new file mode 100644
index 00000000..8ed6288b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeOffset.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeOffset_DEFINED
+#define SkSVGFeOffset_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeOffset : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeOffset> Make() { return sk_sp<SkSVGFeOffset>(new SkSVGFeOffset()); }
+
+    SVG_ATTR(Dx, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(Dy, SkSVGNumberType, SkSVGNumberType(0))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {this->getIn()}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGFeOffset() : INHERITED(SkSVGTag::kFeOffset) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeOffset_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h
new file mode 100644
index 00000000..53f300c8
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFeTurbulence.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFeTurbulence_DEFINED
+#define SkSVGFeTurbulence_DEFINED
+
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFeTurbulence : public SkSVGFe {
+public:
+    static sk_sp<SkSVGFeTurbulence> Make() {
+        return sk_sp<SkSVGFeTurbulence>(new SkSVGFeTurbulence());
+    }
+
+    SVG_ATTR(BaseFrequency, SkSVGFeTurbulenceBaseFrequency, SkSVGFeTurbulenceBaseFrequency({}))
+    SVG_ATTR(NumOctaves, SkSVGIntegerType, SkSVGIntegerType(1))
+    SVG_ATTR(Seed, SkSVGNumberType, SkSVGNumberType(0))
+    SVG_ATTR(TurbulenceType,
+             SkSVGFeTurbulenceType,
+             SkSVGFeTurbulenceType(SkSVGFeTurbulenceType::Type::kTurbulence))
+
+protected:
+    sk_sp<SkImageFilter> onMakeImageFilter(const SkSVGRenderContext&,
+                                           const SkSVGFilterContext&) const override;
+
+    std::vector<SkSVGFeInputType> getInputs() const override { return {}; }
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+private:
+    SkSVGFeTurbulence() : INHERITED(SkSVGTag::kFeTurbulence) {}
+
+    using INHERITED = SkSVGFe;
+};
+
+#endif  // SkSVGFeTurbulence_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h
new file mode 100644
index 00000000..b4320a13
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilter.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFilter_DEFINED
+#define SkSVGFilter_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGFilter final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGFilter> Make() { return sk_sp<SkSVGFilter>(new SkSVGFilter()); }
+
+    /** Propagates any inherited presentation attributes in the given context. */
+    void applyProperties(SkSVGRenderContext*) const;
+
+    sk_sp<SkImageFilter> buildFilterDAG(const SkSVGRenderContext&) const;
+
+    SVG_ATTR(X, SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y, SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Width, SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Height, SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(FilterUnits,
+             SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox))
+    SVG_ATTR(PrimitiveUnits,
+             SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse))
+
+private:
+    SkSVGFilter() : INHERITED(SkSVGTag::kFilter) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif  // SkSVGFilter_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h
new file mode 100644
index 00000000..dcd938d1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGFilterContext.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGFilterContext_DEFINED
+#define SkSVGFilterContext_DEFINED
+
+#include "include/core/SkRect.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkString.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/core/SkTHash.h"
+
+class SkImageFilter;
+class SkSVGFeInputType;
+class SkSVGRenderContext;
+
+class SkSVGFilterContext {
+public:
+    SkSVGFilterContext(const SkRect& filterEffectsRegion,
+                       const SkSVGObjectBoundingBoxUnits& primitiveUnits)
+            : fFilterEffectsRegion(filterEffectsRegion)
+            , fPrimitiveUnits(primitiveUnits)
+            , fPreviousResult({nullptr, filterEffectsRegion, SkSVGColorspace::kSRGB}) {}
+
+    const SkRect& filterEffectsRegion() const { return fFilterEffectsRegion; }
+
+    const SkRect& filterPrimitiveSubregion(const SkSVGFeInputType&) const;
+
+    const SkSVGObjectBoundingBoxUnits& primitiveUnits() const { return fPrimitiveUnits; }
+
+    void registerResult(const SkSVGStringType&, const sk_sp<SkImageFilter>&, const SkRect&, SkSVGColorspace);
+
+    void setPreviousResult(const sk_sp<SkImageFilter>&, const SkRect&, SkSVGColorspace);
+
+    bool previousResultIsSourceGraphic() const;
+
+    SkSVGColorspace resolveInputColorspace(const SkSVGRenderContext&,
+                                           const SkSVGFeInputType&) const;
+
+    sk_sp<SkImageFilter> resolveInput(const SkSVGRenderContext&, const SkSVGFeInputType&) const;
+
+    sk_sp<SkImageFilter> resolveInput(const SkSVGRenderContext&, const SkSVGFeInputType&, SkSVGColorspace) const;
+
+private:
+    struct Result {
+        sk_sp<SkImageFilter> fImageFilter;
+        SkRect fFilterSubregion;
+        SkSVGColorspace fColorspace;
+    };
+
+    const Result* findResultById(const SkSVGStringType&) const;
+
+    std::tuple<sk_sp<SkImageFilter>, SkSVGColorspace> getInput(const SkSVGRenderContext&,
+                                                               const SkSVGFeInputType&) const;
+
+    SkRect fFilterEffectsRegion;
+
+    SkSVGObjectBoundingBoxUnits fPrimitiveUnits;
+
+    skia_private::THashMap<SkSVGStringType, Result> fResults;
+
+    Result fPreviousResult;
+};
+
+#endif  // SkSVGFilterContext_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGG.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGG.h
new file mode 100644
index 00000000..10b90816
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGG.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGG_DEFINED
+#define SkSVGG_DEFINED
+
+#include "modules/svg/include/SkSVGContainer.h"
+
+class SK_API SkSVGG : public SkSVGContainer {
+public:
+    static sk_sp<SkSVGG> Make() { return sk_sp<SkSVGG>(new SkSVGG()); }
+
+private:
+    SkSVGG() : INHERITED(SkSVGTag::kG) { }
+
+    using INHERITED = SkSVGContainer;
+};
+
+#endif // SkSVGG_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h
new file mode 100644
index 00000000..4a7feefd
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGGradient.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGGradient_DEFINED
+#define SkSVGGradient_DEFINED
+
+#include "include/core/SkShader.h"
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkMatrix;
+class SkSVGRenderContext;
+class SkSVGStop;
+
+class SK_API SkSVGGradient : public SkSVGHiddenContainer {
+public:
+    SVG_ATTR(Href, SkSVGIRI, SkSVGIRI())
+    SVG_ATTR(GradientTransform, SkSVGTransformType, SkSVGTransformType(SkMatrix::I()))
+    SVG_ATTR(SpreadMethod, SkSVGSpreadMethod, SkSVGSpreadMethod(SkSVGSpreadMethod::Type::kPad))
+    SVG_ATTR(GradientUnits,
+             SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox))
+
+protected:
+    explicit SkSVGGradient(SkSVGTag t) : INHERITED(t) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    bool onAsPaint(const SkSVGRenderContext&, SkPaint*) const final;
+
+    virtual sk_sp<SkShader> onMakeShader(const SkSVGRenderContext&,
+                                         const SkColor4f*, const SkScalar*, int count,
+                                         SkTileMode, const SkMatrix& localMatrix) const = 0;
+
+private:
+    using StopPositionArray = skia_private::STArray<2, SkScalar , true>;
+    using    StopColorArray = skia_private::STArray<2, SkColor4f, true>;
+    void collectColorStops(const SkSVGRenderContext&, StopPositionArray*, StopColorArray*) const;
+    SkColor4f resolveStopColor(const SkSVGRenderContext&, const SkSVGStop&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGGradient_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h
new file mode 100644
index 00000000..72af219b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGHiddenContainer.h
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGHiddenContainer_DEFINED
+#define SkSVGHiddenContainer_DEFINED
+
+#include "modules/svg/include/SkSVGContainer.h"
+
+class SK_API SkSVGHiddenContainer : public SkSVGContainer {
+protected:
+    explicit SkSVGHiddenContainer(SkSVGTag t) : INHERITED(t) {}
+
+    void onRender(const SkSVGRenderContext&) const final {}
+
+private:
+    using INHERITED = SkSVGContainer;
+};
+
+#endif // SkSVGHiddenContainer_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h
new file mode 100644
index 00000000..e78f28de
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGIDMapper.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGIDMapper_DEFINED
+#define SkSVGIDMapper_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "src/core/SkTHash.h"
+
+class SkString;
+class SkSVGNode;
+
+using SkSVGIDMapper = skia_private::THashMap<SkString, sk_sp<SkSVGNode>>;
+
+#endif // SkSVGIDMapper_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h
new file mode 100644
index 00000000..5b3146c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGImage.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGImage_DEFINED
+#define SkSVGImage_DEFINED
+
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+namespace skresources {
+class ResourceProvider;
+}
+
+class SK_API SkSVGImage final : public SkSVGTransformableNode {
+public:
+    static sk_sp<SkSVGImage> Make() {
+        return sk_sp<SkSVGImage>(new SkSVGImage());
+    }
+
+    void appendChild(sk_sp<SkSVGNode>) override {
+        SkDebugf("cannot append child nodes to this element.\n");
+    }
+
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+    void onRender(const SkSVGRenderContext&) const override;
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+    struct ImageInfo {
+        sk_sp<SkImage> fImage;
+        SkRect         fDst;
+    };
+    static ImageInfo LoadImage(const sk_sp<skresources::ResourceProvider>&,
+                               const SkSVGIRI&,
+                               const SkRect&,
+                               SkSVGPreserveAspectRatio);
+
+    SVG_ATTR(X                  , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Y                  , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Width              , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Height             , SkSVGLength             , SkSVGLength(0))
+    SVG_ATTR(Href               , SkSVGIRI                , SkSVGIRI())
+    SVG_ATTR(PreserveAspectRatio, SkSVGPreserveAspectRatio, SkSVGPreserveAspectRatio())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGImage() : INHERITED(SkSVGTag::kImage) {}
+
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif  // SkSVGImage_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h
new file mode 100644
index 00000000..c6b27481
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGLine.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGLine_DEFINED
+#define SkSVGLine_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+struct SkPoint;
+
+class SK_API SkSVGLine final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGLine> Make() { return sk_sp<SkSVGLine>(new SkSVGLine()); }
+
+    SVG_ATTR(X1, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y1, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(X2, SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y2, SkSVGLength, SkSVGLength(0))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGLine();
+
+    // resolve and return the two endpoints
+    std::tuple<SkPoint, SkPoint> resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGLine_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h
new file mode 100644
index 00000000..3efc46f5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGLinearGradient.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGLinearGradient_DEFINED
+#define SkSVGLinearGradient_DEFINED
+
+#include "modules/svg/include/SkSVGGradient.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGLinearGradient final : public SkSVGGradient {
+public:
+    static sk_sp<SkSVGLinearGradient> Make() {
+        return sk_sp<SkSVGLinearGradient>(new SkSVGLinearGradient());
+    }
+
+    SVG_ATTR(X1, SkSVGLength, SkSVGLength(0  , SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y1, SkSVGLength, SkSVGLength(0  , SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(X2, SkSVGLength, SkSVGLength(100, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y2, SkSVGLength, SkSVGLength(0  , SkSVGLength::Unit::kPercentage))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkShader> onMakeShader(const SkSVGRenderContext&,
+                                 const SkColor4f*, const SkScalar*, int count,
+                                 SkTileMode, const SkMatrix&) const override;
+private:
+    SkSVGLinearGradient();
+
+    using INHERITED = SkSVGGradient;
+};
+
+#endif // SkSVGLinearGradient_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h
new file mode 100644
index 00000000..1063c887
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGMask.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGMask_DEFINED
+#define SkSVGMask_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGMask final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGMask> Make() {
+        return sk_sp<SkSVGMask>(new SkSVGMask());
+    }
+
+    SVG_ATTR(X     , SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Y     , SkSVGLength, SkSVGLength(-10, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Width , SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Height, SkSVGLength, SkSVGLength(120, SkSVGLength::Unit::kPercentage))
+
+    SVG_ATTR(MaskUnits, SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox))
+    SVG_ATTR(MaskContentUnits, SkSVGObjectBoundingBoxUnits,
+             SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse))
+
+private:
+    friend class SkSVGRenderContext;
+
+    SkSVGMask() : INHERITED(SkSVGTag::kMask) {}
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    SkRect bounds(const SkSVGRenderContext&) const;
+    void renderMask(const SkSVGRenderContext&) const;
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGMask_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h
new file mode 100644
index 00000000..7759ddf5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGNode.h
@@ -0,0 +1,230 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGNode_DEFINED
+#define SkSVGNode_DEFINED
+
+#include "include/core/SkRefCnt.h"
+#include "modules/svg/include/SkSVGAttribute.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+
+class SkCanvas;
+class SkMatrix;
+class SkPaint;
+class SkPath;
+class SkSVGLengthContext;
+class SkSVGRenderContext;
+class SkSVGValue;
+
+enum class SkSVGTag {
+    kCircle,
+    kClipPath,
+    kDefs,
+    kEllipse,
+    kFeBlend,
+    kFeColorMatrix,
+    kFeComponentTransfer,
+    kFeComposite,
+    kFeDiffuseLighting,
+    kFeDisplacementMap,
+    kFeDistantLight,
+    kFeFlood,
+    kFeFuncA,
+    kFeFuncR,
+    kFeFuncG,
+    kFeFuncB,
+    kFeGaussianBlur,
+    kFeImage,
+    kFeMerge,
+    kFeMergeNode,
+    kFeMorphology,
+    kFeOffset,
+    kFePointLight,
+    kFeSpecularLighting,
+    kFeSpotLight,
+    kFeTurbulence,
+    kFilter,
+    kG,
+    kImage,
+    kLine,
+    kLinearGradient,
+    kMask,
+    kPath,
+    kPattern,
+    kPolygon,
+    kPolyline,
+    kRadialGradient,
+    kRect,
+    kStop,
+    kSvg,
+    kText,
+    kTextLiteral,
+    kTextPath,
+    kTSpan,
+    kUse
+};
+
+#define SVG_PRES_ATTR(attr_name, attr_type, attr_inherited)                  \
+private:                                                                     \
+    bool set##attr_name(SkSVGAttributeParser::ParseResult<                   \
+                            SkSVGProperty<attr_type, attr_inherited>>&& pr) {\
+        if (pr.isValid()) { this->set##attr_name(std::move(*pr)); }          \
+        return pr.isValid();                                                 \
+    }                                                                        \
+                                                                             \
+public:                                                                      \
+    const SkSVGProperty<attr_type, attr_inherited>& get##attr_name() const { \
+        return fPresentationAttributes.f##attr_name;                         \
+    }                                                                        \
+    void set##attr_name(const SkSVGProperty<attr_type, attr_inherited>& v) { \
+        auto* dest = &fPresentationAttributes.f##attr_name;                  \
+        if (!dest->isInheritable() || v.isValue()) {                         \
+            /* TODO: If dest is not inheritable, handle v == "inherit" */    \
+            *dest = v;                                                       \
+        } else {                                                             \
+            dest->set(SkSVGPropertyState::kInherit);                         \
+        }                                                                    \
+    }                                                                        \
+    void set##attr_name(SkSVGProperty<attr_type, attr_inherited>&& v) {      \
+        auto* dest = &fPresentationAttributes.f##attr_name;                  \
+        if (!dest->isInheritable() || v.isValue()) {                         \
+            /* TODO: If dest is not inheritable, handle v == "inherit" */    \
+            *dest = std::move(v);                                            \
+        } else {                                                             \
+            dest->set(SkSVGPropertyState::kInherit);                         \
+        }                                                                    \
+    }
+
+class SK_API SkSVGNode : public SkRefCnt {
+public:
+    ~SkSVGNode() override;
+
+    SkSVGTag tag() const { return fTag; }
+
+    virtual void appendChild(sk_sp<SkSVGNode>) = 0;
+
+    void render(const SkSVGRenderContext&) const;
+    bool asPaint(const SkSVGRenderContext&, SkPaint*) const;
+    SkPath asPath(const SkSVGRenderContext&) const;
+    SkRect objectBoundingBox(const SkSVGRenderContext&) const;
+
+    void setAttribute(SkSVGAttribute, const SkSVGValue&);
+    bool setAttribute(const char* attributeName, const char* attributeValue);
+
+    // TODO: consolidate with existing setAttribute
+    virtual bool parseAndSetAttribute(const char* name, const char* value);
+
+    // inherited
+    SVG_PRES_ATTR(ClipRule                 , SkSVGFillRule  , true)
+    SVG_PRES_ATTR(Color                    , SkSVGColorType , true)
+    SVG_PRES_ATTR(ColorInterpolation       , SkSVGColorspace, true)
+    SVG_PRES_ATTR(ColorInterpolationFilters, SkSVGColorspace, true)
+    SVG_PRES_ATTR(FillRule                 , SkSVGFillRule  , true)
+    SVG_PRES_ATTR(Fill                     , SkSVGPaint     , true)
+    SVG_PRES_ATTR(FillOpacity              , SkSVGNumberType, true)
+    SVG_PRES_ATTR(FontFamily               , SkSVGFontFamily, true)
+    SVG_PRES_ATTR(FontSize                 , SkSVGFontSize  , true)
+    SVG_PRES_ATTR(FontStyle                , SkSVGFontStyle , true)
+    SVG_PRES_ATTR(FontWeight               , SkSVGFontWeight, true)
+    SVG_PRES_ATTR(Stroke                   , SkSVGPaint     , true)
+    SVG_PRES_ATTR(StrokeDashArray          , SkSVGDashArray , true)
+    SVG_PRES_ATTR(StrokeDashOffset         , SkSVGLength    , true)
+    SVG_PRES_ATTR(StrokeLineCap            , SkSVGLineCap   , true)
+    SVG_PRES_ATTR(StrokeLineJoin           , SkSVGLineJoin  , true)
+    SVG_PRES_ATTR(StrokeMiterLimit         , SkSVGNumberType, true)
+    SVG_PRES_ATTR(StrokeOpacity            , SkSVGNumberType, true)
+    SVG_PRES_ATTR(StrokeWidth              , SkSVGLength    , true)
+    SVG_PRES_ATTR(TextAnchor               , SkSVGTextAnchor, true)
+    SVG_PRES_ATTR(Visibility               , SkSVGVisibility, true)
+
+    // not inherited
+    SVG_PRES_ATTR(ClipPath                 , SkSVGFuncIRI   , false)
+    SVG_PRES_ATTR(Display                  , SkSVGDisplay   , false)
+    SVG_PRES_ATTR(Mask                     , SkSVGFuncIRI   , false)
+    SVG_PRES_ATTR(Filter                   , SkSVGFuncIRI   , false)
+    SVG_PRES_ATTR(Opacity                  , SkSVGNumberType, false)
+    SVG_PRES_ATTR(StopColor                , SkSVGColor     , false)
+    SVG_PRES_ATTR(StopOpacity              , SkSVGNumberType, false)
+    SVG_PRES_ATTR(FloodColor               , SkSVGColor     , false)
+    SVG_PRES_ATTR(FloodOpacity             , SkSVGNumberType, false)
+    SVG_PRES_ATTR(LightingColor            , SkSVGColor     , false)
+
+protected:
+    SkSVGNode(SkSVGTag);
+
+    static SkMatrix ComputeViewboxMatrix(const SkRect&, const SkRect&, SkSVGPreserveAspectRatio);
+
+    // Called before onRender(), to apply local attributes to the context.  Unlike onRender(),
+    // onPrepareToRender() bubbles up the inheritance chain: overriders should always call
+    // INHERITED::onPrepareToRender(), unless they intend to short-circuit rendering
+    // (return false).
+    // Implementations are expected to return true if rendering is to continue, or false if
+    // the node/subtree rendering is disabled.
+    virtual bool onPrepareToRender(SkSVGRenderContext*) const;
+
+    virtual void onRender(const SkSVGRenderContext&) const = 0;
+
+    virtual bool onAsPaint(const SkSVGRenderContext&, SkPaint*) const { return false; }
+
+    virtual SkPath onAsPath(const SkSVGRenderContext&) const = 0;
+
+    virtual void onSetAttribute(SkSVGAttribute, const SkSVGValue&) {}
+
+    virtual bool hasChildren() const { return false; }
+
+    virtual SkRect onObjectBoundingBox(const SkSVGRenderContext&) const {
+        return SkRect::MakeEmpty();
+    }
+
+private:
+    SkSVGTag                    fTag;
+
+    // FIXME: this should be sparse
+    SkSVGPresentationAttributes fPresentationAttributes;
+
+    using INHERITED = SkRefCnt;
+};
+
+#undef SVG_PRES_ATTR // presentation attributes are only defined for the base class
+
+#define _SVG_ATTR_SETTERS(attr_name, attr_type, attr_default, set_cp, set_mv) \
+    private:                                                                  \
+        bool set##attr_name(                                                  \
+                const SkSVGAttributeParser::ParseResult<attr_type>& pr) {     \
+            if (pr.isValid()) { this->set##attr_name(*pr); }                  \
+            return pr.isValid();                                              \
+        }                                                                     \
+        bool set##attr_name(                                                  \
+                SkSVGAttributeParser::ParseResult<attr_type>&& pr) {          \
+            if (pr.isValid()) { this->set##attr_name(std::move(*pr)); }       \
+            return pr.isValid();                                              \
+        }                                                                     \
+    public:                                                                   \
+        void set##attr_name(const attr_type& a) { set_cp(a); }                \
+        void set##attr_name(attr_type&& a) { set_mv(std::move(a)); }
+
+#define SVG_ATTR(attr_name, attr_type, attr_default)                        \
+    private:                                                                \
+        attr_type f##attr_name = attr_default;                              \
+    public:                                                                 \
+        const attr_type& get##attr_name() const { return f##attr_name; }    \
+    _SVG_ATTR_SETTERS(                                                      \
+            attr_name, attr_type, attr_default,                             \
+            [this](const attr_type& a) { this->f##attr_name = a; },         \
+            [this](attr_type&& a) { this->f##attr_name = std::move(a); })
+
+#define SVG_OPTIONAL_ATTR(attr_name, attr_type)                                   \
+    private:                                                                      \
+        SkTLazy<attr_type> f##attr_name;                                          \
+    public:                                                                       \
+        const SkTLazy<attr_type>& get##attr_name() const { return f##attr_name; } \
+    _SVG_ATTR_SETTERS(                                                            \
+            attr_name, attr_type, attr_default,                                   \
+            [this](const attr_type& a) { this->f##attr_name.set(a); },            \
+            [this](attr_type&& a) { this->f##attr_name.set(std::move(a)); })
+
+#endif // SkSVGNode_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h
new file mode 100644
index 00000000..fb4f8304
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGOpenTypeSVGDecoder.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2022 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGOpenTypeSVGDecoder_DEFINED
+#define SkSVGOpenTypeSVGDecoder_DEFINED
+
+#include "include/core/SkColor.h"
+#include "include/core/SkOpenTypeSVGDecoder.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkTypes.h"
+
+class SkCanvas;
+class SkSVGDOM;
+
+class SkSVGOpenTypeSVGDecoder : public SkOpenTypeSVGDecoder {
+public:
+    static std::unique_ptr<SkOpenTypeSVGDecoder> Make(const uint8_t* svg, size_t svgLength);
+    size_t approximateSize() override;
+    bool render(SkCanvas&, int upem, SkGlyphID glyphId,
+                SkColor foregroundColor, SkSpan<SkColor> palette) override;
+    ~SkSVGOpenTypeSVGDecoder() override;
+private:
+    SkSVGOpenTypeSVGDecoder(sk_sp<SkSVGDOM> skSvg, size_t approximateSize);
+    sk_sp<SkSVGDOM> fSkSvg;
+    size_t fApproximateSize;
+};
+
+#endif  // SkSVGOpenTypeSVGDecoder_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h
new file mode 100644
index 00000000..77436d1f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGPath.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGPath_DEFINED
+#define SkSVGPath_DEFINED
+
+#include "include/core/SkPath.h"
+#include "modules/svg/include/SkSVGShape.h"
+
+class SK_API SkSVGPath final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGPath> Make() { return sk_sp<SkSVGPath>(new SkSVGPath()); }
+
+    SVG_ATTR(Path, SkPath, SkPath())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGPath();
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGPath_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h
new file mode 100644
index 00000000..57d934c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGPattern.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGPattern_DEFINED
+#define SkSVGPattern_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGRenderContext;
+
+class SK_API SkSVGPattern final : public SkSVGHiddenContainer {
+public:
+    static sk_sp<SkSVGPattern> Make() {
+        return sk_sp<SkSVGPattern>(new SkSVGPattern());
+    }
+
+    SVG_ATTR(Href, SkSVGIRI, SkSVGIRI())
+    SVG_OPTIONAL_ATTR(X               , SkSVGLength)
+    SVG_OPTIONAL_ATTR(Y               , SkSVGLength)
+    SVG_OPTIONAL_ATTR(Width           , SkSVGLength)
+    SVG_OPTIONAL_ATTR(Height          , SkSVGLength)
+    SVG_OPTIONAL_ATTR(PatternTransform, SkSVGTransformType)
+
+protected:
+    SkSVGPattern();
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    bool onAsPaint(const SkSVGRenderContext&, SkPaint*) const override;
+
+private:
+    struct PatternAttributes {
+        SkTLazy<SkSVGLength>        fX,
+                                    fY,
+                                    fWidth,
+                                    fHeight;
+        SkTLazy<SkSVGTransformType> fPatternTransform;
+    };
+
+    const SkSVGPattern* resolveHref(const SkSVGRenderContext&, PatternAttributes*) const;
+    const SkSVGPattern* hrefTarget(const SkSVGRenderContext&) const;
+
+    // TODO:
+    //   - patternUnits
+    //   - patternContentUnits
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGPattern_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h
new file mode 100644
index 00000000..949490af
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGPoly.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGPoly_DEFINED
+#define SkSVGPoly_DEFINED
+
+#include "include/core/SkPath.h"
+#include "modules/svg/include/SkSVGShape.h"
+
+// Handles <polygon> and <polyline> elements.
+class SK_API SkSVGPoly final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGPoly> MakePolygon() {
+        return sk_sp<SkSVGPoly>(new SkSVGPoly(SkSVGTag::kPolygon));
+    }
+
+    static sk_sp<SkSVGPoly> MakePolyline() {
+        return sk_sp<SkSVGPoly>(new SkSVGPoly(SkSVGTag::kPolyline));
+    }
+
+    SVG_ATTR(Points, SkSVGPointsType, SkSVGPointsType())
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGPoly(SkSVGTag);
+
+    mutable SkPath fPath;  // mutated in onDraw(), to apply inherited fill types.
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGPoly_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h
new file mode 100644
index 00000000..9b25c436
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGRadialGradient.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRadialGradient_DEFINED
+#define SkSVGRadialGradient_DEFINED
+
+#include "modules/svg/include/SkSVGGradient.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGRadialGradient final : public SkSVGGradient {
+public:
+    static sk_sp<SkSVGRadialGradient> Make() {
+        return sk_sp<SkSVGRadialGradient>(new SkSVGRadialGradient());
+    }
+
+    SVG_ATTR(Cx, SkSVGLength, SkSVGLength(50, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Cy, SkSVGLength, SkSVGLength(50, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(R,  SkSVGLength, SkSVGLength(50, SkSVGLength::Unit::kPercentage))
+    SVG_OPTIONAL_ATTR(Fx, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Fy, SkSVGLength)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    sk_sp<SkShader> onMakeShader(const SkSVGRenderContext&,
+                                 const SkColor4f*, const SkScalar*, int count,
+                                 SkTileMode, const SkMatrix&) const override;
+private:
+    SkSVGRadialGradient();
+
+    using INHERITED = SkSVGGradient;
+};
+
+#endif // SkSVGRadialGradient_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h
new file mode 100644
index 00000000..d2983a19
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGRect.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRect_DEFINED
+#define SkSVGRect_DEFINED
+
+#include "modules/svg/include/SkSVGShape.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkRRect;
+
+class SK_API SkSVGRect final : public SkSVGShape {
+public:
+    static sk_sp<SkSVGRect> Make() { return sk_sp<SkSVGRect>(new SkSVGRect()); }
+
+    SVG_ATTR(X     , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y     , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Width , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Height, SkSVGLength, SkSVGLength(0))
+
+    SVG_OPTIONAL_ATTR(Rx, SkSVGLength)
+    SVG_OPTIONAL_ATTR(Ry, SkSVGLength)
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                SkPathFillType) const override;
+
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGRect();
+
+    SkRRect resolve(const SkSVGLengthContext&) const;
+
+    using INHERITED = SkSVGShape;
+};
+
+#endif // SkSVGRect_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h
new file mode 100644
index 00000000..1a0c067f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGRenderContext.h
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRenderContext_DEFINED
+#define SkSVGRenderContext_DEFINED
+
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkM44.h"
+#include "include/core/SkPaint.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkRect.h"
+#include "include/core/SkSize.h"
+#include "include/core/SkTypes.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+#include "modules/svg/include/SkSVGAttribute.h"
+#include "modules/svg/include/SkSVGIDMapper.h"
+#include "src/base/SkTLazy.h"
+#include "src/core/SkTHash.h"
+
+class SkCanvas;
+class SkSVGLength;
+
+class SK_API SkSVGLengthContext {
+public:
+    SkSVGLengthContext(const SkSize& viewport, SkScalar dpi = 90)
+        : fViewport(viewport), fDPI(dpi) {}
+
+    enum class LengthType {
+        kHorizontal,
+        kVertical,
+        kOther,
+    };
+
+    const SkSize& viewPort() const { return fViewport; }
+    void setViewPort(const SkSize& viewport) { fViewport = viewport; }
+
+    SkScalar resolve(const SkSVGLength&, LengthType) const;
+    SkRect   resolveRect(const SkSVGLength& x, const SkSVGLength& y,
+                         const SkSVGLength& w, const SkSVGLength& h) const;
+
+private:
+    SkSize   fViewport;
+    SkScalar fDPI;
+};
+
+struct SK_API SkSVGPresentationContext {
+    SkSVGPresentationContext();
+    SkSVGPresentationContext(const SkSVGPresentationContext&)            = default;
+    SkSVGPresentationContext& operator=(const SkSVGPresentationContext&) = default;
+
+    const skia_private::THashMap<SkString, SkSVGColorType>* fNamedColors = nullptr;
+
+    // Inherited presentation attributes, computed for the current node.
+    SkSVGPresentationAttributes fInherited;
+};
+
+class SK_API SkSVGRenderContext {
+public:
+    // Captures data required for object bounding box resolution.
+    struct OBBScope {
+        const SkSVGNode*          fNode;
+        const SkSVGRenderContext* fCtx;
+    };
+
+    SkSVGRenderContext(SkCanvas*,
+                       const sk_sp<SkFontMgr>&,
+                       const sk_sp<skresources::ResourceProvider>&,
+                       const SkSVGIDMapper&,
+                       const SkSVGLengthContext&,
+                       const SkSVGPresentationContext&,
+                       const OBBScope&,
+                       const sk_sp<SkShapers::Factory>&);
+    SkSVGRenderContext(const SkSVGRenderContext&);
+    SkSVGRenderContext(const SkSVGRenderContext&, SkCanvas*);
+    // Establish a new OBB scope.  Normally used when entering a node's render scope.
+    SkSVGRenderContext(const SkSVGRenderContext&, const SkSVGNode*);
+    ~SkSVGRenderContext();
+
+    const SkSVGLengthContext& lengthContext() const { return *fLengthContext; }
+    SkSVGLengthContext* writableLengthContext() { return fLengthContext.writable(); }
+
+    const SkSVGPresentationContext& presentationContext() const { return *fPresentationContext; }
+
+    SkCanvas* canvas() const { return fCanvas; }
+    void saveOnce();
+
+    enum ApplyFlags {
+        kLeaf = 1 << 0, // the target node doesn't have descendants
+    };
+    void applyPresentationAttributes(const SkSVGPresentationAttributes&, uint32_t flags);
+
+    // Scoped wrapper that temporarily clears the original node reference.
+    class BorrowedNode {
+    public:
+        explicit BorrowedNode(sk_sp<SkSVGNode>* node)
+            : fOwner(node) {
+            if (fOwner) {
+                fBorrowed = std::move(*fOwner);
+                *fOwner = nullptr;
+            }
+        }
+
+        ~BorrowedNode() {
+            if (fOwner) {
+                *fOwner = std::move(fBorrowed);
+            }
+        }
+
+        const SkSVGNode* get() const { return fBorrowed.get(); }
+        const SkSVGNode* operator->() const { return fBorrowed.get(); }
+        const SkSVGNode& operator*() const { return *fBorrowed; }
+
+        explicit operator bool() const { return !!fBorrowed; }
+
+    private:
+        // noncopyable
+        BorrowedNode(const BorrowedNode&)      = delete;
+        BorrowedNode& operator=(BorrowedNode&) = delete;
+
+        sk_sp<SkSVGNode>* fOwner;
+        sk_sp<SkSVGNode>  fBorrowed;
+    };
+
+    // Note: the id->node association is cleared for the lifetime of the returned value
+    // (effectively breaks reference cycles, assuming appropriate return value scoping).
+    BorrowedNode findNodeById(const SkSVGIRI&) const;
+
+    SkTLazy<SkPaint> fillPaint() const;
+    SkTLazy<SkPaint> strokePaint() const;
+
+    SkSVGColorType resolveSvgColor(const SkSVGColor&) const;
+
+    // The local computed clip path (not inherited).
+    const SkPath* clipPath() const { return fClipPath.getMaybeNull(); }
+
+    const sk_sp<skresources::ResourceProvider>& resourceProvider() const {
+        return fResourceProvider;
+    }
+
+    sk_sp<SkFontMgr> fontMgr() const {
+        // It is probably an oversight to try to render <text> without having set the SkFontMgr.
+        // We will assert this in debug mode, but fallback to an empty fontmgr in release builds.
+        SkASSERT(fFontMgr);
+        return fFontMgr ? fFontMgr : SkFontMgr::RefEmpty();
+    }
+
+    // Returns the translate/scale transformation required to map into the current OBB scope,
+    // with the specified units.
+    struct OBBTransform {
+        SkV2 offset, scale;
+    };
+    OBBTransform transformForCurrentOBB(SkSVGObjectBoundingBoxUnits) const;
+
+    SkRect resolveOBBRect(const SkSVGLength& x, const SkSVGLength& y,
+                          const SkSVGLength& w, const SkSVGLength& h,
+                          SkSVGObjectBoundingBoxUnits) const;
+
+    std::unique_ptr<SkShaper> makeShaper() const {
+        SkASSERT(fTextShapingFactory);
+        return fTextShapingFactory->makeShaper(this->fontMgr());
+    }
+
+    std::unique_ptr<SkShaper::BiDiRunIterator> makeBidiRunIterator(const char* utf8,
+                                                                   size_t utf8Bytes,
+                                                                   uint8_t bidiLevel) const {
+        SkASSERT(fTextShapingFactory);
+        return fTextShapingFactory->makeBidiRunIterator(utf8, utf8Bytes, bidiLevel);
+    }
+
+    std::unique_ptr<SkShaper::ScriptRunIterator> makeScriptRunIterator(const char* utf8,
+                                                                       size_t utf8Bytes) const {
+        SkASSERT(fTextShapingFactory);
+        constexpr SkFourByteTag unknownScript = SkSetFourByteTag('Z', 'z', 'z', 'z');
+        return fTextShapingFactory->makeScriptRunIterator(utf8, utf8Bytes, unknownScript);
+    }
+
+private:
+    // Stack-only
+    void* operator new(size_t)                               = delete;
+    void* operator new(size_t, void*)                        = delete;
+    SkSVGRenderContext& operator=(const SkSVGRenderContext&) = delete;
+
+    void applyOpacity(SkScalar opacity, uint32_t flags, bool hasFilter);
+    void applyFilter(const SkSVGFuncIRI&);
+    void applyClip(const SkSVGFuncIRI&);
+    void applyMask(const SkSVGFuncIRI&);
+
+    SkTLazy<SkPaint> commonPaint(const SkSVGPaint&, float opacity) const;
+
+    const sk_sp<SkFontMgr>&                       fFontMgr;
+    const sk_sp<SkShapers::Factory>&              fTextShapingFactory;
+    const sk_sp<skresources::ResourceProvider>&   fResourceProvider;
+    const SkSVGIDMapper&                          fIDMapper;
+    SkTCopyOnFirstWrite<SkSVGLengthContext>       fLengthContext;
+    SkTCopyOnFirstWrite<SkSVGPresentationContext> fPresentationContext;
+    SkCanvas*                                     fCanvas;
+    // The save count on 'fCanvas' at construction time.
+    // A restoreToCount() will be issued on destruction.
+    int                                           fCanvasSaveCount;
+
+    // clipPath, if present for the current context (not inherited).
+    SkTLazy<SkPath>                               fClipPath;
+
+    // Deferred opacity optimization for leaf nodes.
+    float                                         fDeferredPaintOpacity = 1;
+
+    // Current object bounding box scope.
+    const OBBScope                                fOBBScope;
+};
+
+#endif // SkSVGRenderContext_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h
new file mode 100644
index 00000000..b45555b1
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGSVG.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGSVG_DEFINED
+#define SkSVGSVG_DEFINED
+
+#include "modules/svg/include/SkSVGContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkTLazy.h"
+
+class SkSVGLengthContext;
+
+class SK_API SkSVGSVG : public SkSVGContainer {
+public:
+    enum class Type {
+        kRoot,
+        kInner,
+    };
+    static sk_sp<SkSVGSVG> Make(Type t = Type::kInner) { return sk_sp<SkSVGSVG>(new SkSVGSVG(t)); }
+
+    SVG_ATTR(X                  , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y                  , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Width              , SkSVGLength, SkSVGLength(100, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(Height             , SkSVGLength, SkSVGLength(100, SkSVGLength::Unit::kPercentage))
+    SVG_ATTR(PreserveAspectRatio, SkSVGPreserveAspectRatio, SkSVGPreserveAspectRatio())
+
+    SVG_OPTIONAL_ATTR(ViewBox, SkSVGViewBoxType)
+
+    SkSize intrinsicSize(const SkSVGLengthContext&) const;
+
+    void renderNode(const SkSVGRenderContext&, const SkSVGIRI& iri) const;
+
+protected:
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+
+    void onSetAttribute(SkSVGAttribute, const SkSVGValue&) override;
+
+private:
+    explicit SkSVGSVG(Type t)
+        : INHERITED(SkSVGTag::kSvg)
+        , fType(t)
+    {}
+
+    // Some attributes behave differently for the outermost svg element.
+    const Type fType;
+
+    using INHERITED = SkSVGContainer;
+};
+
+#endif // SkSVGSVG_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h
new file mode 100644
index 00000000..49d7a621
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGShape.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGShape_DEFINED
+#define SkSVGShape_DEFINED
+
+#include "include/core/SkPath.h"
+#include "modules/svg/include/SkSVGTransformableNode.h"
+
+class SkSVGLengthContext;
+class SkPaint;
+
+class SK_API SkSVGShape : public SkSVGTransformableNode {
+public:
+    void appendChild(sk_sp<SkSVGNode>) override;
+
+protected:
+    SkSVGShape(SkSVGTag);
+
+    void onRender(const SkSVGRenderContext&) const final;
+
+    virtual void onDraw(SkCanvas*, const SkSVGLengthContext&, const SkPaint&,
+                        SkPathFillType) const = 0;
+
+private:
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif // SkSVGShape_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h
new file mode 100644
index 00000000..8a3a7f66
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGStop.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGStop_DEFINED
+#define SkSVGStop_DEFINED
+
+#include "modules/svg/include/SkSVGHiddenContainer.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SkSVGLengthContext;
+
+class SK_API SkSVGStop : public SkSVGHiddenContainer {
+public:
+    static constexpr SkSVGTag tag = SkSVGTag::kStop;
+
+    static sk_sp<SkSVGStop> Make() {
+        return sk_sp<SkSVGStop>(new SkSVGStop());
+    }
+
+    SVG_ATTR(Offset, SkSVGLength, SkSVGLength(0, SkSVGLength::Unit::kPercentage))
+
+protected:
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    SkSVGStop();
+
+    using INHERITED = SkSVGHiddenContainer;
+};
+
+#endif // SkSVGStop_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGText.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGText.h
new file mode 100644
index 00000000..a9aca608
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGText.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2019 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGText_DEFINED
+#define SkSVGText_DEFINED
+
+#include <vector>
+
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGTextContext;
+
+// Base class for text-rendering nodes.
+class SkSVGTextFragment : public SkSVGTransformableNode {
+public:
+    void renderText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const;
+
+protected:
+    explicit SkSVGTextFragment(SkSVGTag t) : INHERITED(t) {}
+
+    virtual void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const = 0;
+
+    // Text nodes other than the root <text> element are not rendered directly.
+    void onRender(const SkSVGRenderContext&) const override {}
+
+private:
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    using INHERITED = SkSVGTransformableNode;
+};
+
+// Base class for nestable text containers (<text>, <tspan>, etc).
+class SkSVGTextContainer : public SkSVGTextFragment {
+public:
+    SVG_ATTR(X, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Y, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Dx, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Dy, std::vector<SkSVGLength>, {})
+    SVG_ATTR(Rotate, std::vector<SkSVGNumberType>, {})
+
+    SVG_ATTR(XmlSpace, SkSVGXmlSpace, SkSVGXmlSpace::kDefault)
+
+    void appendChild(sk_sp<SkSVGNode>) final;
+
+protected:
+    explicit SkSVGTextContainer(SkSVGTag t) : INHERITED(t) {}
+
+    void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const override;
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+private:
+    std::vector<sk_sp<SkSVGTextFragment>> fChildren;
+
+    using INHERITED = SkSVGTextFragment;
+};
+
+class SkSVGText final : public SkSVGTextContainer {
+public:
+    static sk_sp<SkSVGText> Make() { return sk_sp<SkSVGText>(new SkSVGText()); }
+
+private:
+    SkSVGText() : INHERITED(SkSVGTag::kText) {}
+
+    void onRender(const SkSVGRenderContext&) const override;
+
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+
+    using INHERITED = SkSVGTextContainer;
+};
+
+class SkSVGTSpan final : public SkSVGTextContainer {
+public:
+    static sk_sp<SkSVGTSpan> Make() { return sk_sp<SkSVGTSpan>(new SkSVGTSpan()); }
+
+private:
+    SkSVGTSpan() : INHERITED(SkSVGTag::kTSpan) {}
+
+    using INHERITED = SkSVGTextContainer;
+};
+
+class SkSVGTextLiteral final : public SkSVGTextFragment {
+public:
+    static sk_sp<SkSVGTextLiteral> Make() {
+        return sk_sp<SkSVGTextLiteral>(new SkSVGTextLiteral());
+    }
+
+    SVG_ATTR(Text, SkSVGStringType, SkSVGStringType())
+
+private:
+    SkSVGTextLiteral() : INHERITED(SkSVGTag::kTextLiteral) {}
+
+    void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const override;
+
+    void appendChild(sk_sp<SkSVGNode>) override {}
+
+    using INHERITED = SkSVGTextFragment;
+};
+
+class SkSVGTextPath final : public SkSVGTextContainer {
+public:
+    static sk_sp<SkSVGTextPath> Make() { return sk_sp<SkSVGTextPath>(new SkSVGTextPath()); }
+
+    SVG_ATTR(Href       , SkSVGIRI   , {}  )
+    SVG_ATTR(StartOffset, SkSVGLength, SkSVGLength(0))
+
+private:
+    SkSVGTextPath() : INHERITED(SkSVGTag::kTextPath) {}
+
+    void onShapeText(const SkSVGRenderContext&, SkSVGTextContext*, SkSVGXmlSpace) const override;
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGTextContainer;
+};
+
+#endif  // SkSVGText_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h
new file mode 100644
index 00000000..bb74e288
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGTransformableNode.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGTransformableNode_DEFINED
+#define SkSVGTransformableNode_DEFINED
+
+#include "include/core/SkMatrix.h"
+#include "modules/svg/include/SkSVGNode.h"
+
+class SK_API SkSVGTransformableNode : public SkSVGNode {
+public:
+    void setTransform(const SkSVGTransformType& t) { fTransform = t; }
+
+protected:
+    SkSVGTransformableNode(SkSVGTag);
+
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+
+    void onSetAttribute(SkSVGAttribute, const SkSVGValue&) override;
+
+    void mapToParent(SkPath*) const;
+
+    void mapToParent(SkRect*) const;
+
+private:
+    // FIXME: should be sparse
+    SkSVGTransformType fTransform;
+
+    using INHERITED = SkSVGNode;
+};
+
+#endif // SkSVGTransformableNode_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h
new file mode 100644
index 00000000..f03d8c27
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGTypes.h
@@ -0,0 +1,740 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGTypes_DEFINED
+#define SkSVGTypes_DEFINED
+
+#include "include/core/SkColor.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkPoint.h"
+#include "include/core/SkRect.h"
+#include "include/core/SkRefCnt.h"
+#include "include/core/SkScalar.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkString.h"
+#include "include/core/SkTypes.h"
+
+#include <optional>
+#include <vector>
+
+using SkSVGColorType     = SkColor;
+using SkSVGIntegerType   = int;
+using SkSVGNumberType    = SkScalar;
+using SkSVGStringType    = SkString;
+using SkSVGViewBoxType   = SkRect;
+using SkSVGTransformType = SkMatrix;
+using SkSVGPointsType    = std::vector<SkPoint>;
+
+enum class SkSVGPropertyState {
+    kUnspecified,
+    kInherit,
+    kValue,
+};
+
+// https://www.w3.org/TR/SVG11/intro.html#TermProperty
+template <typename T, bool kInheritable> class SkSVGProperty {
+public:
+    using ValueT = T;
+
+    SkSVGProperty() : fState(SkSVGPropertyState::kUnspecified) {}
+
+    explicit SkSVGProperty(SkSVGPropertyState state) : fState(state) {}
+
+    explicit SkSVGProperty(const T& value) : fState(SkSVGPropertyState::kValue) {
+        fValue = value;
+    }
+
+    explicit SkSVGProperty(T&& value) : fState(SkSVGPropertyState::kValue) {
+        fValue = std::move(value);
+    }
+
+    template <typename... Args>
+    void init(Args&&... args) {
+        fState = SkSVGPropertyState::kValue;
+        fValue.emplace(std::forward<Args>(args)...);
+    }
+
+    constexpr bool isInheritable() const { return kInheritable; }
+
+    bool isValue() const { return fState == SkSVGPropertyState::kValue; }
+
+    T* getMaybeNull() const {
+        return fValue.has_value() ? &fValue.value() : nullptr;
+    }
+
+    void set(SkSVGPropertyState state) {
+        fState = state;
+        if (fState != SkSVGPropertyState::kValue) {
+            fValue.reset();
+        }
+    }
+
+    void set(const T& value) {
+        fState = SkSVGPropertyState::kValue;
+        fValue = value;
+    }
+
+    void set(T&& value) {
+        fState = SkSVGPropertyState::kValue;
+        fValue = std::move(value);
+    }
+
+    T* operator->() {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return &fValue.value();
+    }
+
+    const T* operator->() const {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return &fValue.value();
+    }
+
+    T& operator*() {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return *fValue;
+    }
+
+    const T& operator*() const {
+        SkASSERT(fState == SkSVGPropertyState::kValue);
+        SkASSERT(fValue.has_value());
+        return *fValue;
+    }
+
+private:
+    SkSVGPropertyState fState;
+    std::optional<T>   fValue;
+};
+
+class SK_API SkSVGLength {
+public:
+    enum class Unit {
+        kUnknown,
+        kNumber,
+        kPercentage,
+        kEMS,
+        kEXS,
+        kPX,
+        kCM,
+        kMM,
+        kIN,
+        kPT,
+        kPC,
+    };
+
+    constexpr SkSVGLength()                    : fValue(0), fUnit(Unit::kUnknown) {}
+    explicit constexpr SkSVGLength(SkScalar v, Unit u = Unit::kNumber)
+        : fValue(v), fUnit(u) {}
+    SkSVGLength(const SkSVGLength&)            = default;
+    SkSVGLength& operator=(const SkSVGLength&) = default;
+
+    bool operator==(const SkSVGLength& other) const {
+        return fUnit == other.fUnit && fValue == other.fValue;
+    }
+    bool operator!=(const SkSVGLength& other) const { return !(*this == other); }
+
+    const SkScalar& value() const { return fValue; }
+    const Unit&     unit()  const { return fUnit;  }
+
+private:
+    SkScalar fValue;
+    Unit     fUnit;
+};
+
+// https://www.w3.org/TR/SVG11/linking.html#IRIReference
+class SK_API SkSVGIRI {
+public:
+    enum class Type {
+        kLocal,
+        kNonlocal,
+        kDataURI,
+    };
+
+    SkSVGIRI() : fType(Type::kLocal) {}
+    SkSVGIRI(Type t, const SkSVGStringType& iri) : fType(t), fIRI(iri) {}
+
+    Type type() const { return fType; }
+    const SkSVGStringType& iri() const { return fIRI; }
+
+    bool operator==(const SkSVGIRI& other) const {
+        return fType == other.fType && fIRI == other.fIRI;
+    }
+    bool operator!=(const SkSVGIRI& other) const { return !(*this == other); }
+
+private:
+    Type fType;
+    SkSVGStringType fIRI;
+};
+
+// https://www.w3.org/TR/SVG11/types.html#InterfaceSVGColor
+class SK_API SkSVGColor {
+public:
+    enum class Type {
+        kCurrentColor,
+        kColor,
+        kICCColor,
+    };
+    using Vars = std::vector<SkString>;
+
+    SkSVGColor() : SkSVGColor(SK_ColorBLACK) {}
+    explicit SkSVGColor(const SkSVGColorType& c) : fType(Type::kColor), fColor(c), fVars(nullptr) {}
+    explicit SkSVGColor(Type t, Vars&& vars)
+        : fType(t), fColor(SK_ColorBLACK)
+        , fVars(vars.empty() ? nullptr : new RefCntVars(std::move(vars))) {}
+    explicit SkSVGColor(const SkSVGColorType& c, Vars&& vars)
+        : fType(Type::kColor), fColor(c)
+        , fVars(vars.empty() ? nullptr : new RefCntVars(std::move(vars))) {}
+
+    SkSVGColor(const SkSVGColor&)            = default;
+    SkSVGColor& operator=(const SkSVGColor&) = default;
+    SkSVGColor(SkSVGColor&&)                 = default;
+    SkSVGColor& operator=(SkSVGColor&&)      = default;
+
+    bool operator==(const SkSVGColor& other) const {
+        return fType == other.fType && fColor == other.fColor && fVars == other.fVars;
+    }
+    bool operator!=(const SkSVGColor& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGColorType& color() const { SkASSERT(fType == Type::kColor); return fColor; }
+    SkSpan<const SkString> vars() const {
+        return fVars ? SkSpan<const SkString>(fVars->fData) : SkSpan<const SkString>();
+    }
+    SkSpan<SkString> vars()       {
+        return fVars ? SkSpan<SkString>(fVars->fData) : SkSpan<SkString>();
+    }
+
+private:
+    Type fType;
+    SkSVGColorType fColor;
+    struct RefCntVars : public SkNVRefCnt<RefCntVars> {
+        RefCntVars(Vars&& vars) : fData(std::move(vars)) {}
+        Vars fData;
+    };
+    sk_sp<RefCntVars> fVars;
+};
+
+class SK_API SkSVGPaint {
+public:
+    enum class Type {
+        kNone,
+        kColor,
+        kIRI,
+    };
+
+    SkSVGPaint() : fType(Type::kNone), fColor(SK_ColorBLACK) {}
+    explicit SkSVGPaint(Type t) : fType(t), fColor(SK_ColorBLACK) {}
+    explicit SkSVGPaint(SkSVGColor c) : fType(Type::kColor), fColor(std::move(c)) {}
+    SkSVGPaint(const SkSVGIRI& iri, SkSVGColor fallback_color)
+        : fType(Type::kIRI), fColor(std::move(fallback_color)), fIRI(iri) {}
+
+    SkSVGPaint(const SkSVGPaint&)            = default;
+    SkSVGPaint& operator=(const SkSVGPaint&) = default;
+    SkSVGPaint(SkSVGPaint&&)                 = default;
+    SkSVGPaint& operator=(SkSVGPaint&&)      = default;
+
+    bool operator==(const SkSVGPaint& other) const {
+        return fType == other.fType && fColor == other.fColor && fIRI == other.fIRI;
+    }
+    bool operator!=(const SkSVGPaint& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGColor& color() const {
+        SkASSERT(fType == Type::kColor || fType == Type::kIRI);
+        return fColor;
+    }
+    const SkSVGIRI& iri() const { SkASSERT(fType == Type::kIRI); return fIRI; }
+
+private:
+    Type fType;
+
+    // Logical union.
+    SkSVGColor fColor;
+    SkSVGIRI   fIRI;
+};
+
+// <funciri> | none (used for clip/mask/filter properties)
+class SK_API SkSVGFuncIRI {
+public:
+    enum class Type {
+        kNone,
+        kIRI,
+    };
+
+    SkSVGFuncIRI() : fType(Type::kNone) {}
+    explicit SkSVGFuncIRI(Type t) : fType(t) {}
+    explicit SkSVGFuncIRI(SkSVGIRI&& iri) : fType(Type::kIRI), fIRI(std::move(iri)) {}
+
+    bool operator==(const SkSVGFuncIRI& other) const {
+        return fType == other.fType && fIRI == other.fIRI;
+    }
+    bool operator!=(const SkSVGFuncIRI& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGIRI& iri() const { SkASSERT(fType == Type::kIRI); return fIRI; }
+
+private:
+    Type           fType;
+    SkSVGIRI       fIRI;
+};
+
+enum class SkSVGLineCap {
+    kButt,
+    kRound,
+    kSquare,
+};
+
+class SK_API SkSVGLineJoin {
+public:
+    enum class Type {
+        kMiter,
+        kRound,
+        kBevel,
+        kInherit,
+    };
+
+    constexpr SkSVGLineJoin() : fType(Type::kInherit) {}
+    constexpr explicit SkSVGLineJoin(Type t) : fType(t) {}
+
+    SkSVGLineJoin(const SkSVGLineJoin&)            = default;
+    SkSVGLineJoin& operator=(const SkSVGLineJoin&) = default;
+
+    bool operator==(const SkSVGLineJoin& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGLineJoin& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGSpreadMethod {
+public:
+    // These values must match Skia's SkShader::TileMode enum.
+    enum class Type {
+        kPad,       // kClamp_TileMode
+        kRepeat,    // kRepeat_TileMode
+        kReflect,   // kMirror_TileMode
+    };
+
+    constexpr SkSVGSpreadMethod() : fType(Type::kPad) {}
+    constexpr explicit SkSVGSpreadMethod(Type t) : fType(t) {}
+
+    SkSVGSpreadMethod(const SkSVGSpreadMethod&)            = default;
+    SkSVGSpreadMethod& operator=(const SkSVGSpreadMethod&) = default;
+
+    bool operator==(const SkSVGSpreadMethod& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGSpreadMethod& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGFillRule {
+public:
+    enum class Type {
+        kNonZero,
+        kEvenOdd,
+        kInherit,
+    };
+
+    constexpr SkSVGFillRule() : fType(Type::kInherit) {}
+    constexpr explicit SkSVGFillRule(Type t) : fType(t) {}
+
+    SkSVGFillRule(const SkSVGFillRule&)            = default;
+    SkSVGFillRule& operator=(const SkSVGFillRule&) = default;
+
+    bool operator==(const SkSVGFillRule& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGFillRule& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    SkPathFillType asFillType() const {
+        SkASSERT(fType != Type::kInherit); // should never be called for unresolved values.
+        return fType == Type::kEvenOdd ? SkPathFillType::kEvenOdd : SkPathFillType::kWinding;
+    }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGVisibility {
+public:
+    enum class Type {
+        kVisible,
+        kHidden,
+        kCollapse,
+        kInherit,
+    };
+
+    constexpr SkSVGVisibility() : fType(Type::kVisible) {}
+    constexpr explicit SkSVGVisibility(Type t) : fType(t) {}
+
+    SkSVGVisibility(const SkSVGVisibility&)            = default;
+    SkSVGVisibility& operator=(const SkSVGVisibility&) = default;
+
+    bool operator==(const SkSVGVisibility& other) const { return fType == other.fType; }
+    bool operator!=(const SkSVGVisibility& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGDashArray {
+public:
+    enum class Type {
+        kNone,
+        kDashArray,
+        kInherit,
+    };
+
+    SkSVGDashArray()                : fType(Type::kNone) {}
+    explicit SkSVGDashArray(Type t) : fType(t) {}
+    explicit SkSVGDashArray(std::vector<SkSVGLength>&& dashArray)
+        : fType(Type::kDashArray)
+        , fDashArray(std::move(dashArray)) {}
+
+    SkSVGDashArray(const SkSVGDashArray&)            = default;
+    SkSVGDashArray& operator=(const SkSVGDashArray&) = default;
+
+    bool operator==(const SkSVGDashArray& other) const {
+        return fType == other.fType && fDashArray == other.fDashArray;
+    }
+    bool operator!=(const SkSVGDashArray& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    const std::vector<SkSVGLength>& dashArray() const { return fDashArray; }
+
+private:
+    Type fType;
+    std::vector<SkSVGLength> fDashArray;
+};
+
+class SK_API SkSVGStopColor {
+public:
+    enum class Type {
+        kColor,
+        kCurrentColor,
+        kICCColor,
+        kInherit,
+    };
+
+    SkSVGStopColor() : fType(Type::kColor), fColor(SK_ColorBLACK) {}
+    explicit SkSVGStopColor(Type t) : fType(t), fColor(SK_ColorBLACK) {}
+    explicit SkSVGStopColor(const SkSVGColorType& c) : fType(Type::kColor), fColor(c) {}
+
+    SkSVGStopColor(const SkSVGStopColor&)            = default;
+    SkSVGStopColor& operator=(const SkSVGStopColor&) = default;
+
+    bool operator==(const SkSVGStopColor& other) const {
+        return fType == other.fType && fColor == other.fColor;
+    }
+    bool operator!=(const SkSVGStopColor& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+    const SkSVGColorType& color() const { SkASSERT(fType == Type::kColor); return fColor; }
+
+private:
+    Type fType;
+    SkSVGColorType fColor;
+};
+
+class SK_API SkSVGObjectBoundingBoxUnits {
+public:
+    enum class Type {
+        kUserSpaceOnUse,
+        kObjectBoundingBox,
+    };
+
+    SkSVGObjectBoundingBoxUnits() : fType(Type::kUserSpaceOnUse) {}
+    explicit SkSVGObjectBoundingBoxUnits(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGObjectBoundingBoxUnits& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGObjectBoundingBoxUnits& other) const {
+        return !(*this == other);
+    }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGFontFamily {
+public:
+    enum class Type {
+        kFamily,
+        kInherit,
+    };
+
+    SkSVGFontFamily() : fType(Type::kInherit) {}
+    explicit SkSVGFontFamily(const char family[])
+        : fType(Type::kFamily)
+        , fFamily(family) {}
+
+    bool operator==(const SkSVGFontFamily& other) const {
+        return fType == other.fType && fFamily == other.fFamily;
+    }
+    bool operator!=(const SkSVGFontFamily& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    const SkString& family() const { return fFamily; }
+
+private:
+    Type     fType;
+    SkString fFamily;
+};
+
+class SK_API SkSVGFontStyle {
+public:
+    enum class Type {
+        kNormal,
+        kItalic,
+        kOblique,
+        kInherit,
+    };
+
+    SkSVGFontStyle() : fType(Type::kInherit) {}
+    explicit SkSVGFontStyle(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGFontStyle& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGFontStyle& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+class SK_API SkSVGFontSize {
+public:
+    enum class Type {
+        kLength,
+        kInherit,
+    };
+
+    SkSVGFontSize() : fType(Type::kInherit), fSize(0) {}
+    explicit SkSVGFontSize(const SkSVGLength& s)
+        : fType(Type::kLength)
+        , fSize(s) {}
+
+    bool operator==(const SkSVGFontSize& other) const {
+        return fType == other.fType && fSize == other.fSize;
+    }
+    bool operator!=(const SkSVGFontSize& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+    const SkSVGLength& size() const { return fSize; }
+
+private:
+    Type        fType;
+    SkSVGLength fSize;
+};
+
+class SK_API SkSVGFontWeight {
+public:
+    enum class Type {
+        k100,
+        k200,
+        k300,
+        k400,
+        k500,
+        k600,
+        k700,
+        k800,
+        k900,
+        kNormal,
+        kBold,
+        kBolder,
+        kLighter,
+        kInherit,
+    };
+
+    SkSVGFontWeight() : fType(Type::kInherit) {}
+    explicit SkSVGFontWeight(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGFontWeight& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGFontWeight& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+struct SK_API SkSVGPreserveAspectRatio {
+    enum Align : uint8_t {
+        // These values are chosen such that bits [0,1] encode X alignment, and
+        // bits [2,3] encode Y alignment.
+        kXMinYMin = 0x00,
+        kXMidYMin = 0x01,
+        kXMaxYMin = 0x02,
+        kXMinYMid = 0x04,
+        kXMidYMid = 0x05,
+        kXMaxYMid = 0x06,
+        kXMinYMax = 0x08,
+        kXMidYMax = 0x09,
+        kXMaxYMax = 0x0a,
+
+        kNone     = 0x10,
+    };
+
+    enum Scale {
+        kMeet,
+        kSlice,
+    };
+
+    Align fAlign = kXMidYMid;
+    Scale fScale = kMeet;
+};
+
+class SK_API SkSVGTextAnchor {
+public:
+    enum class Type {
+        kStart,
+        kMiddle,
+        kEnd,
+        kInherit,
+    };
+
+    SkSVGTextAnchor() : fType(Type::kInherit) {}
+    explicit SkSVGTextAnchor(Type t) : fType(t) {}
+
+    bool operator==(const SkSVGTextAnchor& other) const {
+        return fType == other.fType;
+    }
+    bool operator!=(const SkSVGTextAnchor& other) const { return !(*this == other); }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+};
+
+// https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveInAttribute
+class SK_API SkSVGFeInputType {
+public:
+    enum class Type {
+        kSourceGraphic,
+        kSourceAlpha,
+        kBackgroundImage,
+        kBackgroundAlpha,
+        kFillPaint,
+        kStrokePaint,
+        kFilterPrimitiveReference,
+        kUnspecified,
+    };
+
+    SkSVGFeInputType() : fType(Type::kUnspecified) {}
+    explicit SkSVGFeInputType(Type t) : fType(t) {}
+    explicit SkSVGFeInputType(const SkSVGStringType& id)
+            : fType(Type::kFilterPrimitiveReference), fId(id) {}
+
+    bool operator==(const SkSVGFeInputType& other) const {
+        return fType == other.fType && fId == other.fId;
+    }
+    bool operator!=(const SkSVGFeInputType& other) const { return !(*this == other); }
+
+    const SkString& id() const {
+        SkASSERT(fType == Type::kFilterPrimitiveReference);
+        return fId;
+    }
+
+    Type type() const { return fType; }
+
+private:
+    Type fType;
+    SkString fId;
+};
+
+enum class SkSVGFeColorMatrixType {
+    kMatrix,
+    kSaturate,
+    kHueRotate,
+    kLuminanceToAlpha,
+};
+
+using SkSVGFeColorMatrixValues = std::vector<SkSVGNumberType>;
+
+enum class SkSVGFeCompositeOperator {
+    kOver,
+    kIn,
+    kOut,
+    kAtop,
+    kXor,
+    kArithmetic,
+};
+
+class SK_API SkSVGFeTurbulenceBaseFrequency {
+public:
+    SkSVGFeTurbulenceBaseFrequency() : fFreqX(0), fFreqY(0) {}
+    SkSVGFeTurbulenceBaseFrequency(SkSVGNumberType freqX, SkSVGNumberType freqY)
+            : fFreqX(freqX), fFreqY(freqY) {}
+
+    SkSVGNumberType freqX() const { return fFreqX; }
+    SkSVGNumberType freqY() const { return fFreqY; }
+
+private:
+    SkSVGNumberType fFreqX;
+    SkSVGNumberType fFreqY;
+};
+
+struct SK_API SkSVGFeTurbulenceType {
+    enum Type {
+        kFractalNoise,
+        kTurbulence,
+    };
+
+    Type fType;
+
+    SkSVGFeTurbulenceType() : fType(kTurbulence) {}
+    explicit SkSVGFeTurbulenceType(Type type) : fType(type) {}
+};
+
+enum class SkSVGXmlSpace {
+    kDefault,
+    kPreserve,
+};
+
+enum class SkSVGColorspace {
+    kAuto,
+    kSRGB,
+    kLinearRGB,
+};
+
+// https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
+enum class SkSVGDisplay {
+    kInline,
+    kNone,
+};
+
+// https://www.w3.org/TR/SVG11/filters.html#TransferFunctionElementAttributes
+enum class SkSVGFeFuncType {
+    kIdentity,
+    kTable,
+    kDiscrete,
+    kLinear,
+    kGamma,
+};
+
+#endif // SkSVGTypes_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h
new file mode 100644
index 00000000..1b41614a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGUse.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGUse_DEFINED
+#define SkSVGUse_DEFINED
+
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+/**
+ * Implements support for <use> (reference) elements.
+ * (https://www.w3.org/TR/SVG11/struct.html#UseElement)
+ */
+class SK_API SkSVGUse final : public SkSVGTransformableNode {
+public:
+    static sk_sp<SkSVGUse> Make() { return sk_sp<SkSVGUse>(new SkSVGUse()); }
+
+    void appendChild(sk_sp<SkSVGNode>) override;
+
+    SVG_ATTR(X   , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Y   , SkSVGLength, SkSVGLength(0))
+    SVG_ATTR(Href, SkSVGIRI   , SkSVGIRI())
+
+protected:
+    bool onPrepareToRender(SkSVGRenderContext*) const override;
+    void onRender(const SkSVGRenderContext&) const override;
+    SkPath onAsPath(const SkSVGRenderContext&) const override;
+    SkRect onObjectBoundingBox(const SkSVGRenderContext&) const override;
+
+private:
+    SkSVGUse();
+
+    bool parseAndSetAttribute(const char*, const char*) override;
+
+    using INHERITED = SkSVGTransformableNode;
+};
+
+#endif // SkSVGUse_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h b/Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h
new file mode 100644
index 00000000..5a574b9b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/include/SkSVGValue.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGValue_DEFINED
+#define SkSVGValue_DEFINED
+
+#include "include/core/SkColor.h"
+#include "include/core/SkMatrix.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkTypes.h"
+#include "include/private/base/SkNoncopyable.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+class SK_API SkSVGValue : public SkNoncopyable {
+public:
+    enum class Type {
+        kColor,
+        kFilter,
+        kLength,
+        kNumber,
+        kObjectBoundingBoxUnits,
+        kPreserveAspectRatio,
+        kStopColor,
+        kString,
+        kTransform,
+        kViewBox,
+    };
+
+    Type type() const { return fType; }
+
+    template <typename T>
+    const T* as() const {
+        return fType == T::TYPE ? static_cast<const T*>(this) : nullptr;
+    }
+
+protected:
+    SkSVGValue(Type t) : fType(t) { }
+
+private:
+    Type fType;
+
+    using INHERITED = SkNoncopyable;
+};
+
+template <typename T, SkSVGValue::Type ValueType>
+class SK_API SkSVGWrapperValue final : public SkSVGValue {
+public:
+    static constexpr Type TYPE = ValueType;
+
+    explicit SkSVGWrapperValue(const T& v)
+        : INHERITED(ValueType)
+        , fWrappedValue(v) { }
+
+    operator const T&() const { return fWrappedValue; }
+    const T* operator->() const { return &fWrappedValue; }
+
+private:
+    // Stack-only
+    void* operator new(size_t) = delete;
+    void* operator new(size_t, void*) = delete;
+
+    const T& fWrappedValue;
+
+    using INHERITED = SkSVGValue;
+};
+
+using SkSVGColorValue        = SkSVGWrapperValue<SkSVGColorType    , SkSVGValue::Type::kColor     >;
+using SkSVGLengthValue       = SkSVGWrapperValue<SkSVGLength       , SkSVGValue::Type::kLength    >;
+using SkSVGTransformValue    = SkSVGWrapperValue<SkSVGTransformType, SkSVGValue::Type::kTransform >;
+using SkSVGViewBoxValue      = SkSVGWrapperValue<SkSVGViewBoxType  , SkSVGValue::Type::kViewBox   >;
+using SkSVGNumberValue       = SkSVGWrapperValue<SkSVGNumberType   , SkSVGValue::Type::kNumber    >;
+using SkSVGStringValue       = SkSVGWrapperValue<SkSVGStringType   , SkSVGValue::Type::kString    >;
+using SkSVGStopColorValue    = SkSVGWrapperValue<SkSVGStopColor    , SkSVGValue::Type::kStopColor >;
+
+using SkSVGPreserveAspectRatioValue    = SkSVGWrapperValue<SkSVGPreserveAspectRatio,
+                                                           SkSVGValue::Type::kPreserveAspectRatio>;
+
+using SkSVGObjectBoundingBoxUnitsValue = SkSVGWrapperValue<SkSVGObjectBoundingBoxUnits,
+                                                           SkSVGValue::Type::kObjectBoundingBoxUnits>;
+
+#endif // SkSVGValue_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/src/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/src/BUILD.bazel
new file mode 100644
index 00000000..e478438e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/BUILD.bazel
@@ -0,0 +1,69 @@
+load("//bazel:skia_rules.bzl", "skia_filegroup")
+
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
+
+# This group is exported as //modules/svg/svg.gni:skia_svg_sources.
+skia_filegroup(
+    name = "private_hdrs",
+    srcs = [
+        "SkSVGRectPriv.h",
+        "SkSVGTextPriv.h",
+    ],
+    visibility = ["//modules/svg:__pkg__"],
+)
+
+# This group is exported as //modules/svg/svg.gni:skia_svg_sources.
+skia_filegroup(
+    name = "srcs",
+    srcs = [
+        "SkSVGAttribute.cpp",
+        "SkSVGAttributeParser.cpp",
+        "SkSVGCircle.cpp",
+        "SkSVGClipPath.cpp",
+        "SkSVGContainer.cpp",
+        "SkSVGDOM.cpp",
+        "SkSVGEllipse.cpp",
+        "SkSVGFe.cpp",
+        "SkSVGFeBlend.cpp",
+        "SkSVGFeColorMatrix.cpp",
+        "SkSVGFeComponentTransfer.cpp",
+        "SkSVGFeComposite.cpp",
+        "SkSVGFeDisplacementMap.cpp",
+        "SkSVGFeFlood.cpp",
+        "SkSVGFeGaussianBlur.cpp",
+        "SkSVGFeImage.cpp",
+        "SkSVGFeLightSource.cpp",
+        "SkSVGFeLighting.cpp",
+        "SkSVGFeMerge.cpp",
+        "SkSVGFeMorphology.cpp",
+        "SkSVGFeOffset.cpp",
+        "SkSVGFeTurbulence.cpp",
+        "SkSVGFilter.cpp",
+        "SkSVGFilterContext.cpp",
+        "SkSVGGradient.cpp",
+        "SkSVGImage.cpp",
+        "SkSVGLine.cpp",
+        "SkSVGLinearGradient.cpp",
+        "SkSVGMask.cpp",
+        "SkSVGNode.cpp",
+        "SkSVGOpenTypeSVGDecoder.cpp",
+        "SkSVGPath.cpp",
+        "SkSVGPattern.cpp",
+        "SkSVGPoly.cpp",
+        "SkSVGRadialGradient.cpp",
+        "SkSVGRect.cpp",
+        "SkSVGRenderContext.cpp",
+        "SkSVGSVG.cpp",
+        "SkSVGShape.cpp",
+        "SkSVGStop.cpp",
+        "SkSVGText.cpp",
+        "SkSVGTransformableNode.cpp",
+        "SkSVGUse.cpp",
+        "SkSVGValue.cpp",
+    ],
+    visibility = ["//modules/svg:__pkg__"],
+)
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp
new file mode 100644
index 00000000..ac99e64a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttribute.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGAttribute.h"
+
+SkSVGPresentationAttributes SkSVGPresentationAttributes::MakeInitial() {
+    SkSVGPresentationAttributes result;
+
+    result.fFill.set(SkSVGPaint(SkSVGColor(SK_ColorBLACK)));
+    result.fFillOpacity.set(SkSVGNumberType(1));
+    result.fFillRule.set(SkSVGFillRule(SkSVGFillRule::Type::kNonZero));
+    result.fClipRule.set(SkSVGFillRule(SkSVGFillRule::Type::kNonZero));
+
+    result.fStroke.set(SkSVGPaint(SkSVGPaint::Type::kNone));
+    result.fStrokeDashArray.set(SkSVGDashArray(SkSVGDashArray::Type::kNone));
+    result.fStrokeDashOffset.set(SkSVGLength(0));
+    result.fStrokeLineCap.set(SkSVGLineCap::kButt);
+    result.fStrokeLineJoin.set(SkSVGLineJoin(SkSVGLineJoin::Type::kMiter));
+    result.fStrokeMiterLimit.set(SkSVGNumberType(4));
+    result.fStrokeOpacity.set(SkSVGNumberType(1));
+    result.fStrokeWidth.set(SkSVGLength(1));
+
+    result.fVisibility.set(SkSVGVisibility(SkSVGVisibility::Type::kVisible));
+
+    result.fColor.set(SkSVGColorType(SK_ColorBLACK));
+    result.fColorInterpolation.set(SkSVGColorspace::kSRGB);
+    result.fColorInterpolationFilters.set(SkSVGColorspace::kLinearRGB);
+
+    result.fFontFamily.init("Sans");
+    result.fFontStyle.init(SkSVGFontStyle::Type::kNormal);
+    result.fFontSize.init(SkSVGLength(24));
+    result.fFontWeight.init(SkSVGFontWeight::Type::kNormal);
+    result.fTextAnchor.init(SkSVGTextAnchor::Type::kStart);
+
+    result.fDisplay.init(SkSVGDisplay::kInline);
+
+    result.fStopColor.set(SkSVGColor(SK_ColorBLACK));
+    result.fStopOpacity.set(SkSVGNumberType(1));
+    result.fFloodColor.set(SkSVGColor(SK_ColorBLACK));
+    result.fFloodOpacity.set(SkSVGNumberType(1));
+    result.fLightingColor.set(SkSVGColor(SK_ColorWHITE));
+
+    return result;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp
new file mode 100644
index 00000000..0277add3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGAttributeParser.cpp
@@ -0,0 +1,1175 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/private/base/SkTPin.h"
+#include "include/utils/SkParse.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "src/base/SkUTF.h"
+
+namespace {
+
+// TODO: these should be shared with SkParse.cpp
+
+inline bool is_between(char c, char min, char max) {
+    SkASSERT(min <= max);
+    return (unsigned)(c - min) <= (unsigned)(max - min);
+}
+
+inline bool is_ws(char c) {
+    return is_between(c, 1, 32);
+}
+
+inline bool is_sep(char c) {
+    return is_ws(c) || c == ',' || c == ';';
+}
+
+inline bool is_nl(char c) {
+    return c == '\n' || c == '\r' || c == '\f';
+}
+
+inline bool is_hex(char c) {
+    return is_between(c, 'a', 'f') ||
+           is_between(c, 'A', 'F') ||
+           is_between(c, '0', '9');
+}
+
+}  // namespace
+
+SkSVGAttributeParser::SkSVGAttributeParser(const char attributeString[])
+    // TODO: need actual UTF-8 with length.
+    : fCurPos(attributeString), fEndPos(fCurPos + strlen(attributeString)) {}
+
+template <typename F>
+inline bool SkSVGAttributeParser::advanceWhile(F f) {
+    auto initial = fCurPos;
+    while (fCurPos < fEndPos && f(*fCurPos)) {
+        fCurPos++;
+    }
+    return fCurPos != initial;
+}
+
+bool SkSVGAttributeParser::matchStringToken(const char* token, const char** newPos) const {
+    const char* c = fCurPos;
+
+    while (c < fEndPos && *token && *c == *token) {
+        c++;
+        token++;
+    }
+
+    if (*token) {
+        return false;
+    }
+
+    if (newPos) {
+        *newPos = c;
+    }
+
+    return true;
+}
+
+bool SkSVGAttributeParser::parseEOSToken() {
+    return fCurPos == fEndPos;
+}
+
+bool SkSVGAttributeParser::parseSepToken() {
+    return this->advanceWhile(is_sep);
+}
+
+bool SkSVGAttributeParser::parseWSToken() {
+    return this->advanceWhile(is_ws);
+}
+
+bool SkSVGAttributeParser::parseCommaWspToken() {
+    // comma-wsp:
+    //     (wsp+ comma? wsp*) | (comma wsp*)
+    return this->parseWSToken() || this->parseExpectedStringToken(",");
+}
+
+bool SkSVGAttributeParser::parseExpectedStringToken(const char* expected) {
+    const char* newPos;
+    if (!matchStringToken(expected, &newPos)) {
+        return false;
+    }
+
+    fCurPos = newPos;
+    return true;
+}
+
+bool SkSVGAttributeParser::parseScalarToken(SkScalar* res) {
+    if (const char* next = SkParse::FindScalar(fCurPos, res)) {
+        fCurPos = next;
+        return true;
+    }
+    return false;
+}
+
+bool SkSVGAttributeParser::parseInt32Token(int32_t* res) {
+    if (const char* next = SkParse::FindS32(fCurPos, res)) {
+        fCurPos = next;
+        return true;
+    }
+    return false;
+}
+
+bool SkSVGAttributeParser::matchHexToken(const char** newPos) const {
+    *newPos = fCurPos;
+    while (*newPos < fEndPos && is_hex(**newPos)) { ++*newPos; }
+    return *newPos != fCurPos;
+}
+
+bool SkSVGAttributeParser::parseEscape(SkUnichar* c) {
+    // \(hexDigit{1,6}whitespace?|[^newline|hexDigit])
+    RestoreCurPos restoreCurPos(this);
+
+    if (!this->parseExpectedStringToken("\\")) {
+        return false;
+    }
+    const char* hexEnd;
+    if (this->matchHexToken(&hexEnd)) {
+        if (hexEnd - fCurPos > 6) {
+            hexEnd = fCurPos + 6;
+        }
+        char hexString[7];
+        size_t hexSize = hexEnd - fCurPos;
+        memcpy(hexString, fCurPos, hexSize);
+        hexString[hexSize] = '\0';
+        uint32_t cp;
+        const char* hexFound = SkParse::FindHex(hexString, &cp);
+        if (!hexFound || cp < 1 || (0xD800 <= cp && cp <= 0xDFFF) || 0x10FFFF < cp) {
+            cp = 0xFFFD;
+        }
+        *c = cp;
+        fCurPos = hexEnd;
+        this->parseWSToken();
+    } else if (this->parseEOSToken() || is_nl(*fCurPos)) {
+        *c = 0xFFFD;
+        return false;
+    } else {
+        if ((*c = SkUTF::NextUTF8(&fCurPos, fEndPos)) < 0) {
+            return false;
+        }
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseIdentToken(SkString* ident) {
+    // <ident-token>
+    // (--|-?([a-z|A-Z|_|non-ASCII]|escape))([a-z|A-Z|0-9|_|-|non-ASCII]|escape)?
+    RestoreCurPos restoreCurPos(this);
+
+    SkUnichar c;
+    if (this->parseExpectedStringToken("--")) {
+        ident->append("--");
+    } else {
+        if (this->parseExpectedStringToken("-")) {
+            ident->append("-");
+        }
+        if (this->parseEscape(&c)) {
+            ident->appendUnichar(c);
+        } else {
+            if ((c = SkUTF::NextUTF8(&fCurPos, fEndPos)) < 0) {
+                return false;
+            }
+            if ((c < 'a' || 'z' < c) &&
+                (c < 'A' || 'Z' < c) &&
+                (c != '_') &&
+                (c < 0x80 || 0x10FFFF < c))
+            {
+                return false;
+            }
+            ident->appendUnichar(c);
+        }
+    }
+    while (fCurPos < fEndPos) {
+        if (this->parseEscape(&c)) {
+            ident->appendUnichar(c);
+            continue;
+        }
+        const char* next = fCurPos;
+        if ((c = SkUTF::NextUTF8(&next, fEndPos)) < 0) {
+            break;
+        }
+        if ((c < 'a' || 'z' < c) &&
+            (c < 'A' || 'Z' < c) &&
+            (c < '0' || '9' < c) &&
+            (c != '_') &&
+            (c != '-') &&
+            (c < 0x80 || 0x10FFFF < c))
+        {
+            break;
+        }
+        ident->appendUnichar(c);
+        fCurPos = next;
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseLengthUnitToken(SkSVGLength::Unit* unit) {
+    static const struct {
+        const char*       fUnitName;
+        SkSVGLength::Unit fUnit;
+    } gUnitInfo[] = {
+        { "%" , SkSVGLength::Unit::kPercentage },
+        { "em", SkSVGLength::Unit::kEMS        },
+        { "ex", SkSVGLength::Unit::kEXS        },
+        { "px", SkSVGLength::Unit::kPX         },
+        { "cm", SkSVGLength::Unit::kCM         },
+        { "mm", SkSVGLength::Unit::kMM         },
+        { "in", SkSVGLength::Unit::kIN         },
+        { "pt", SkSVGLength::Unit::kPT         },
+        { "pc", SkSVGLength::Unit::kPC         },
+    };
+
+    for (size_t i = 0; i < std::size(gUnitInfo); ++i) {
+        if (this->parseExpectedStringToken(gUnitInfo[i].fUnitName)) {
+            *unit = gUnitInfo[i].fUnit;
+            return true;
+        }
+    }
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeColor
+bool SkSVGAttributeParser::parseNamedColorToken(SkColor* c) {
+    RestoreCurPos restoreCurPos(this);
+
+    SkString ident;
+    if (!this->parseIdentToken(&ident)) {
+        return false;
+    }
+    if (!SkParse::FindNamedColor(ident.c_str(), ident.size(), c)) {
+        return false;
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseHexColorToken(SkColor* c) {
+    RestoreCurPos restoreCurPos(this);
+
+    const char* hexEnd;
+    if (!this->parseExpectedStringToken("#") || !this->matchHexToken(&hexEnd)) {
+        return false;
+    }
+
+    uint32_t v;
+    SkString hexString(fCurPos, hexEnd - fCurPos);
+    SkParse::FindHex(hexString.c_str(), &v);
+
+    switch (hexString.size()) {
+    case 6:
+        // matched #xxxxxxx
+        break;
+    case 3:
+        // matched '#xxx;
+        v = ((v << 12) & 0x00f00000) |
+            ((v <<  8) & 0x000ff000) |
+            ((v <<  4) & 0x00000ff0) |
+            ((v <<  0) & 0x0000000f);
+        break;
+    default:
+        return false;
+    }
+
+    *c = v | 0xff000000;
+    fCurPos = hexEnd;
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseColorComponentIntegralToken(int32_t* c) {
+    const char* p = SkParse::FindS32(fCurPos, c);
+    if (!p || *p == '.') {
+        // No value parsed, or fractional value.
+        return false;
+    }
+
+    if (*p == '%') {
+        *c = SkScalarRoundToInt(*c * 255.0f / 100);
+        *c = SkTPin<int32_t>(*c, 0, 255);
+        p++;
+    }
+
+    fCurPos = p;
+    return true;
+}
+
+bool SkSVGAttributeParser::parseColorComponentFractionalToken(int32_t* c) {
+    SkScalar s;
+    const char* p = SkParse::FindScalar(fCurPos, &s);
+    if (!p || *p != '%') {
+        // Floating point must be a percentage (CSS2 rgb-percent syntax).
+        return false;
+    }
+    p++;  // Skip '%'
+
+    *c = SkScalarRoundToInt(s * 255.0f / 100);
+    *c = SkTPin<int32_t>(*c, 0, 255);
+    fCurPos = p;
+    return true;
+}
+
+bool SkSVGAttributeParser::parseColorComponentScalarToken(int32_t* c) {
+    SkScalar s;
+    if (const char* p = SkParse::FindScalar(fCurPos, &s)) {
+        *c = SkScalarRoundToInt(s * 255.0f);
+        *c = SkTPin<int32_t>(*c, 0, 255);
+        fCurPos = p;
+        return true;
+    }
+    return false;
+}
+
+bool SkSVGAttributeParser::parseColorComponentToken(int32_t* c) {
+    return parseColorComponentIntegralToken(c) ||
+           parseColorComponentFractionalToken(c);
+}
+
+bool SkSVGAttributeParser::parseRGBColorToken(SkColor* c) {
+    return this->parseParenthesized("rgb", [this](SkColor* c) -> bool {
+        int32_t r, g, b;
+        if (this->parseColorComponentToken(&r) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&g) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&b)) {
+
+            *c = SkColorSetRGB(static_cast<uint8_t>(r),
+                               static_cast<uint8_t>(g),
+                               static_cast<uint8_t>(b));
+            return true;
+        }
+        return false;
+    }, c);
+}
+
+bool SkSVGAttributeParser::parseRGBAColorToken(SkColor* c) {
+    return this->parseParenthesized("rgba", [this](SkColor* c) -> bool {
+        int32_t r, g, b, a;
+        if (this->parseColorComponentToken(&r) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&g) &&
+            this->parseSepToken() &&
+            this->parseColorComponentToken(&b) &&
+            this->parseSepToken() &&
+            this->parseColorComponentScalarToken(&a)) {
+
+            *c = SkColorSetARGB(static_cast<uint8_t>(a),
+                                static_cast<uint8_t>(r),
+                                static_cast<uint8_t>(g),
+                                static_cast<uint8_t>(b));
+            return true;
+        }
+        return false;
+    }, c);
+}
+
+bool SkSVGAttributeParser::parseColorToken(SkColor* c) {
+    return this->parseHexColorToken(c) ||
+           this->parseNamedColorToken(c) ||
+           this->parseRGBAColorToken(c) ||
+           this->parseRGBColorToken(c);
+}
+
+bool SkSVGAttributeParser::parseSVGColorType(SkSVGColorType* color) {
+    SkColor c;
+    if (!this->parseColorToken(&c)) {
+        return false;
+    }
+    *color = SkSVGColorType(c);
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeColor
+// And https://www.w3.org/TR/CSS2/syndata.html#color-units for the alternative
+// forms supported by SVG (e.g. RGB percentages).
+template <>
+bool SkSVGAttributeParser::parse(SkSVGColorType* color) {
+    this->parseWSToken();
+    if (!this->parseSVGColorType(color)) {
+        return false;
+    }
+    this->parseWSToken();
+    return this->parseEOSToken();
+}
+
+bool SkSVGAttributeParser::parseSVGColor(SkSVGColor* color, SkSVGColor::Vars&& vars) {
+    static const constexpr int kVarsLimit = 32;
+
+    if (SkSVGColorType c; this->parseSVGColorType(&c)) {
+        *color = SkSVGColor(c, std::move(vars));
+        return true;
+    }
+    if (this->parseExpectedStringToken("currentColor")) {
+        *color = SkSVGColor(SkSVGColor::Type::kCurrentColor, std::move(vars));
+        return true;
+    }
+    // https://drafts.csswg.org/css-variables/#using-variables
+    if (this->parseParenthesized("var", [this, &vars](SkSVGColor* colorResult) -> bool {
+            SkString ident;
+            if (!this->parseIdentToken(&ident) || ident.size() < 2 || !ident.startsWith("--")) {
+                return false;
+            }
+            ident.remove(0, 2);
+            vars.push_back(std::move(ident));
+            this->parseWSToken();
+            if (!this->parseExpectedStringToken(",")) {
+                *colorResult = SkSVGColor(SK_ColorBLACK, std::move(vars));
+                return true;
+            }
+            this->parseWSToken();
+            if (this->matchStringToken(")")) {
+                *colorResult = SkSVGColor(SK_ColorBLACK, std::move(vars));
+                return true;
+            }
+            return vars.size() < kVarsLimit && this->parseSVGColor(colorResult, std::move(vars));
+        }, color))
+    {
+        return true;
+    }
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#InterfaceSVGColor
+template <>
+bool SkSVGAttributeParser::parse(SkSVGColor* color) {
+    this->parseWSToken();
+    if (!this->parseSVGColor(color, SkSVGColor::Vars())) {
+        return false;
+    }
+    this->parseWSToken();
+    return this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/linking.html#IRIReference
+template <>
+bool SkSVGAttributeParser::parse(SkSVGIRI* iri) {
+    // consume preceding whitespace
+    this->parseWSToken();
+
+    SkSVGIRI::Type iriType;
+    if (this->parseExpectedStringToken("#")) {
+        iriType = SkSVGIRI::Type::kLocal;
+    } else if (this->matchStringToken("data:")) {
+        iriType = SkSVGIRI::Type::kDataURI;
+    } else {
+        iriType = SkSVGIRI::Type::kNonlocal;
+    }
+
+    const auto* start = fCurPos;
+    if (!this->advanceWhile([](char c) -> bool { return c != ')'; })) {
+        return false;
+    }
+    *iri = SkSVGIRI(iriType, SkString(start, fCurPos - start));
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeFuncIRI
+bool SkSVGAttributeParser::parseFuncIRI(SkSVGFuncIRI* iri) {
+    return this->parseParenthesized("url", [this](SkSVGFuncIRI* iriResult) -> bool {
+        SkSVGIRI iri;
+        if (this->parse(&iri)) {
+            *iriResult = SkSVGFuncIRI(std::move(iri));
+            return true;
+        }
+        return false;
+    }, iri);
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGStringType* result) {
+    if (this->parseEOSToken()) {
+        return false;
+    }
+    *result = SkSVGStringType(fCurPos);
+    fCurPos += result->size();
+    return this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeNumber
+template <>
+bool SkSVGAttributeParser::parse(SkSVGNumberType* number) {
+    // consume WS
+    this->parseWSToken();
+
+    SkScalar s;
+    if (this->parseScalarToken(&s)) {
+        *number = SkSVGNumberType(s);
+        // consume trailing separators
+        this->parseSepToken();
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeInteger
+bool SkSVGAttributeParser::parseInteger(SkSVGIntegerType* number) {
+    // consume WS
+    this->parseWSToken();
+
+    // consume optional '+'
+    this->parseExpectedStringToken("+");
+
+    SkSVGIntegerType i;
+    if (this->parseInt32Token(&i)) {
+        *number = SkSVGNumberType(i);
+        // consume trailing separators
+        this->parseSepToken();
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeLength
+template <>
+bool SkSVGAttributeParser::parse(SkSVGLength* length) {
+    SkScalar s;
+    SkSVGLength::Unit u = SkSVGLength::Unit::kNumber;
+
+    if (this->parseScalarToken(&s) &&
+        (this->parseLengthUnitToken(&u) || this->parseSepToken() || this->parseEOSToken())) {
+        *length = SkSVGLength(s, u);
+        // consume trailing separators
+        this->parseSepToken();
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#ViewBoxAttribute
+bool SkSVGAttributeParser::parseViewBox(SkSVGViewBoxType* vb) {
+    SkScalar x, y, w, h;
+    this->parseWSToken();
+
+    bool parsedValue = false;
+    if (this->parseScalarToken(&x) && this->parseSepToken() &&
+        this->parseScalarToken(&y) && this->parseSepToken() &&
+        this->parseScalarToken(&w) && this->parseSepToken() &&
+        this->parseScalarToken(&h)) {
+
+        *vb = SkSVGViewBoxType(SkRect::MakeXYWH(x, y, w, h));
+        parsedValue = true;
+        // consume trailing whitespace
+        this->parseWSToken();
+    }
+    return parsedValue && this->parseEOSToken();
+}
+
+template <typename Func, typename T>
+bool SkSVGAttributeParser::parseParenthesized(const char* prefix, Func f, T* result) {
+    RestoreCurPos restoreCurPos(this);
+
+    this->parseWSToken();
+    if (prefix && !this->parseExpectedStringToken(prefix)) {
+        return false;
+    }
+    this->parseWSToken();
+    if (!this->parseExpectedStringToken("(")) {
+        return false;
+    }
+    this->parseWSToken();
+
+    if (!f(result)) {
+        return false;
+    }
+
+    this->parseWSToken();
+    if (!this->parseExpectedStringToken(")")) {
+        return false;
+    }
+
+    restoreCurPos.clear();
+    return true;
+}
+
+bool SkSVGAttributeParser::parseMatrixToken(SkMatrix* matrix) {
+    return this->parseParenthesized("matrix", [this](SkMatrix* m) -> bool {
+        SkScalar scalars[6];
+        for (int i = 0; i < 6; ++i) {
+            if (!(this->parseScalarToken(scalars + i) &&
+                  (i > 4 || this->parseSepToken()))) {
+                return false;
+            }
+        }
+
+        m->setAll(scalars[0], scalars[2], scalars[4], scalars[1], scalars[3], scalars[5], 0, 0, 1);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseTranslateToken(SkMatrix* matrix) {
+    return this->parseParenthesized("translate", [this](SkMatrix* m) -> bool {
+        SkScalar tx = 0.0, ty = 0.0;
+        this->parseWSToken();
+        if (!this->parseScalarToken(&tx)) {
+            return false;
+        }
+
+        if (!this->parseSepToken() || !this->parseScalarToken(&ty)) {
+            ty = 0.0;
+        }
+
+        m->setTranslate(tx, ty);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseScaleToken(SkMatrix* matrix) {
+    return this->parseParenthesized("scale", [this](SkMatrix* m) -> bool {
+        SkScalar sx = 0.0, sy = 0.0;
+        if (!this->parseScalarToken(&sx)) {
+            return false;
+        }
+
+        if (!(this->parseSepToken() && this->parseScalarToken(&sy))) {
+            sy = sx;
+        }
+
+        m->setScale(sx, sy);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseRotateToken(SkMatrix* matrix) {
+    return this->parseParenthesized("rotate", [this](SkMatrix* m) -> bool {
+        SkScalar angle;
+        if (!this->parseScalarToken(&angle)) {
+            return false;
+        }
+
+        SkScalar cx = 0;
+        SkScalar cy = 0;
+        // optional [<cx> <cy>]
+        if (this->parseSepToken() && this->parseScalarToken(&cx)) {
+            if (!(this->parseSepToken() && this->parseScalarToken(&cy))) {
+                return false;
+            }
+        }
+
+        m->setRotate(angle, cx, cy);
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseSkewXToken(SkMatrix* matrix) {
+    return this->parseParenthesized("skewX", [this](SkMatrix* m) -> bool {
+        SkScalar angle;
+        if (!this->parseScalarToken(&angle)) {
+            return false;
+        }
+        m->setSkewX(tanf(SkDegreesToRadians(angle)));
+        return true;
+    }, matrix);
+}
+
+bool SkSVGAttributeParser::parseSkewYToken(SkMatrix* matrix) {
+    return this->parseParenthesized("skewY", [this](SkMatrix* m) -> bool {
+        SkScalar angle;
+        if (!this->parseScalarToken(&angle)) {
+            return false;
+        }
+        m->setSkewY(tanf(SkDegreesToRadians(angle)));
+        return true;
+    }, matrix);
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#TransformAttribute
+template <>
+bool SkSVGAttributeParser::parse(SkSVGTransformType* t) {
+    SkMatrix matrix = SkMatrix::I();
+
+    bool parsed = false;
+    while (true) {
+        SkMatrix m;
+
+        if (!( this->parseMatrixToken(&m)
+            || this->parseTranslateToken(&m)
+            || this->parseScaleToken(&m)
+            || this->parseRotateToken(&m)
+            || this->parseSkewXToken(&m)
+            || this->parseSkewYToken(&m))) {
+            break;
+        }
+
+        matrix.preConcat(m);
+        parsed = true;
+
+        this->parseCommaWspToken();
+    }
+
+    this->parseWSToken();
+    if (!parsed || !this->parseEOSToken()) {
+        return false;
+    }
+
+    *t = SkSVGTransformType(matrix);
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#SpecifyingPaint
+template <>
+bool SkSVGAttributeParser::parse(SkSVGPaint* paint) {
+    SkSVGColor c;
+    SkSVGFuncIRI iri;
+    bool parsedValue = false;
+
+    this->parseWSToken();
+    if (this->parseSVGColor(&c, SkSVGColor::Vars())) {
+        *paint = SkSVGPaint(std::move(c));
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("none")) {
+        *paint = SkSVGPaint(SkSVGPaint::Type::kNone);
+        parsedValue = true;
+    } else if (this->parseFuncIRI(&iri)) {
+        // optional fallback color
+        this->parseWSToken();
+        this->parseSVGColor(&c, SkSVGColor::Vars());
+        *paint = SkSVGPaint(iri.iri(), std::move(c));
+        parsedValue = true;
+    }
+    this->parseWSToken();
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/masking.html#ClipPathProperty
+// https://www.w3.org/TR/SVG11/masking.html#MaskProperty
+// https://www.w3.org/TR/SVG11/filters.html#FilterProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFuncIRI* firi) {
+    SkSVGStringType iri;
+    bool parsedValue = false;
+
+    if (this->parseExpectedStringToken("none")) {
+        *firi = SkSVGFuncIRI();
+        parsedValue = true;
+    } else if (this->parseFuncIRI(firi)) {
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGLineCap* cap) {
+    static const struct {
+        SkSVGLineCap fType;
+        const char*        fName;
+    } gCapInfo[] = {
+        { SkSVGLineCap::kButt   , "butt"    },
+        { SkSVGLineCap::kRound  , "round"   },
+        { SkSVGLineCap::kSquare , "square"  },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gCapInfo); ++i) {
+        if (this->parseExpectedStringToken(gCapInfo[i].fName)) {
+            *cap = SkSVGLineCap(gCapInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGLineJoin* join) {
+    static const struct {
+        SkSVGLineJoin::Type fType;
+        const char*         fName;
+    } gJoinInfo[] = {
+        { SkSVGLineJoin::Type::kMiter  , "miter"   },
+        { SkSVGLineJoin::Type::kRound  , "round"   },
+        { SkSVGLineJoin::Type::kBevel  , "bevel"   },
+        { SkSVGLineJoin::Type::kInherit, "inherit" },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gJoinInfo); ++i) {
+        if (this->parseExpectedStringToken(gJoinInfo[i].fName)) {
+            *join = SkSVGLineJoin(gJoinInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#ObjectBoundingBoxUnits
+template <>
+bool SkSVGAttributeParser::parse(SkSVGObjectBoundingBoxUnits* objectBoundingBoxUnits) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("userSpaceOnUse")) {
+        *objectBoundingBoxUnits =
+                SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse);
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("objectBoundingBox")) {
+        *objectBoundingBoxUnits =
+                SkSVGObjectBoundingBoxUnits(SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox);
+        parsedValue = true;
+    }
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute
+template <>
+bool SkSVGAttributeParser::parse(SkSVGPointsType* points) {
+    SkSVGPointsType pts;
+
+    // Skip initial wsp.
+    // list-of-points:
+    //     wsp* coordinate-pairs? wsp*
+    this->advanceWhile(is_ws);
+
+    bool parsedValue = false;
+    for (;;) {
+        // Adjacent coordinate-pairs separated by comma-wsp.
+        // coordinate-pairs:
+        //     coordinate-pair
+        //     | coordinate-pair comma-wsp coordinate-pairs
+        if (parsedValue && !this->parseCommaWspToken()) {
+            break;
+        }
+
+        SkScalar x, y;
+        if (!this->parseScalarToken(&x)) {
+            break;
+        }
+
+        // Coordinate values separated by comma-wsp or '-'.
+        // coordinate-pair:
+        //     coordinate comma-wsp coordinate
+        //     | coordinate negative-coordinate
+        if (!this->parseCommaWspToken() && !this->parseEOSToken() && *fCurPos != '-') {
+            break;
+        }
+
+        if (!this->parseScalarToken(&y)) {
+            break;
+        }
+
+        pts.push_back(SkPoint::Make(x, y));
+        parsedValue = true;
+    }
+
+    if (parsedValue && this->parseEOSToken()) {
+        *points = std::move(pts);
+        return true;
+    }
+
+    return false;
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#FillRuleProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFillRule* fillRule) {
+    static const struct {
+        SkSVGFillRule::Type fType;
+        const char*         fName;
+    } gFillRuleInfo[] = {
+        { SkSVGFillRule::Type::kNonZero, "nonzero" },
+        { SkSVGFillRule::Type::kEvenOdd, "evenodd" },
+        { SkSVGFillRule::Type::kInherit, "inherit" },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gFillRuleInfo); ++i) {
+        if (this->parseExpectedStringToken(gFillRuleInfo[i].fName)) {
+            *fillRule = SkSVGFillRule(gFillRuleInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#VisibilityProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGVisibility* visibility) {
+    static const struct {
+        SkSVGVisibility::Type fType;
+        const char*           fName;
+    } gVisibilityInfo[] = {
+        { SkSVGVisibility::Type::kVisible , "visible"  },
+        { SkSVGVisibility::Type::kHidden  , "hidden"   },
+        { SkSVGVisibility::Type::kCollapse, "collapse" },
+        { SkSVGVisibility::Type::kInherit , "inherit"  },
+    };
+
+    bool parsedValue = false;
+    for (const auto& parseInfo : gVisibilityInfo) {
+        if (this->parseExpectedStringToken(parseInfo.fName)) {
+            *visibility = SkSVGVisibility(parseInfo.fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#StrokeDasharrayProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGDashArray* dashArray) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("none")) {
+        *dashArray = SkSVGDashArray(SkSVGDashArray::Type::kNone);
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("inherit")) {
+        *dashArray = SkSVGDashArray(SkSVGDashArray::Type::kInherit);
+        parsedValue = true;
+    } else {
+        std::vector<SkSVGLength> dashes;
+        for (;;) {
+            SkSVGLength dash;
+            // parseLength() also consumes trailing separators.
+            if (!this->parse(&dash)) {
+                break;
+            }
+
+            dashes.push_back(dash);
+            parsedValue = true;
+        }
+
+        if (parsedValue) {
+            *dashArray = SkSVGDashArray(std::move(dashes));
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontFamilyProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontFamily* family) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("inherit")) {
+        *family = SkSVGFontFamily();
+        parsedValue = true;
+    } else {
+        // The spec allows specifying a comma-separated list for explicit fallback order.
+        // For now, we only use the first entry and rely on the font manager to handle fallback.
+        const auto* comma = strchr(fCurPos, ',');
+        auto family_name = comma ? SkString(fCurPos, comma - fCurPos)
+                                 : SkString(fCurPos);
+        *family = SkSVGFontFamily(family_name.c_str());
+        fCurPos += strlen(fCurPos);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontSizeProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontSize* size) {
+    bool parsedValue = false;
+    if (this->parseExpectedStringToken("inherit")) {
+        *size = SkSVGFontSize();
+        parsedValue = true;
+    } else {
+        SkSVGLength length;
+        if (this->parse(&length)) {
+            *size = SkSVGFontSize(length);
+            parsedValue = true;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontStyleProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontStyle* style) {
+    static constexpr std::tuple<const char*, SkSVGFontStyle::Type> gStyleMap[] = {
+        { "normal" , SkSVGFontStyle::Type::kNormal  },
+        { "italic" , SkSVGFontStyle::Type::kItalic  },
+        { "oblique", SkSVGFontStyle::Type::kOblique },
+        { "inherit", SkSVGFontStyle::Type::kInherit },
+    };
+
+    bool parsedValue = false;
+    SkSVGFontStyle::Type type;
+
+    if (this->parseEnumMap(gStyleMap, &type)) {
+        *style = SkSVGFontStyle(type);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#FontWeightProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFontWeight* weight) {
+    static constexpr std::tuple<const char*, SkSVGFontWeight::Type> gWeightMap[] = {
+        { "normal" , SkSVGFontWeight::Type::kNormal  },
+        { "bold"   , SkSVGFontWeight::Type::kBold    },
+        { "bolder" , SkSVGFontWeight::Type::kBolder  },
+        { "lighter", SkSVGFontWeight::Type::kLighter },
+        { "100"    , SkSVGFontWeight::Type::k100     },
+        { "200"    , SkSVGFontWeight::Type::k200     },
+        { "300"    , SkSVGFontWeight::Type::k300     },
+        { "400"    , SkSVGFontWeight::Type::k400     },
+        { "500"    , SkSVGFontWeight::Type::k500     },
+        { "600"    , SkSVGFontWeight::Type::k600     },
+        { "700"    , SkSVGFontWeight::Type::k700     },
+        { "800"    , SkSVGFontWeight::Type::k800     },
+        { "900"    , SkSVGFontWeight::Type::k900     },
+        { "inherit", SkSVGFontWeight::Type::kInherit },
+    };
+
+    bool parsedValue = false;
+    SkSVGFontWeight::Type type;
+
+    if (this->parseEnumMap(gWeightMap, &type)) {
+        *weight = SkSVGFontWeight(type);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/text.html#TextAnchorProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGTextAnchor* anchor) {
+    static constexpr std::tuple<const char*, SkSVGTextAnchor::Type> gAnchorMap[] = {
+        { "start"  , SkSVGTextAnchor::Type::kStart  },
+        { "middle" , SkSVGTextAnchor::Type::kMiddle },
+        { "end"    , SkSVGTextAnchor::Type::kEnd    },
+        { "inherit", SkSVGTextAnchor::Type::kInherit},
+    };
+
+    bool parsedValue = false;
+    SkSVGTextAnchor::Type type;
+
+    if (this->parseEnumMap(gAnchorMap, &type)) {
+        *anchor = SkSVGTextAnchor(type);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#PreserveAspectRatioAttribute
+bool SkSVGAttributeParser::parsePreserveAspectRatio(SkSVGPreserveAspectRatio* par) {
+    static constexpr std::tuple<const char*, SkSVGPreserveAspectRatio::Align> gAlignMap[] = {
+        { "none"    , SkSVGPreserveAspectRatio::kNone     },
+        { "xMinYMin", SkSVGPreserveAspectRatio::kXMinYMin },
+        { "xMidYMin", SkSVGPreserveAspectRatio::kXMidYMin },
+        { "xMaxYMin", SkSVGPreserveAspectRatio::kXMaxYMin },
+        { "xMinYMid", SkSVGPreserveAspectRatio::kXMinYMid },
+        { "xMidYMid", SkSVGPreserveAspectRatio::kXMidYMid },
+        { "xMaxYMid", SkSVGPreserveAspectRatio::kXMaxYMid },
+        { "xMinYMax", SkSVGPreserveAspectRatio::kXMinYMax },
+        { "xMidYMax", SkSVGPreserveAspectRatio::kXMidYMax },
+        { "xMaxYMax", SkSVGPreserveAspectRatio::kXMaxYMax },
+    };
+
+    static constexpr std::tuple<const char*, SkSVGPreserveAspectRatio::Scale> gScaleMap[] = {
+        { "meet" , SkSVGPreserveAspectRatio::kMeet  },
+        { "slice", SkSVGPreserveAspectRatio::kSlice },
+    };
+
+    bool parsedValue = false;
+
+    // ignoring optional 'defer'
+    this->parseExpectedStringToken("defer");
+    this->parseWSToken();
+
+    if (this->parseEnumMap(gAlignMap, &par->fAlign)) {
+        parsedValue = true;
+
+        // optional scaling selector
+        this->parseWSToken();
+        this->parseEnumMap(gScaleMap, &par->fScale);
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGPreserveAspectRatio* par) {
+    return this->parsePreserveAspectRatio(par);
+}
+
+// https://www.w3.org/TR/SVG11/types.html#DataTypeCoordinates
+template <typename T>
+bool SkSVGAttributeParser::parseList(std::vector<T>* vals) {
+    SkASSERT(vals->empty());
+
+    T v;
+    for (;;) {
+        if (!this->parse(&v)) {
+            break;
+        }
+
+        vals->push_back(v);
+
+        this->parseCommaWspToken();
+    }
+
+    return !vals->empty() && this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse(std::vector<SkSVGLength>* lengths) {
+    return this->parseList(lengths);
+}
+
+template <>
+bool SkSVGAttributeParser::parse(std::vector<SkSVGNumberType>* numbers) {
+    return this->parseList(numbers);
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGColorspace* colorspace) {
+    static constexpr std::tuple<const char*, SkSVGColorspace> gColorspaceMap[] = {
+        { "auto"     , SkSVGColorspace::kAuto      },
+        { "sRGB"     , SkSVGColorspace::kSRGB      },
+        { "linearRGB", SkSVGColorspace::kLinearRGB },
+    };
+
+    return this->parseEnumMap(gColorspaceMap, colorspace) && this->parseEOSToken();
+}
+
+// https://www.w3.org/TR/SVG11/painting.html#DisplayProperty
+template <>
+bool SkSVGAttributeParser::parse(SkSVGDisplay* display) {
+    static const struct {
+        SkSVGDisplay fType;
+        const char*  fName;
+    } gDisplayInfo[] = {
+        { SkSVGDisplay::kInline, "inline" },
+        { SkSVGDisplay::kNone  , "none"   },
+    };
+
+    bool parsedValue = false;
+    for (const auto& parseInfo : gDisplayInfo) {
+        if (this->parseExpectedStringToken(parseInfo.fName)) {
+            *display = SkSVGDisplay(parseInfo.fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp
new file mode 100644
index 00000000..31501d14
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGCircle.cpp
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGCircle.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGCircle::SkSVGCircle() : INHERITED(SkSVGTag::kCircle) {}
+
+bool SkSVGCircle::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setCx(SkSVGAttributeParser::parse<SkSVGLength>("cx", n, v)) ||
+           this->setCy(SkSVGAttributeParser::parse<SkSVGLength>("cy", n, v)) ||
+           this->setR(SkSVGAttributeParser::parse<SkSVGLength>("r", n, v));
+}
+
+std::tuple<SkPoint, SkScalar> SkSVGCircle::resolve(const SkSVGLengthContext& lctx) const {
+    const auto cx = lctx.resolve(fCx, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto cy = lctx.resolve(fCy, SkSVGLengthContext::LengthType::kVertical);
+    const auto  r = lctx.resolve(fR , SkSVGLengthContext::LengthType::kOther);
+
+    return std::make_tuple(SkPoint::Make(cx, cy), r);
+}
+void SkSVGCircle::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                         const SkPaint& paint, SkPathFillType) const {
+    SkPoint pos;
+    SkScalar r;
+    std::tie(pos, r) = this->resolve(lctx);
+
+    if (r > 0) {
+        canvas->drawCircle(pos.x(), pos.y(), r, paint);
+    }
+}
+
+SkPath SkSVGCircle::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPoint pos;
+    SkScalar r;
+    std::tie(pos, r) = this->resolve(ctx.lengthContext());
+
+    SkPath path = SkPath::Circle(pos.x(), pos.y(), r);
+    this->mapToParent(&path);
+
+    return path;
+}
+
+SkRect SkSVGCircle::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    const auto [pos, r] = this->resolve(ctx.lengthContext());
+    return SkRect::MakeXYWH(pos.fX - r, pos.fY - r, 2 * r, 2 * r);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp
new file mode 100644
index 00000000..06ef8ae3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGClipPath.cpp
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGClipPath.h"
+
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+SkSVGClipPath::SkSVGClipPath() : INHERITED(SkSVGTag::kClipPath) {}
+
+bool SkSVGClipPath::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setClipPathUnits(
+                SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>("clipPathUnits", n, v));
+}
+
+SkPath SkSVGClipPath::resolveClip(const SkSVGRenderContext& ctx) const {
+    auto clip = this->asPath(ctx);
+
+    const auto obbt = ctx.transformForCurrentOBB(fClipPathUnits);
+    const auto m = SkMatrix::Translate(obbt.offset.x, obbt.offset.y)
+                 * SkMatrix::Scale(obbt.scale.x, obbt.scale.y);
+    clip.transform(m);
+
+    return clip;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp
new file mode 100644
index 00000000..c4b760c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGContainer.cpp
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGContainer.h"
+
+#include "include/core/SkPath.h"
+#include "include/pathops/SkPathOps.h"
+
+SkSVGContainer::SkSVGContainer(SkSVGTag t) : INHERITED(t) { }
+
+void SkSVGContainer::appendChild(sk_sp<SkSVGNode> node) {
+    SkASSERT(node);
+    fChildren.push_back(std::move(node));
+}
+
+bool SkSVGContainer::hasChildren() const {
+    return !fChildren.empty();
+}
+
+void SkSVGContainer::onRender(const SkSVGRenderContext& ctx) const {
+    for (int i = 0; i < fChildren.size(); ++i) {
+        fChildren[i]->render(ctx);
+    }
+}
+
+SkPath SkSVGContainer::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path;
+
+    for (int i = 0; i < fChildren.size(); ++i) {
+        const SkPath childPath = fChildren[i]->asPath(ctx);
+
+        Op(path, childPath, kUnion_SkPathOp, &path);
+    }
+
+    this->mapToParent(&path);
+    return path;
+}
+
+SkRect SkSVGContainer::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    SkRect bounds = SkRect::MakeEmpty();
+
+    for (int i = 0; i < fChildren.size(); ++i) {
+        const SkRect childBounds = fChildren[i]->objectBoundingBox(ctx);
+        bounds.join(childBounds);
+    }
+
+    return bounds;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp
new file mode 100644
index 00000000..25542889
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGDOM.cpp
@@ -0,0 +1,510 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGDOM.h"
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkString.h"
+#include "include/private/base/SkTo.h"
+#include "modules/skshaper/include/SkShaper_factory.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGCircle.h"
+#include "modules/svg/include/SkSVGClipPath.h"
+#include "modules/svg/include/SkSVGDefs.h"
+#include "modules/svg/include/SkSVGEllipse.h"
+#include "modules/svg/include/SkSVGFeBlend.h"
+#include "modules/svg/include/SkSVGFeColorMatrix.h"
+#include "modules/svg/include/SkSVGFeComponentTransfer.h"
+#include "modules/svg/include/SkSVGFeComposite.h"
+#include "modules/svg/include/SkSVGFeDisplacementMap.h"
+#include "modules/svg/include/SkSVGFeFlood.h"
+#include "modules/svg/include/SkSVGFeGaussianBlur.h"
+#include "modules/svg/include/SkSVGFeImage.h"
+#include "modules/svg/include/SkSVGFeLightSource.h"
+#include "modules/svg/include/SkSVGFeLighting.h"
+#include "modules/svg/include/SkSVGFeMerge.h"
+#include "modules/svg/include/SkSVGFeMorphology.h"
+#include "modules/svg/include/SkSVGFeOffset.h"
+#include "modules/svg/include/SkSVGFeTurbulence.h"
+#include "modules/svg/include/SkSVGFilter.h"
+#include "modules/svg/include/SkSVGG.h"
+#include "modules/svg/include/SkSVGImage.h"
+#include "modules/svg/include/SkSVGLine.h"
+#include "modules/svg/include/SkSVGLinearGradient.h"
+#include "modules/svg/include/SkSVGMask.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGPath.h"
+#include "modules/svg/include/SkSVGPattern.h"
+#include "modules/svg/include/SkSVGPoly.h"
+#include "modules/svg/include/SkSVGRadialGradient.h"
+#include "modules/svg/include/SkSVGRect.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGSVG.h"
+#include "modules/svg/include/SkSVGStop.h"
+#include "modules/svg/include/SkSVGText.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "modules/svg/include/SkSVGUse.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/base/SkTSearch.h"
+#include "src/core/SkTraceEvent.h"
+#include "src/xml/SkDOM.h"
+
+namespace {
+
+bool SetIRIAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                      const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGIRI>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGStringValue(parseResult->iri()));
+    return true;
+}
+
+bool SetStringAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                           const char* stringValue) {
+    SkString str(stringValue, strlen(stringValue));
+    SkSVGStringType strType = SkSVGStringType(str);
+    node->setAttribute(attr, SkSVGStringValue(strType));
+    return true;
+}
+
+bool SetTransformAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                           const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGTransformType>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGTransformValue(*parseResult));
+    return true;
+}
+
+bool SetLengthAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                        const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGLength>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGLengthValue(*parseResult));
+    return true;
+}
+
+bool SetViewBoxAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                         const char* stringValue) {
+    SkSVGViewBoxType viewBox;
+    SkSVGAttributeParser parser(stringValue);
+    if (!parser.parseViewBox(&viewBox)) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGViewBoxValue(viewBox));
+    return true;
+}
+
+bool SetObjectBoundingBoxUnitsAttribute(const sk_sp<SkSVGNode>& node,
+                                        SkSVGAttribute attr,
+                                        const char* stringValue) {
+    auto parseResult = SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(stringValue);
+    if (!parseResult.isValid()) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGObjectBoundingBoxUnitsValue(*parseResult));
+    return true;
+}
+
+bool SetPreserveAspectRatioAttribute(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr,
+                                     const char* stringValue) {
+    SkSVGPreserveAspectRatio par;
+    SkSVGAttributeParser parser(stringValue);
+    if (!parser.parsePreserveAspectRatio(&par)) {
+        return false;
+    }
+
+    node->setAttribute(attr, SkSVGPreserveAspectRatioValue(par));
+    return true;
+}
+
+SkString TrimmedString(const char* first, const char* last) {
+    SkASSERT(first);
+    SkASSERT(last);
+    SkASSERT(first <= last);
+
+    while (first <= last && *first <= ' ') { first++; }
+    while (first <= last && *last  <= ' ') { last--; }
+
+    SkASSERT(last - first + 1 >= 0);
+    return SkString(first, SkTo<size_t>(last - first + 1));
+}
+
+// Breaks a "foo: bar; baz: ..." string into key:value pairs.
+class StyleIterator {
+public:
+    StyleIterator(const char* str) : fPos(str) { }
+
+    std::tuple<SkString, SkString> next() {
+        SkString name, value;
+
+        if (fPos) {
+            const char* sep = this->nextSeparator();
+            SkASSERT(*sep == ';' || *sep == '\0');
+
+            const char* valueSep = strchr(fPos, ':');
+            if (valueSep && valueSep < sep) {
+                name  = TrimmedString(fPos, valueSep - 1);
+                value = TrimmedString(valueSep + 1, sep - 1);
+            }
+
+            fPos = *sep ? sep + 1 : nullptr;
+        }
+
+        return std::make_tuple(name, value);
+    }
+
+private:
+    const char* nextSeparator() const {
+        const char* sep = fPos;
+        while (*sep != ';' && *sep != '\0') {
+            sep++;
+        }
+        return sep;
+    }
+
+    const char* fPos;
+};
+
+bool set_string_attribute(const sk_sp<SkSVGNode>& node, const char* name, const char* value);
+
+bool SetStyleAttributes(const sk_sp<SkSVGNode>& node, SkSVGAttribute,
+                        const char* stringValue) {
+
+    SkString name, value;
+    StyleIterator iter(stringValue);
+    for (;;) {
+        std::tie(name, value) = iter.next();
+        if (name.isEmpty()) {
+            break;
+        }
+        set_string_attribute(node, name.c_str(), value.c_str());
+    }
+
+    return true;
+}
+
+template<typename T>
+struct SortedDictionaryEntry {
+    const char* fKey;
+    const T     fValue;
+};
+
+struct AttrParseInfo {
+    SkSVGAttribute fAttr;
+    bool (*fSetter)(const sk_sp<SkSVGNode>& node, SkSVGAttribute attr, const char* stringValue);
+};
+
+SortedDictionaryEntry<AttrParseInfo> gAttributeParseInfo[] = {
+    { "cx"                 , { SkSVGAttribute::kCx               , SetLengthAttribute       }},
+    { "cy"                 , { SkSVGAttribute::kCy               , SetLengthAttribute       }},
+    { "filterUnits"        , { SkSVGAttribute::kFilterUnits      ,
+                               SetObjectBoundingBoxUnitsAttribute }},
+    // focal point x & y
+    { "fx"                 , { SkSVGAttribute::kFx               , SetLengthAttribute       }},
+    { "fy"                 , { SkSVGAttribute::kFy               , SetLengthAttribute       }},
+    { "height"             , { SkSVGAttribute::kHeight           , SetLengthAttribute       }},
+    { "preserveAspectRatio", { SkSVGAttribute::kPreserveAspectRatio,
+                               SetPreserveAspectRatioAttribute }},
+    { "r"                  , { SkSVGAttribute::kR                , SetLengthAttribute       }},
+    { "rx"                 , { SkSVGAttribute::kRx               , SetLengthAttribute       }},
+    { "ry"                 , { SkSVGAttribute::kRy               , SetLengthAttribute       }},
+    { "style"              , { SkSVGAttribute::kUnknown          , SetStyleAttributes       }},
+    { "text"               , { SkSVGAttribute::kText             , SetStringAttribute       }},
+    { "transform"          , { SkSVGAttribute::kTransform        , SetTransformAttribute    }},
+    { "viewBox"            , { SkSVGAttribute::kViewBox          , SetViewBoxAttribute      }},
+    { "width"              , { SkSVGAttribute::kWidth            , SetLengthAttribute       }},
+    { "x"                  , { SkSVGAttribute::kX                , SetLengthAttribute       }},
+    { "x1"                 , { SkSVGAttribute::kX1               , SetLengthAttribute       }},
+    { "x2"                 , { SkSVGAttribute::kX2               , SetLengthAttribute       }},
+    { "xlink:href"         , { SkSVGAttribute::kHref             , SetIRIAttribute          }},
+    { "y"                  , { SkSVGAttribute::kY                , SetLengthAttribute       }},
+    { "y1"                 , { SkSVGAttribute::kY1               , SetLengthAttribute       }},
+    { "y2"                 , { SkSVGAttribute::kY2               , SetLengthAttribute       }},
+};
+
+SortedDictionaryEntry<sk_sp<SkSVGNode>(*)()> gTagFactories[] = {
+    { "a"                  , []() -> sk_sp<SkSVGNode> { return SkSVGG::Make();                   }},
+    { "circle"             , []() -> sk_sp<SkSVGNode> { return SkSVGCircle::Make();              }},
+    { "clipPath"           , []() -> sk_sp<SkSVGNode> { return SkSVGClipPath::Make();            }},
+    { "defs"               , []() -> sk_sp<SkSVGNode> { return SkSVGDefs::Make();                }},
+    { "ellipse"            , []() -> sk_sp<SkSVGNode> { return SkSVGEllipse::Make();             }},
+    { "feBlend"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeBlend::Make();             }},
+    { "feColorMatrix"      , []() -> sk_sp<SkSVGNode> { return SkSVGFeColorMatrix::Make();       }},
+    { "feComponentTransfer", []() -> sk_sp<SkSVGNode> { return SkSVGFeComponentTransfer::Make(); }},
+    { "feComposite"        , []() -> sk_sp<SkSVGNode> { return SkSVGFeComposite::Make();         }},
+    { "feDiffuseLighting"  , []() -> sk_sp<SkSVGNode> { return SkSVGFeDiffuseLighting::Make();   }},
+    { "feDisplacementMap"  , []() -> sk_sp<SkSVGNode> { return SkSVGFeDisplacementMap::Make();   }},
+    { "feDistantLight"     , []() -> sk_sp<SkSVGNode> { return SkSVGFeDistantLight::Make();      }},
+    { "feFlood"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFlood::Make();             }},
+    { "feFuncA"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncA();         }},
+    { "feFuncB"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncB();         }},
+    { "feFuncG"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncG();         }},
+    { "feFuncR"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeFunc::MakeFuncR();         }},
+    { "feGaussianBlur"     , []() -> sk_sp<SkSVGNode> { return SkSVGFeGaussianBlur::Make();      }},
+    { "feImage"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeImage::Make();             }},
+    { "feMerge"            , []() -> sk_sp<SkSVGNode> { return SkSVGFeMerge::Make();             }},
+    { "feMergeNode"        , []() -> sk_sp<SkSVGNode> { return SkSVGFeMergeNode::Make();         }},
+    { "feMorphology"       , []() -> sk_sp<SkSVGNode> { return SkSVGFeMorphology::Make();        }},
+    { "feOffset"           , []() -> sk_sp<SkSVGNode> { return SkSVGFeOffset::Make();            }},
+    { "fePointLight"       , []() -> sk_sp<SkSVGNode> { return SkSVGFePointLight::Make();        }},
+    { "feSpecularLighting" , []() -> sk_sp<SkSVGNode> { return SkSVGFeSpecularLighting::Make();  }},
+    { "feSpotLight"        , []() -> sk_sp<SkSVGNode> { return SkSVGFeSpotLight::Make();         }},
+    { "feTurbulence"       , []() -> sk_sp<SkSVGNode> { return SkSVGFeTurbulence::Make();        }},
+    { "filter"             , []() -> sk_sp<SkSVGNode> { return SkSVGFilter::Make();              }},
+    { "g"                  , []() -> sk_sp<SkSVGNode> { return SkSVGG::Make();                   }},
+    { "image"              , []() -> sk_sp<SkSVGNode> { return SkSVGImage::Make();               }},
+    { "line"               , []() -> sk_sp<SkSVGNode> { return SkSVGLine::Make();                }},
+    { "linearGradient"     , []() -> sk_sp<SkSVGNode> { return SkSVGLinearGradient::Make();      }},
+    { "mask"               , []() -> sk_sp<SkSVGNode> { return SkSVGMask::Make();                }},
+    { "path"               , []() -> sk_sp<SkSVGNode> { return SkSVGPath::Make();                }},
+    { "pattern"            , []() -> sk_sp<SkSVGNode> { return SkSVGPattern::Make();             }},
+    { "polygon"            , []() -> sk_sp<SkSVGNode> { return SkSVGPoly::MakePolygon();         }},
+    { "polyline"           , []() -> sk_sp<SkSVGNode> { return SkSVGPoly::MakePolyline();        }},
+    { "radialGradient"     , []() -> sk_sp<SkSVGNode> { return SkSVGRadialGradient::Make();      }},
+    { "rect"               , []() -> sk_sp<SkSVGNode> { return SkSVGRect::Make();                }},
+    { "stop"               , []() -> sk_sp<SkSVGNode> { return SkSVGStop::Make();                }},
+//    "svg" handled explicitly
+    { "text"               , []() -> sk_sp<SkSVGNode> { return SkSVGText::Make();                }},
+    { "textPath"           , []() -> sk_sp<SkSVGNode> { return SkSVGTextPath::Make();            }},
+    { "tspan"              , []() -> sk_sp<SkSVGNode> { return SkSVGTSpan::Make();               }},
+    { "use"                , []() -> sk_sp<SkSVGNode> { return SkSVGUse::Make();                 }},
+};
+
+struct ConstructionContext {
+    ConstructionContext(SkSVGIDMapper* mapper) : fParent(nullptr), fIDMapper(mapper) {}
+    ConstructionContext(const ConstructionContext& other, const sk_sp<SkSVGNode>& newParent)
+        : fParent(newParent.get()), fIDMapper(other.fIDMapper) {}
+
+    SkSVGNode*     fParent;
+    SkSVGIDMapper* fIDMapper;
+};
+
+bool set_string_attribute(const sk_sp<SkSVGNode>& node, const char* name, const char* value) {
+    if (node->parseAndSetAttribute(name, value)) {
+        // Handled by new code path
+        return true;
+    }
+
+    const int attrIndex = SkStrSearch(&gAttributeParseInfo[0].fKey,
+                                      SkTo<int>(std::size(gAttributeParseInfo)),
+                                      name, sizeof(gAttributeParseInfo[0]));
+    if (attrIndex < 0) {
+#if defined(SK_VERBOSE_SVG_PARSING)
+        SkDebugf("unhandled attribute: %s\n", name);
+#endif
+        return false;
+    }
+
+    SkASSERT(SkTo<size_t>(attrIndex) < std::size(gAttributeParseInfo));
+    const auto& attrInfo = gAttributeParseInfo[attrIndex].fValue;
+    if (!attrInfo.fSetter(node, attrInfo.fAttr, value)) {
+#if defined(SK_VERBOSE_SVG_PARSING)
+        SkDebugf("could not parse attribute: '%s=\"%s\"'\n", name, value);
+#endif
+        return false;
+    }
+
+    return true;
+}
+
+void parse_node_attributes(const SkDOM& xmlDom, const SkDOM::Node* xmlNode,
+                           const sk_sp<SkSVGNode>& svgNode, SkSVGIDMapper* mapper) {
+    const char* name, *value;
+    SkDOM::AttrIter attrIter(xmlDom, xmlNode);
+    while ((name = attrIter.next(&value))) {
+        // We're handling id attributes out of band for now.
+        if (!strcmp(name, "id")) {
+            mapper->set(SkString(value), svgNode);
+            continue;
+        }
+        set_string_attribute(svgNode, name, value);
+    }
+}
+
+sk_sp<SkSVGNode> construct_svg_node(const SkDOM& dom, const ConstructionContext& ctx,
+                                    const SkDOM::Node* xmlNode) {
+    const char* elem = dom.getName(xmlNode);
+    const SkDOM::Type elemType = dom.getType(xmlNode);
+
+    if (elemType == SkDOM::kText_Type) {
+        // Text literals require special handling.
+        SkASSERT(dom.countChildren(xmlNode) == 0);
+        auto txt = SkSVGTextLiteral::Make();
+        txt->setText(SkString(dom.getName(xmlNode)));
+        ctx.fParent->appendChild(std::move(txt));
+
+        return nullptr;
+    }
+
+    SkASSERT(elemType == SkDOM::kElement_Type);
+
+    auto make_node = [](const ConstructionContext& ctx, const char* elem) -> sk_sp<SkSVGNode> {
+        if (strcmp(elem, "svg") == 0) {
+            // Outermost SVG element must be tagged as such.
+            return SkSVGSVG::Make(ctx.fParent ? SkSVGSVG::Type::kInner
+                                              : SkSVGSVG::Type::kRoot);
+        }
+
+        const int tagIndex = SkStrSearch(&gTagFactories[0].fKey,
+                                         SkTo<int>(std::size(gTagFactories)),
+                                         elem, sizeof(gTagFactories[0]));
+        if (tagIndex < 0) {
+#if defined(SK_VERBOSE_SVG_PARSING)
+            SkDebugf("unhandled element: <%s>\n", elem);
+#endif
+            return nullptr;
+        }
+        SkASSERT(SkTo<size_t>(tagIndex) < std::size(gTagFactories));
+
+        return gTagFactories[tagIndex].fValue();
+    };
+
+    auto node = make_node(ctx, elem);
+    if (!node) {
+        return nullptr;
+    }
+
+    parse_node_attributes(dom, xmlNode, node, ctx.fIDMapper);
+
+    ConstructionContext localCtx(ctx, node);
+    for (auto* child = dom.getFirstChild(xmlNode, nullptr); child;
+         child = dom.getNextSibling(child)) {
+        sk_sp<SkSVGNode> childNode = construct_svg_node(dom, localCtx, child);
+        if (childNode) {
+            node->appendChild(std::move(childNode));
+        }
+    }
+
+    return node;
+}
+
+} // anonymous namespace
+
+SkSVGDOM::Builder& SkSVGDOM::Builder::setFontManager(sk_sp<SkFontMgr> fmgr) {
+    fFontMgr = std::move(fmgr);
+    return *this;
+}
+
+SkSVGDOM::Builder& SkSVGDOM::Builder::setResourceProvider(sk_sp<skresources::ResourceProvider> rp) {
+    fResourceProvider = std::move(rp);
+    return *this;
+}
+
+SkSVGDOM::Builder& SkSVGDOM::Builder::setTextShapingFactory(sk_sp<SkShapers::Factory> f) {
+    fTextShapingFactory = f;
+    return *this;
+}
+
+sk_sp<SkSVGDOM> SkSVGDOM::Builder::make(SkStream& str) const {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+    SkDOM xmlDom;
+    if (!xmlDom.build(str)) {
+        return nullptr;
+    }
+
+    SkSVGIDMapper mapper;
+    ConstructionContext ctx(&mapper);
+
+    auto root = construct_svg_node(xmlDom, ctx, xmlDom.getRootNode());
+    if (!root || root->tag() != SkSVGTag::kSvg) {
+        return nullptr;
+    }
+
+    class NullResourceProvider final : public skresources::ResourceProvider {
+        sk_sp<SkData> load(const char[], const char[]) const override { return nullptr; }
+    };
+
+    auto resource_provider = fResourceProvider ? fResourceProvider
+                                               : sk_make_sp<NullResourceProvider>();
+
+    auto factory = fTextShapingFactory ? fTextShapingFactory : SkShapers::Primitive::Factory();
+
+    return sk_sp<SkSVGDOM>(new SkSVGDOM(sk_sp<SkSVGSVG>(static_cast<SkSVGSVG*>(root.release())),
+                                        std::move(fFontMgr),
+                                        std::move(resource_provider),
+                                        std::move(mapper),
+                                        std::move(factory)));
+}
+
+SkSVGDOM::SkSVGDOM(sk_sp<SkSVGSVG> root,
+                   sk_sp<SkFontMgr> fmgr,
+                   sk_sp<skresources::ResourceProvider> rp,
+                   SkSVGIDMapper&& mapper,
+                   sk_sp<SkShapers::Factory> fact)
+        : fRoot(std::move(root))
+        , fFontMgr(std::move(fmgr))
+        , fTextShapingFactory(std::move(fact))
+        , fResourceProvider(std::move(rp))
+        , fIDMapper(std::move(mapper))
+        , fContainerSize(fRoot->intrinsicSize(SkSVGLengthContext(SkSize::Make(0, 0)))) {
+    SkASSERT(fResourceProvider);
+    SkASSERT(fTextShapingFactory);
+}
+
+void SkSVGDOM::render(SkCanvas* canvas) const {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+    if (fRoot) {
+        SkSVGLengthContext       lctx(fContainerSize);
+        SkSVGPresentationContext pctx;
+        fRoot->render(SkSVGRenderContext(canvas,
+                                         fFontMgr,
+                                         fResourceProvider,
+                                         fIDMapper,
+                                         lctx,
+                                         pctx,
+                                         {nullptr, nullptr},
+                                         fTextShapingFactory));
+    }
+}
+
+void SkSVGDOM::renderNode(SkCanvas* canvas, SkSVGPresentationContext& pctx, const char* id) const {
+    TRACE_EVENT0("skia", TRACE_FUNC);
+
+    if (fRoot) {
+        SkSVGLengthContext lctx(fContainerSize);
+        fRoot->renderNode(SkSVGRenderContext(canvas,
+                                             fFontMgr,
+                                             fResourceProvider,
+                                             fIDMapper,
+                                             lctx,
+                                             pctx,
+                                             {nullptr, nullptr},
+                                             fTextShapingFactory),
+                          SkSVGIRI(SkSVGIRI::Type::kLocal, SkSVGStringType(id)));
+    }
+}
+
+const SkSize& SkSVGDOM::containerSize() const {
+    return fContainerSize;
+}
+
+void SkSVGDOM::setContainerSize(const SkSize& containerSize) {
+    // TODO: inval
+    fContainerSize = containerSize;
+}
+
+sk_sp<SkSVGNode>* SkSVGDOM::findNodeById(const char* id) {
+    SkString idStr(id);
+    return this->fIDMapper.find(idStr);
+}
+
+// TODO(fuego): move this to SkSVGNode or its own CU.
+bool SkSVGNode::setAttribute(const char* attributeName, const char* attributeValue) {
+    return set_string_attribute(sk_ref_sp(this), attributeName, attributeValue);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp
new file mode 100644
index 00000000..33a8f694
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGEllipse.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGEllipse.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGTypes.h"
+#include "modules/svg/src/SkSVGRectPriv.h"
+
+SkSVGEllipse::SkSVGEllipse() : INHERITED(SkSVGTag::kEllipse) {}
+
+bool SkSVGEllipse::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setCx(SkSVGAttributeParser::parse<SkSVGLength>("cx", n, v)) ||
+           this->setCy(SkSVGAttributeParser::parse<SkSVGLength>("cy", n, v)) ||
+           this->setRx(SkSVGAttributeParser::parse<SkSVGLength>("rx", n, v)) ||
+           this->setRy(SkSVGAttributeParser::parse<SkSVGLength>("ry", n, v));
+}
+
+SkRect SkSVGEllipse::resolve(const SkSVGLengthContext& lctx) const {
+    const auto cx = lctx.resolve(fCx, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto cy = lctx.resolve(fCy, SkSVGLengthContext::LengthType::kVertical);
+
+    // https://www.w3.org/TR/SVG2/shapes.html#EllipseElement
+    //
+    // An auto value for either rx or ry is converted to a used value, following the rules given
+    // above for rectangles (but without any clamping based on width or height).
+    const auto [ rx, ry ] = ResolveOptionalRadii(fRx, fRy, lctx);
+
+    // A computed value of zero for either dimension, or a computed value of auto for both
+    // dimensions, disables rendering of the element.
+    return (rx > 0 && ry > 0)
+        ? SkRect::MakeXYWH(cx - rx, cy - ry, rx * 2, ry * 2)
+        : SkRect::MakeEmpty();
+}
+
+void SkSVGEllipse::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                          const SkPaint& paint, SkPathFillType) const {
+    canvas->drawOval(this->resolve(lctx), paint);
+}
+
+SkPath SkSVGEllipse::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = SkPath::Oval(this->resolve(ctx.lengthContext()));
+    this->mapToParent(&path);
+
+    return path;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp
new file mode 100644
index 00000000..46a89be5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFe.cpp
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+sk_sp<SkImageFilter> SkSVGFe::makeImageFilter(const SkSVGRenderContext& ctx,
+                                              const SkSVGFilterContext& fctx) const {
+    return this->onMakeImageFilter(ctx, fctx);
+}
+
+SkRect SkSVGFe::resolveBoundaries(const SkSVGRenderContext& ctx,
+                                  const SkSVGFilterContext& fctx) const {
+    const auto x = fX.isValid() ? *fX : SkSVGLength(0, SkSVGLength::Unit::kPercentage);
+    const auto y = fY.isValid() ? *fY : SkSVGLength(0, SkSVGLength::Unit::kPercentage);
+    const auto w = fWidth.isValid() ? *fWidth : SkSVGLength(100, SkSVGLength::Unit::kPercentage);
+    const auto h = fHeight.isValid() ? *fHeight : SkSVGLength(100, SkSVGLength::Unit::kPercentage);
+
+    return ctx.resolveOBBRect(x, y, w, h, fctx.primitiveUnits());
+}
+
+static bool AnyIsStandardInput(const SkSVGFilterContext& fctx,
+                               const std::vector<SkSVGFeInputType>& inputs) {
+    for (const auto& in : inputs) {
+        switch (in.type()) {
+            case SkSVGFeInputType::Type::kFilterPrimitiveReference:
+                break;
+            case SkSVGFeInputType::Type::kSourceGraphic:
+            case SkSVGFeInputType::Type::kSourceAlpha:
+            case SkSVGFeInputType::Type::kBackgroundImage:
+            case SkSVGFeInputType::Type::kBackgroundAlpha:
+            case SkSVGFeInputType::Type::kFillPaint:
+            case SkSVGFeInputType::Type::kStrokePaint:
+                return true;
+            case SkSVGFeInputType::Type::kUnspecified:
+                // Unspecified means previous result (which may be SourceGraphic).
+                if (fctx.previousResultIsSourceGraphic()) {
+                    return true;
+                }
+                break;
+        }
+    }
+
+    return false;
+}
+
+SkRect SkSVGFe::resolveFilterSubregion(const SkSVGRenderContext& ctx,
+                                       const SkSVGFilterContext& fctx) const {
+    // From https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveSubRegion,
+    // the default filter effect subregion is equal to the union of the subregions defined
+    // for all "referenced nodes" (filter effect inputs). If there are no inputs, the
+    // default subregion is equal to the filter effects region
+    // (https://www.w3.org/TR/SVG11/filters.html#FilterEffectsRegion).
+    const std::vector<SkSVGFeInputType> inputs = this->getInputs();
+    SkRect defaultSubregion;
+    if (inputs.empty() || AnyIsStandardInput(fctx, inputs)) {
+        defaultSubregion = fctx.filterEffectsRegion();
+    } else {
+        defaultSubregion = fctx.filterPrimitiveSubregion(inputs[0]);
+        for (size_t i = 1; i < inputs.size(); i++) {
+            defaultSubregion.join(fctx.filterPrimitiveSubregion(inputs[i]));
+        }
+    }
+
+    // Next resolve the rect specified by the x, y, width, height attributes on this filter effect.
+    // If those attributes were given, they override the corresponding attribute of the default
+    // filter effect subregion calculated above.
+    const SkRect boundaries = this->resolveBoundaries(ctx, fctx);
+
+    // Compute and return the fully resolved subregion.
+    return SkRect::MakeXYWH(fX.isValid() ? boundaries.fLeft : defaultSubregion.fLeft,
+                            fY.isValid() ? boundaries.fTop : defaultSubregion.fTop,
+                            fWidth.isValid() ? boundaries.width() : defaultSubregion.width(),
+                            fHeight.isValid() ? boundaries.height() : defaultSubregion.height());
+}
+
+SkSVGColorspace SkSVGFe::resolveColorspace(const SkSVGRenderContext& ctx,
+                                           const SkSVGFilterContext&) const {
+    constexpr SkSVGColorspace kDefaultCS = SkSVGColorspace::kSRGB;
+    const SkSVGColorspace cs = *ctx.presentationContext().fInherited.fColorInterpolationFilters;
+    return cs == SkSVGColorspace::kAuto ? kDefaultCS : cs;
+}
+
+void SkSVGFe::applyProperties(SkSVGRenderContext* ctx) const { this->onPrepareToRender(ctx); }
+
+bool SkSVGFe::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn(SkSVGAttributeParser::parse<SkSVGFeInputType>("in", name, value)) ||
+           this->setResult(SkSVGAttributeParser::parse<SkSVGStringType>("result", name, value)) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", name, value)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", name, value)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", name, value));
+}
+
+template <> bool SkSVGAttributeParser::parse(SkSVGFeInputType* type) {
+    static constexpr std::tuple<const char*, SkSVGFeInputType::Type> gTypeMap[] = {
+            {"SourceGraphic", SkSVGFeInputType::Type::kSourceGraphic},
+            {"SourceAlpha", SkSVGFeInputType::Type::kSourceAlpha},
+            {"BackgroundImage", SkSVGFeInputType::Type::kBackgroundImage},
+            {"BackgroundAlpha", SkSVGFeInputType::Type::kBackgroundAlpha},
+            {"FillPaint", SkSVGFeInputType::Type::kFillPaint},
+            {"StrokePaint", SkSVGFeInputType::Type::kStrokePaint},
+    };
+
+    SkSVGStringType resultId;
+    SkSVGFeInputType::Type t;
+    bool parsedValue = false;
+    if (this->parseEnumMap(gTypeMap, &t)) {
+        *type = SkSVGFeInputType(t);
+        parsedValue = true;
+    } else if (parse(&resultId)) {
+        *type = SkSVGFeInputType(resultId);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp
new file mode 100644
index 00000000..eef899c6
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeBlend.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkBlendMode.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeBlend.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeBlend::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn2(SkSVGAttributeParser::parse<SkSVGFeInputType>("in2", name, value)) ||
+           this->setMode(SkSVGAttributeParser::parse<SkSVGFeBlend::Mode>("mode", name, value));
+}
+
+static SkBlendMode GetBlendMode(SkSVGFeBlend::Mode mode) {
+    switch (mode) {
+        case SkSVGFeBlend::Mode::kNormal:
+            return SkBlendMode::kSrcOver;
+        case SkSVGFeBlend::Mode::kMultiply:
+            return SkBlendMode::kMultiply;
+        case SkSVGFeBlend::Mode::kScreen:
+            return SkBlendMode::kScreen;
+        case SkSVGFeBlend::Mode::kDarken:
+            return SkBlendMode::kDarken;
+        case SkSVGFeBlend::Mode::kLighten:
+            return SkBlendMode::kLighten;
+    }
+
+    SkUNREACHABLE;
+}
+
+sk_sp<SkImageFilter> SkSVGFeBlend::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkBlendMode blendMode = GetBlendMode(this->getMode());
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+    const sk_sp<SkImageFilter> background = fctx.resolveInput(ctx, fIn2, colorspace);
+    const sk_sp<SkImageFilter> foreground = fctx.resolveInput(ctx, this->getIn(), colorspace);
+    return SkImageFilters::Blend(blendMode, background, foreground, cropRect);
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeBlend::Mode>(
+        SkSVGFeBlend::Mode* mode) {
+    static constexpr std::tuple<const char*, SkSVGFeBlend::Mode> gMap[] = {
+        { "normal"  , SkSVGFeBlend::Mode::kNormal   },
+        { "multiply", SkSVGFeBlend::Mode::kMultiply },
+        { "screen"  , SkSVGFeBlend::Mode::kScreen   },
+        { "darken"  , SkSVGFeBlend::Mode::kDarken   },
+        { "lighten" , SkSVGFeBlend::Mode::kLighten  },
+    };
+
+    return this->parseEnumMap(gMap, mode) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp
new file mode 100644
index 00000000..4c8b34ab
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeColorMatrix.cpp
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "include/private/SkColorData.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeColorMatrix.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeColorMatrix::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setType(
+                   SkSVGAttributeParser::parse<SkSVGFeColorMatrixType>("type", name, value)) ||
+           this->setValues(
+                   SkSVGAttributeParser::parse<SkSVGFeColorMatrixValues>("values", name, value));
+}
+
+SkColorMatrix SkSVGFeColorMatrix::makeMatrixForType() const {
+    if (fValues.empty() && fType != SkSVGFeColorMatrixType::kLuminanceToAlpha) {
+        return SkColorMatrix();
+    }
+
+    switch (fType) {
+        case SkSVGFeColorMatrixType::kMatrix: {
+            if (fValues.size() < 20) {
+                return SkColorMatrix();
+            }
+            SkColorMatrix m;
+            m.setRowMajor(fValues.data());
+            return m;
+        }
+        case SkSVGFeColorMatrixType::kSaturate:
+            return MakeSaturate(!fValues.empty() ? fValues[0] : 1);
+        case SkSVGFeColorMatrixType::kHueRotate:
+            return MakeHueRotate(!fValues.empty() ? fValues[0] : 0);
+        case SkSVGFeColorMatrixType::kLuminanceToAlpha:
+            return MakeLuminanceToAlpha();
+    }
+
+    SkUNREACHABLE;
+}
+
+SkColorMatrix SkSVGFeColorMatrix::MakeSaturate(SkSVGNumberType s) {
+    SkColorMatrix m;
+    m.setSaturation(s);
+    return m;
+}
+
+SkColorMatrix SkSVGFeColorMatrix::MakeHueRotate(SkSVGNumberType degrees) {
+    const SkScalar theta = SkDegreesToRadians(degrees);
+    const SkSVGNumberType c = SkScalarCos(theta);
+    const SkSVGNumberType s = SkScalarSin(theta);
+    return SkColorMatrix(
+        0.213f + c* 0.787f + s*-0.213f,
+        0.715f + c*-0.715f + s*-0.715f,
+        0.072f + c*-0.072f + s* 0.928f,
+        0,
+        0,
+
+        0.213f + c*-0.213f + s* 0.143f,
+        0.715f + c* 0.285f + s* 0.140f,
+        0.072f + c*-0.072f + s*-0.283f,
+        0,
+        0,
+
+        0.213f + c*-0.213f + s*-0.787f,
+        0.715f + c*-0.715f + s* 0.715f,
+        0.072f + c* 0.928f + s* 0.072f,
+        0,
+        0,
+
+        0,0,0,1,0
+    );
+}
+
+SkColorMatrix SkSVGFeColorMatrix::MakeLuminanceToAlpha() {
+    return SkColorMatrix(
+        0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0,
+        0, 0, 0, 0, 0,
+        SK_LUM_COEFF_R, SK_LUM_COEFF_G, SK_LUM_COEFF_B, 0, 0
+    );
+}
+
+sk_sp<SkImageFilter> SkSVGFeColorMatrix::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                           const SkSVGFilterContext& fctx) const {
+    return SkImageFilters::ColorFilter(
+            SkColorFilters::Matrix(makeMatrixForType()),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+template <> bool SkSVGAttributeParser::parse(SkSVGFeColorMatrixType* type) {
+    static constexpr std::tuple<const char*, SkSVGFeColorMatrixType> gTypeMap[] = {
+            {"matrix", SkSVGFeColorMatrixType::kMatrix},
+            {"saturate", SkSVGFeColorMatrixType::kSaturate},
+            {"hueRotate", SkSVGFeColorMatrixType::kHueRotate},
+            {"luminanceToAlpha", SkSVGFeColorMatrixType::kLuminanceToAlpha},
+    };
+
+    return this->parseEnumMap(gTypeMap, type) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp
new file mode 100644
index 00000000..cb227117
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComponentTransfer.cpp
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGFeComponentTransfer.h"
+
+#include "include/core/SkColorFilter.h"
+#include "include/core/SkImageFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "include/private/base/SkAssert.h"
+#include "include/private/base/SkFloatingPoint.h"
+#include "include/private/base/SkTPin.h"
+#include "include/private/base/SkTo.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+#include <cmath>
+#include <cstdint>
+
+sk_sp<SkImageFilter> SkSVGFeComponentTransfer::onMakeImageFilter(
+        const SkSVGRenderContext& ctx,
+        const SkSVGFilterContext& fctx) const {
+    std::vector<uint8_t> a_tbl, b_tbl, g_tbl, r_tbl;
+
+    for (const auto& child : fChildren) {
+        switch (child->tag()) {
+            case SkSVGTag::kFeFuncA:
+                a_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            case SkSVGTag::kFeFuncB:
+                b_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            case SkSVGTag::kFeFuncG:
+                g_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            case SkSVGTag::kFeFuncR:
+                r_tbl = static_cast<const SkSVGFeFunc*>(child.get())->getTable();
+                break;
+            default:
+                break;
+        }
+    }
+    SkASSERT(a_tbl.empty() || a_tbl.size() == 256);
+    SkASSERT(b_tbl.empty() || b_tbl.size() == 256);
+    SkASSERT(g_tbl.empty() || g_tbl.size() == 256);
+    SkASSERT(r_tbl.empty() || r_tbl.size() == 256);
+
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const sk_sp<SkImageFilter> input = fctx.resolveInput(ctx,
+                                                         this->getIn(),
+                                                         this->resolveColorspace(ctx, fctx));
+
+    const auto cf =  SkColorFilters::TableARGB(a_tbl.empty() ? nullptr : a_tbl.data(),
+                                               r_tbl.empty() ? nullptr : r_tbl.data(),
+                                               g_tbl.empty() ? nullptr : g_tbl.data(),
+                                               b_tbl.empty() ? nullptr : b_tbl.data());
+
+    return SkImageFilters::ColorFilter(std::move(cf), std::move(input), cropRect);
+}
+
+std::vector<uint8_t> SkSVGFeFunc::getTable() const {
+    // https://www.w3.org/TR/SVG11/filters.html#feComponentTransferTypeAttribute
+    const auto make_linear = [this]() -> std::vector<uint8_t> {
+        std::vector<uint8_t> tbl(256);
+        const float slope = this->getSlope(),
+             intercept255 = this->getIntercept() * 255;
+
+        for (size_t i = 0; i < 256; ++i) {
+            tbl[i] = SkTPin<int>(sk_float_round2int(intercept255 + i * slope), 0, 255);
+        }
+
+        return tbl;
+    };
+
+    const auto make_gamma = [this]() -> std::vector<uint8_t> {
+        std::vector<uint8_t> tbl(256);
+        const float exponent = this->getExponent(),
+                      offset = this->getOffset();
+
+        for (size_t i = 0; i < 256; ++i) {
+            const float component = offset + std::pow(i * (1 / 255.f), exponent);
+            tbl[i] = SkTPin<int>(sk_float_round2int(component * 255), 0, 255);
+        }
+
+        return tbl;
+    };
+
+    const auto lerp_from_table_values = [this](auto lerp_func) -> std::vector<uint8_t> {
+        const auto& vals = this->getTableValues();
+        if (vals.size() < 2 || vals.size() > 255) {
+            return {};
+        }
+
+        // number of interpolation intervals
+        const size_t n = vals.size() - 1;
+
+        std::vector<uint8_t> tbl(256);
+        for (size_t k = 0; k < n; ++k) {
+            // interpolation values
+            const SkSVGNumberType v0 = SkTPin(vals[k + 0], 0.f, 1.f),
+                                  v1 = SkTPin(vals[k + 1], 0.f, 1.f);
+
+            // start/end component table indices
+            const size_t c_start = k * 255 / n,
+                         c_end   = (k + 1) * 255 / n;
+            SkASSERT(c_end <= 255);
+
+            for (size_t ci = c_start; ci < c_end; ++ci) {
+                const float lerp_t = static_cast<float>(ci - c_start) / (c_end - c_start),
+                         component = lerp_func(v0, v1, lerp_t);
+                SkASSERT(component >= 0 && component <= 1);
+
+                tbl[ci] = SkToU8(sk_float_round2int(component * 255));
+            }
+        }
+
+        tbl.back() = SkToU8(sk_float_round2int(255 * SkTPin(vals.back(), 0.f, 1.f)));
+
+        return tbl;
+    };
+
+    const auto make_table = [&]() -> std::vector<uint8_t> {
+        return lerp_from_table_values([](float v0, float v1, float t) {
+            return v0 + (v1 - v0) * t;
+        });
+    };
+
+    const auto make_discrete = [&]() -> std::vector<uint8_t> {
+        return lerp_from_table_values([](float v0, float v1, float t) {
+            return v0;
+        });
+    };
+
+    switch (this->getType()) {
+        case SkSVGFeFuncType::kIdentity: return {};
+        case SkSVGFeFuncType::kTable:    return make_table();
+        case SkSVGFeFuncType::kDiscrete: return make_discrete();
+        case SkSVGFeFuncType::kLinear:   return make_linear();
+        case SkSVGFeFuncType::kGamma:    return make_gamma();
+    }
+
+    SkUNREACHABLE;
+}
+
+bool SkSVGFeFunc::parseAndSetAttribute(const char* name, const char* val) {
+    return INHERITED::parseAndSetAttribute(name, val) ||
+      this->setAmplitude(SkSVGAttributeParser::parse<SkSVGNumberType>("amplitude", name, val)) ||
+      this->setExponent(SkSVGAttributeParser::parse<SkSVGNumberType>("exponent", name, val)) ||
+      this->setIntercept(SkSVGAttributeParser::parse<SkSVGNumberType>("intercept", name, val)) ||
+      this->setOffset(SkSVGAttributeParser::parse<SkSVGNumberType>("offset", name, val)) ||
+      this->setSlope(SkSVGAttributeParser::parse<SkSVGNumberType>("slope", name, val)) ||
+      this->setTableValues(SkSVGAttributeParser::parse<std::vector<SkSVGNumberType>>("tableValues",
+                                                                                     name, val)) ||
+      this->setType(SkSVGAttributeParser::parse<SkSVGFeFuncType>("type", name, val));
+}
+
+template <>
+bool SkSVGAttributeParser::parse(SkSVGFeFuncType* type) {
+    static constexpr std::tuple<const char*, SkSVGFeFuncType> gTypeMap[] = {
+            { "identity", SkSVGFeFuncType::kIdentity },
+            { "table"   , SkSVGFeFuncType::kTable    },
+            { "discrete", SkSVGFeFuncType::kDiscrete },
+            { "linear"  , SkSVGFeFuncType::kLinear   },
+            { "gamma"   , SkSVGFeFuncType::kGamma    },
+    };
+
+    return this->parseEnumMap(gTypeMap, type) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp
new file mode 100644
index 00000000..3ae12d9f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeComposite.cpp
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeComposite.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+bool SkSVGFeComposite::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           // SkSVGFeInputType parsing defined in SkSVGFe.cpp:
+           this->setIn2(SkSVGAttributeParser::parse<SkSVGFeInputType>("in2", name, value)) ||
+           this->setK1(SkSVGAttributeParser::parse<SkSVGNumberType>("k1", name, value)) ||
+           this->setK2(SkSVGAttributeParser::parse<SkSVGNumberType>("k2", name, value)) ||
+           this->setK3(SkSVGAttributeParser::parse<SkSVGNumberType>("k3", name, value)) ||
+           this->setK4(SkSVGAttributeParser::parse<SkSVGNumberType>("k4", name, value)) ||
+           this->setOperator(
+                   SkSVGAttributeParser::parse<SkSVGFeCompositeOperator>("operator", name, value));
+}
+
+SkBlendMode SkSVGFeComposite::BlendModeForOperator(SkSVGFeCompositeOperator op) {
+    switch (op) {
+        case SkSVGFeCompositeOperator::kOver:
+            return SkBlendMode::kSrcOver;
+        case SkSVGFeCompositeOperator::kIn:
+            return SkBlendMode::kSrcIn;
+        case SkSVGFeCompositeOperator::kOut:
+            return SkBlendMode::kSrcOut;
+        case SkSVGFeCompositeOperator::kAtop:
+            return SkBlendMode::kSrcATop;
+        case SkSVGFeCompositeOperator::kXor:
+            return SkBlendMode::kXor;
+        case SkSVGFeCompositeOperator::kArithmetic:
+            // Arithmetic is not handled with a blend
+            SkASSERT(false);
+            return SkBlendMode::kSrcOver;
+    }
+
+    SkUNREACHABLE;
+}
+
+sk_sp<SkImageFilter> SkSVGFeComposite::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                         const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+    const sk_sp<SkImageFilter> background = fctx.resolveInput(ctx, fIn2, colorspace);
+    const sk_sp<SkImageFilter> foreground = fctx.resolveInput(ctx, this->getIn(), colorspace);
+    if (fOperator == SkSVGFeCompositeOperator::kArithmetic) {
+        constexpr bool enforcePMColor = true;
+        return SkImageFilters::Arithmetic(
+                fK1, fK2, fK3, fK4, enforcePMColor, background, foreground, cropRect);
+    } else {
+        return SkImageFilters::Blend(
+                BlendModeForOperator(fOperator), background, foreground, cropRect);
+    }
+}
+
+template <> bool SkSVGAttributeParser::parse(SkSVGFeCompositeOperator* op) {
+    static constexpr std::tuple<const char*, SkSVGFeCompositeOperator> gOpMap[] = {
+            {"over", SkSVGFeCompositeOperator::kOver},
+            {"in", SkSVGFeCompositeOperator::kIn},
+            {"out", SkSVGFeCompositeOperator::kOut},
+            {"atop", SkSVGFeCompositeOperator::kAtop},
+            {"xor", SkSVGFeCompositeOperator::kXor},
+            {"arithmetic", SkSVGFeCompositeOperator::kArithmetic},
+    };
+
+    return this->parseEnumMap(gOpMap, op) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp
new file mode 100644
index 00000000..9698a55c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeDisplacementMap.cpp
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeDisplacementMap.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeDisplacementMap::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn2(SkSVGAttributeParser::parse<SkSVGFeInputType>("in2", name, value)) ||
+           this->setXChannelSelector(
+                   SkSVGAttributeParser::parse<SkSVGFeDisplacementMap::ChannelSelector>(
+                           "xChannelSelector", name, value)) ||
+           this->setYChannelSelector(
+                   SkSVGAttributeParser::parse<SkSVGFeDisplacementMap::ChannelSelector>(
+                           "yChannelSelector", name, value)) ||
+           this->setScale(SkSVGAttributeParser::parse<SkSVGNumberType>("scale", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDisplacementMap::onMakeImageFilter(
+        const SkSVGRenderContext& ctx, const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+
+    // According to spec https://www.w3.org/TR/SVG11/filters.html#feDisplacementMapElement,
+    // the 'in' source image must remain in its current colorspace.
+    sk_sp<SkImageFilter> in = fctx.resolveInput(ctx, this->getIn());
+    sk_sp<SkImageFilter> in2 = fctx.resolveInput(ctx, this->getIn2(), colorspace);
+
+    SkScalar scale = fScale;
+    if (fctx.primitiveUnits().type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox) {
+        const auto obbt = ctx.transformForCurrentOBB(fctx.primitiveUnits());
+        scale = SkSVGLengthContext({obbt.scale.x, obbt.scale.y})
+                    .resolve(SkSVGLength(scale, SkSVGLength::Unit::kPercentage),
+                             SkSVGLengthContext::LengthType::kOther);
+    }
+
+    return SkImageFilters::DisplacementMap(
+            fXChannelSelector, fYChannelSelector, scale, in2, in, cropRect);
+}
+
+SkSVGColorspace SkSVGFeDisplacementMap::resolveColorspace(const SkSVGRenderContext& ctx,
+                                                          const SkSVGFilterContext& fctx) const {
+    // According to spec https://www.w3.org/TR/SVG11/filters.html#feDisplacementMapElement,
+    // the 'in' source image must remain in its current colorspace, which means the colorspace of
+    // this FE node is the same as the input.
+    return fctx.resolveInputColorspace(ctx, this->getIn());
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeDisplacementMap::ChannelSelector>(
+        SkSVGFeDisplacementMap::ChannelSelector* channel) {
+    static constexpr std::tuple<const char*, SkSVGFeDisplacementMap::ChannelSelector> gMap[] = {
+            { "R", SkSVGFeDisplacementMap::ChannelSelector::kR },
+            { "G", SkSVGFeDisplacementMap::ChannelSelector::kG },
+            { "B", SkSVGFeDisplacementMap::ChannelSelector::kB },
+            { "A", SkSVGFeDisplacementMap::ChannelSelector::kA },
+    };
+
+    return this->parseEnumMap(gMap, channel) && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp
new file mode 100644
index 00000000..7dccc235
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeFlood.cpp
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGFeFlood.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkColor SkSVGFeFlood::resolveFloodColor(const SkSVGRenderContext& ctx) const {
+    const auto floodColor = this->getFloodColor();
+    const auto floodOpacity = this->getFloodOpacity();
+    // Uninherited presentation attributes should have a concrete value by now.
+    if (!floodColor.isValue() || !floodOpacity.isValue()) {
+        SkDebugf("unhandled: flood-color or flood-opacity has no value\n");
+        return SK_ColorBLACK;
+    }
+
+    const SkColor color = ctx.resolveSvgColor(*floodColor);
+    return SkColorSetA(color, SkScalarRoundToInt(*floodOpacity * 255));
+}
+
+sk_sp<SkImageFilter> SkSVGFeFlood::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    return SkImageFilters::Shader(SkShaders::Color(resolveFloodColor(ctx)),
+                                  this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp
new file mode 100644
index 00000000..1443845a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeGaussianBlur.cpp
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeGaussianBlur.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeGaussianBlur::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setStdDeviation(SkSVGAttributeParser::parse<SkSVGFeGaussianBlur::StdDeviation>(
+                   "stdDeviation", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeGaussianBlur::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                            const SkSVGFilterContext& fctx) const {
+    const auto sigma = SkV2{fStdDeviation.fX, fStdDeviation.fY}
+                     * ctx.transformForCurrentOBB(fctx.primitiveUnits()).scale;
+
+    return SkImageFilters::Blur(
+            sigma.x, sigma.y,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeGaussianBlur::StdDeviation>(
+        SkSVGFeGaussianBlur::StdDeviation* stdDeviation) {
+    std::vector<SkSVGNumberType> values;
+    if (!this->parse(&values)) {
+        return false;
+    }
+
+    stdDeviation->fX = values[0];
+    stdDeviation->fY = values.size() > 1 ? values[1] : values[0];
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp
new file mode 100644
index 00000000..9767b371
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeImage.cpp
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkSamplingOptions.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGFeImage.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGImage.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeImage::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", n, v)) ||
+           this->setPreserveAspectRatio(SkSVGAttributeParser::parse<SkSVGPreserveAspectRatio>(
+                   "preserveAspectRatio", n, v));
+}
+
+sk_sp<SkImageFilter> SkSVGFeImage::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    // Load image and map viewbox (image bounds) to viewport (filter effects subregion).
+    const SkRect viewport = this->resolveFilterSubregion(ctx, fctx);
+    const auto imgInfo =
+            SkSVGImage::LoadImage(ctx.resourceProvider(), fHref, viewport, fPreserveAspectRatio);
+    if (!imgInfo.fImage) {
+        return nullptr;
+    }
+
+    // Create the image filter mapped according to aspect ratio
+    const SkRect srcRect = SkRect::Make(imgInfo.fImage->bounds());
+    const SkRect& dstRect = imgInfo.fDst;
+    // TODO: image-rendering property
+    auto imgfilt = SkImageFilters::Image(imgInfo.fImage, srcRect, dstRect,
+                                         SkSamplingOptions(SkFilterMode::kLinear,
+                                                           SkMipmapMode::kNearest));
+
+    // Aspect ratio mapping may end up drawing content outside of the filter effects region,
+    // so perform an explicit crop.
+    return SkImageFilters::Merge(&imgfilt, 1, fctx.filterEffectsRegion());
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp
new file mode 100644
index 00000000..2f059570
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLightSource.cpp
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeLightSource.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkPoint3 SkSVGFeDistantLight::computeDirection() const {
+    // Computing direction from azimuth+elevation is two 3D rotations:
+    //  - Rotate [1,0,0] about y axis first (elevation)
+    //  - Rotate result about z axis (azimuth)
+    // Which is just the first column vector in the 3x3 matrix Rz*Ry.
+    const float azimuthRad = SkDegreesToRadians(fAzimuth);
+    const float elevationRad = SkDegreesToRadians(fElevation);
+    const float sinAzimuth = sinf(azimuthRad), cosAzimuth = cosf(azimuthRad);
+    const float sinElevation = sinf(elevationRad), cosElevation = cosf(elevationRad);
+    return SkPoint3::Make(cosAzimuth * cosElevation, sinAzimuth * cosElevation, sinElevation);
+}
+
+bool SkSVGFeDistantLight::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setAzimuth(SkSVGAttributeParser::parse<SkSVGNumberType>("azimuth", n, v)) ||
+           this->setElevation(SkSVGAttributeParser::parse<SkSVGNumberType>("elevation", n, v));
+}
+
+bool SkSVGFePointLight::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGNumberType>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGNumberType>("y", n, v)) ||
+           this->setZ(SkSVGAttributeParser::parse<SkSVGNumberType>("z", n, v));
+}
+
+bool SkSVGFeSpotLight::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGNumberType>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGNumberType>("y", n, v)) ||
+           this->setZ(SkSVGAttributeParser::parse<SkSVGNumberType>("z", n, v)) ||
+           this->setPointsAtX(SkSVGAttributeParser::parse<SkSVGNumberType>("pointsAtX", n, v)) ||
+           this->setPointsAtY(SkSVGAttributeParser::parse<SkSVGNumberType>("pointsAtY", n, v)) ||
+           this->setPointsAtZ(SkSVGAttributeParser::parse<SkSVGNumberType>("pointsAtZ", n, v)) ||
+           this->setSpecularExponent(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("specularExponent", n, v)) ||
+           this->setLimitingConeAngle(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("limitingConeAngle", n, v));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp
new file mode 100644
index 00000000..61816b97
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeLighting.cpp
@@ -0,0 +1,190 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkPoint3.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeLightSource.h"
+#include "modules/svg/include/SkSVGFeLighting.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeLighting::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setSurfaceScale(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("surfaceScale", n, v)) ||
+           this->setKernelUnitLength(SkSVGAttributeParser::parse<SkSVGFeLighting::KernelUnitLength>(
+                   "kernelUnitLength", n, v));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeLighting::KernelUnitLength>(
+        SkSVGFeLighting::KernelUnitLength* kernelUnitLength) {
+    std::vector<SkSVGNumberType> values;
+    if (!this->parse(&values)) {
+        return false;
+    }
+
+    kernelUnitLength->fDx = values[0];
+    kernelUnitLength->fDy = values.size() > 1 ? values[1] : values[0];
+    return true;
+}
+
+sk_sp<SkImageFilter> SkSVGFeLighting::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                        const SkSVGFilterContext& fctx) const {
+    for (const auto& child : fChildren) {
+        switch (child->tag()) {
+            case SkSVGTag::kFeDistantLight:
+                return this->makeDistantLight(
+                        ctx, fctx, static_cast<const SkSVGFeDistantLight*>(child.get()));
+            case SkSVGTag::kFePointLight:
+                return this->makePointLight(
+                        ctx, fctx, static_cast<const SkSVGFePointLight*>(child.get()));
+            case SkSVGTag::kFeSpotLight:
+                return this->makeSpotLight(
+                        ctx, fctx, static_cast<const SkSVGFeSpotLight*>(child.get()));
+            default:
+                // Ignore unknown children, such as <desc> elements
+                break;
+        }
+    }
+
+    SkDebugf("lighting filter effect needs exactly one light source\n");
+    return nullptr;
+}
+
+SkColor SkSVGFeLighting::resolveLightingColor(const SkSVGRenderContext& ctx) const {
+    const auto color = this->getLightingColor();
+    if (!color.isValue()) {
+        // Uninherited presentation attributes should have a concrete value by now.
+        SkDebugf("unhandled: lighting-color has no value\n");
+        return SK_ColorWHITE;
+    }
+
+    return ctx.resolveSvgColor(*color);
+}
+
+SkPoint3 SkSVGFeLighting::resolveXYZ(const SkSVGRenderContext& ctx,
+                                     const SkSVGFilterContext& fctx,
+                                     SkSVGNumberType x,
+                                     SkSVGNumberType y,
+                                     SkSVGNumberType z) const {
+    const auto obbt = ctx.transformForCurrentOBB(fctx.primitiveUnits());
+    const auto xy = SkV2{x,y} * obbt.scale + obbt.offset;
+    z = SkSVGLengthContext({obbt.scale.x, obbt.scale.y})
+            .resolve(SkSVGLength(z * 100.f, SkSVGLength::Unit::kPercentage),
+                     SkSVGLengthContext::LengthType::kOther);
+    return SkPoint3::Make(xy.x, xy.y, z);
+}
+
+bool SkSVGFeSpecularLighting::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setSpecularConstant(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("specularConstant", n, v)) ||
+           this->setSpecularExponent(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("specularExponent", n, v));
+}
+
+sk_sp<SkImageFilter> SkSVGFeSpecularLighting::makeDistantLight(
+        const SkSVGRenderContext& ctx,
+        const SkSVGFilterContext& fctx,
+        const SkSVGFeDistantLight* light) const {
+    const SkPoint3 dir = light->computeDirection();
+    return SkImageFilters::DistantLitSpecular(
+            this->resolveXYZ(ctx, fctx, dir.fX, dir.fY, dir.fZ),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            fSpecularConstant,
+            fSpecularExponent,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeSpecularLighting::makePointLight(const SkSVGRenderContext& ctx,
+                                                             const SkSVGFilterContext& fctx,
+                                                             const SkSVGFePointLight* light) const {
+    return SkImageFilters::PointLitSpecular(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            fSpecularConstant,
+            fSpecularExponent,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeSpecularLighting::makeSpotLight(const SkSVGRenderContext& ctx,
+                                                            const SkSVGFilterContext& fctx,
+                                                            const SkSVGFeSpotLight* light) const {
+    const auto& limitingConeAngle = light->getLimitingConeAngle();
+    const float cutoffAngle = limitingConeAngle.isValid() ? *limitingConeAngle : 180.f;
+
+    return SkImageFilters::SpotLitSpecular(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveXYZ(
+                    ctx, fctx, light->getPointsAtX(), light->getPointsAtY(), light->getPointsAtZ()),
+            light->getSpecularExponent(),
+            cutoffAngle,
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            fSpecularConstant,
+            fSpecularExponent,
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+bool SkSVGFeDiffuseLighting::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setDiffuseConstant(
+                   SkSVGAttributeParser::parse<SkSVGNumberType>("diffuseConstant", n, v));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDiffuseLighting::makeDistantLight(
+        const SkSVGRenderContext& ctx,
+        const SkSVGFilterContext& fctx,
+        const SkSVGFeDistantLight* light) const {
+    const SkPoint3 dir = light->computeDirection();
+    return SkImageFilters::DistantLitDiffuse(
+            this->resolveXYZ(ctx, fctx, dir.fX, dir.fY, dir.fZ),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            this->getDiffuseConstant(),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDiffuseLighting::makePointLight(const SkSVGRenderContext& ctx,
+                                                            const SkSVGFilterContext& fctx,
+                                                            const SkSVGFePointLight* light) const {
+    return SkImageFilters::PointLitDiffuse(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            this->getDiffuseConstant(),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
+
+sk_sp<SkImageFilter> SkSVGFeDiffuseLighting::makeSpotLight(const SkSVGRenderContext& ctx,
+                                                           const SkSVGFilterContext& fctx,
+                                                           const SkSVGFeSpotLight* light) const {
+    const auto& limitingConeAngle = light->getLimitingConeAngle();
+    const float cutoffAngle = limitingConeAngle.isValid() ? *limitingConeAngle : 180.f;
+
+    return SkImageFilters::SpotLitDiffuse(
+            this->resolveXYZ(ctx, fctx, light->getX(), light->getY(), light->getZ()),
+            this->resolveXYZ(
+                    ctx, fctx, light->getPointsAtX(), light->getPointsAtY(), light->getPointsAtZ()),
+            light->getSpecularExponent(),
+            cutoffAngle,
+            this->resolveLightingColor(ctx),
+            this->getSurfaceScale(),
+            this->getDiffuseConstant(),
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx)),
+            this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp
new file mode 100644
index 00000000..6d476b34
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMerge.cpp
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGFeMerge.h"
+
+#include "include/core/SkImageFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "include/private/base/SkTArray.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGNode.h"
+
+bool SkSVGFeMergeNode::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setIn(SkSVGAttributeParser::parse<SkSVGFeInputType>("in", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeMerge::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                     const SkSVGFilterContext& fctx) const {
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+
+    skia_private::STArray<8, sk_sp<SkImageFilter>> merge_node_filters;
+    merge_node_filters.reserve(fChildren.size());
+
+    this->forEachChild<SkSVGFeMergeNode>([&](const SkSVGFeMergeNode* child) {
+        merge_node_filters.push_back(fctx.resolveInput(ctx, child->getIn(), colorspace));
+    });
+
+    return SkImageFilters::Merge(merge_node_filters.data(),
+                                 merge_node_filters.size(),
+                                 this->resolveFilterSubregion(ctx, fctx));
+}
+
+std::vector<SkSVGFeInputType> SkSVGFeMerge::getInputs() const {
+    std::vector<SkSVGFeInputType> inputs;
+    inputs.reserve(fChildren.size());
+
+    this->forEachChild<SkSVGFeMergeNode>([&](const SkSVGFeMergeNode* child) {
+        inputs.push_back(child->getIn());
+    });
+
+    return inputs;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp
new file mode 100644
index 00000000..77b834bc
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeMorphology.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeMorphology.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeMorphology::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setOperator(SkSVGAttributeParser::parse<SkSVGFeMorphology::Operator>(
+                   "operator", name, value)) ||
+           this->setRadius(SkSVGAttributeParser::parse<SkSVGFeMorphology::Radius>(
+                   "radius", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeMorphology::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                          const SkSVGFilterContext& fctx) const {
+    const SkRect cropRect = this->resolveFilterSubregion(ctx, fctx);
+    const SkSVGColorspace colorspace = this->resolveColorspace(ctx, fctx);
+    sk_sp<SkImageFilter> input = fctx.resolveInput(ctx, this->getIn(), colorspace);
+
+    const auto r = SkV2{fRadius.fX, fRadius.fY}
+                 * ctx.transformForCurrentOBB(fctx.primitiveUnits()).scale;
+    switch (fOperator) {
+        case Operator::kErode:
+            return SkImageFilters::Erode(r.x, r.y, input, cropRect);
+        case Operator::kDilate:
+            return SkImageFilters::Dilate(r.x, r.y, input, cropRect);
+    }
+
+    SkUNREACHABLE;
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeMorphology::Operator>(SkSVGFeMorphology::Operator* op) {
+    static constexpr std::tuple<const char*, SkSVGFeMorphology::Operator> gMap[] = {
+            { "dilate", SkSVGFeMorphology::Operator::kDilate },
+            { "erode" , SkSVGFeMorphology::Operator::kErode  },
+    };
+
+    return this->parseEnumMap(gMap, op) && this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeMorphology::Radius>(SkSVGFeMorphology::Radius* radius) {
+    std::vector<SkSVGNumberType> values;
+    if (!this->parse(&values)) {
+        return false;
+    }
+
+    radius->fX = values[0];
+    radius->fY = values.size() > 1 ? values[1] : values[0];
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp
new file mode 100644
index 00000000..057a4048
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeOffset.cpp
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeOffset.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeOffset::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setDx(SkSVGAttributeParser::parse<SkSVGNumberType>("dx", name, value)) ||
+           this->setDy(SkSVGAttributeParser::parse<SkSVGNumberType>("dy", name, value));
+}
+
+sk_sp<SkImageFilter> SkSVGFeOffset::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                      const SkSVGFilterContext& fctx) const {
+    const auto d = SkV2{this->getDx(), this->getDy()}
+                 * ctx.transformForCurrentOBB(fctx.primitiveUnits()).scale;
+
+    sk_sp<SkImageFilter> in =
+            fctx.resolveInput(ctx, this->getIn(), this->resolveColorspace(ctx, fctx));
+    return SkImageFilters::Offset(d.x, d.y, std::move(in), this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp
new file mode 100644
index 00000000..8357e6e5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFeTurbulence.cpp
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/effects/SkImageFilters.h"
+#include "include/effects/SkPerlinNoiseShader.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGFeTurbulence.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFeTurbulence::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setNumOctaves(
+                   SkSVGAttributeParser::parse<SkSVGIntegerType>("numOctaves", name, value)) ||
+           this->setSeed(SkSVGAttributeParser::parse<SkSVGNumberType>("seed", name, value)) ||
+           this->setBaseFrequency(SkSVGAttributeParser::parse<SkSVGFeTurbulenceBaseFrequency>(
+                   "baseFrequency", name, value)) ||
+           this->setTurbulenceType(SkSVGAttributeParser::parse<SkSVGFeTurbulenceType>(
+                   "type", name, value));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeTurbulenceBaseFrequency>(
+        SkSVGFeTurbulenceBaseFrequency* freq) {
+    SkSVGNumberType freqX;
+    if (!this->parse(&freqX)) {
+        return false;
+    }
+
+    SkSVGNumberType freqY;
+    this->parseCommaWspToken();
+    if (this->parse(&freqY)) {
+        *freq = SkSVGFeTurbulenceBaseFrequency(freqX, freqY);
+    } else {
+        *freq = SkSVGFeTurbulenceBaseFrequency(freqX, freqX);
+    }
+
+    return this->parseEOSToken();
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkSVGFeTurbulenceType>(SkSVGFeTurbulenceType* type) {
+    bool parsedValue = false;
+
+    if (this->parseExpectedStringToken("fractalNoise")) {
+        *type = SkSVGFeTurbulenceType(SkSVGFeTurbulenceType::kFractalNoise);
+        parsedValue = true;
+    } else if (this->parseExpectedStringToken("turbulence")) {
+        *type = SkSVGFeTurbulenceType(SkSVGFeTurbulenceType::kTurbulence);
+        parsedValue = true;
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
+
+sk_sp<SkImageFilter> SkSVGFeTurbulence::onMakeImageFilter(const SkSVGRenderContext& ctx,
+                                                          const SkSVGFilterContext& fctx) const {
+    const SkISize* tileSize = nullptr;  // TODO: needs filter element subregion properties
+
+    sk_sp<SkShader> shader;
+    switch (fTurbulenceType.fType) {
+        case SkSVGFeTurbulenceType::Type::kTurbulence:
+            shader = SkShaders::MakeTurbulence(
+                    fBaseFrequency.freqX(), fBaseFrequency.freqY(), fNumOctaves, fSeed, tileSize);
+            break;
+        case SkSVGFeTurbulenceType::Type::kFractalNoise:
+            shader = SkShaders::MakeFractalNoise(
+                    fBaseFrequency.freqX(), fBaseFrequency.freqY(), fNumOctaves, fSeed, tileSize);
+            break;
+    }
+
+    return SkImageFilters::Shader(shader, this->resolveFilterSubregion(ctx, fctx));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp
new file mode 100644
index 00000000..0258c3d2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilter.cpp
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorFilter.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGFe.h"
+#include "modules/svg/include/SkSVGFilter.h"
+#include "modules/svg/include/SkSVGFilterContext.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGFilter::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", name, value)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", name, value)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", name, value)) ||
+           this->setFilterUnits(SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(
+                   "filterUnits", name, value)) ||
+           this->setPrimitiveUnits(SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(
+                   "primitiveUnits", name, value));
+}
+
+void SkSVGFilter::applyProperties(SkSVGRenderContext* ctx) const { this->onPrepareToRender(ctx); }
+
+sk_sp<SkImageFilter> SkSVGFilter::buildFilterDAG(const SkSVGRenderContext& ctx) const {
+    sk_sp<SkImageFilter> filter;
+    SkSVGFilterContext fctx(ctx.resolveOBBRect(fX, fY, fWidth, fHeight, fFilterUnits),
+                            fPrimitiveUnits);
+    SkSVGRenderContext localCtx(ctx);
+    this->applyProperties(&localCtx);
+    SkSVGColorspace cs = SkSVGColorspace::kSRGB;
+    for (const auto& child : fChildren) {
+        if (!SkSVGFe::IsFilterEffect(child)) {
+            continue;
+        }
+
+        const auto& feNode = static_cast<const SkSVGFe&>(*child);
+        const auto& feResultType = feNode.getResult();
+
+        // Propagate any inherited properties that may impact filter effect behavior (e.g.
+        // color-interpolation-filters). We call this explicitly here because the SkSVGFe
+        // nodes do not participate in the normal onRender path, which is when property
+        // propagation currently occurs.
+        SkSVGRenderContext localChildCtx(localCtx);
+        feNode.applyProperties(&localChildCtx);
+
+        const SkRect filterSubregion = feNode.resolveFilterSubregion(localChildCtx, fctx);
+        cs = feNode.resolveColorspace(localChildCtx, fctx);
+        filter = feNode.makeImageFilter(localChildCtx, fctx);
+
+        if (!feResultType.isEmpty()) {
+            fctx.registerResult(feResultType, filter, filterSubregion, cs);
+        }
+
+        // Unspecified 'in' and 'in2' inputs implicitly resolve to the previous filter's result.
+        fctx.setPreviousResult(filter, filterSubregion, cs);
+    }
+
+    // Convert to final destination colorspace
+    if (cs != SkSVGColorspace::kSRGB) {
+        filter = SkImageFilters::ColorFilter(SkColorFilters::LinearToSRGBGamma(), filter);
+    }
+
+    return filter;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp
new file mode 100644
index 00000000..61b97091
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGFilterContext.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/svg/include/SkSVGFilterContext.h"
+
+#include "include/core/SkBlendMode.h"
+#include "include/core/SkColorFilter.h"
+#include "include/core/SkColorSpace.h"
+#include "include/effects/SkColorMatrix.h"
+#include "include/effects/SkImageFilters.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+namespace {
+
+sk_sp<SkImageFilter> ConvertFilterColorspace(sk_sp<SkImageFilter>&& input,
+                                             SkSVGColorspace src,
+                                             SkSVGColorspace dst) {
+    if (src == dst) {
+        return std::move(input);
+    } else if (src == SkSVGColorspace::kSRGB && dst == SkSVGColorspace::kLinearRGB) {
+        return SkImageFilters::ColorFilter(SkColorFilters::SRGBToLinearGamma(), input);
+    } else {
+        SkASSERT(src == SkSVGColorspace::kLinearRGB && dst == SkSVGColorspace::kSRGB);
+        return SkImageFilters::ColorFilter(SkColorFilters::LinearToSRGBGamma(), input);
+    }
+}
+
+sk_sp<SkShader> paint_as_shader(const SkPaint& paint) {
+    sk_sp<SkShader> shader = paint.refShader();
+    auto color = paint.getColor4f();
+    if (shader && color.fA < 1.f) {
+        // Multiply by paint alpha
+        shader = shader->makeWithColorFilter(
+                SkColorFilters::Blend(color, /*colorSpace=*/nullptr, SkBlendMode::kDstIn));
+    } else if (!shader) {
+        shader = SkShaders::Color(color, /*colorSpace=*/nullptr);
+    }
+    if (paint.getColorFilter()) {
+        shader = shader->makeWithColorFilter(paint.refColorFilter());
+    }
+    return shader;
+}
+
+}  // namespace
+
+const SkSVGFilterContext::Result* SkSVGFilterContext::findResultById(
+        const SkSVGStringType& id) const {
+    return fResults.find(id);
+}
+
+const SkRect& SkSVGFilterContext::filterPrimitiveSubregion(const SkSVGFeInputType& input) const {
+    const Result* res = nullptr;
+    if (input.type() == SkSVGFeInputType::Type::kFilterPrimitiveReference) {
+        res = fResults.find(input.id());
+    } else if (input.type() == SkSVGFeInputType::Type::kUnspecified) {
+        res = &fPreviousResult;
+    }
+    return res ? res->fFilterSubregion : fFilterEffectsRegion;
+}
+
+void SkSVGFilterContext::registerResult(const SkSVGStringType& id,
+                                        const sk_sp<SkImageFilter>& result,
+                                        const SkRect& subregion,
+                                        SkSVGColorspace resultColorspace) {
+    SkASSERT(!id.isEmpty());
+    fResults[id] = {result, subregion, resultColorspace};
+}
+
+void SkSVGFilterContext::setPreviousResult(const sk_sp<SkImageFilter>& result,
+                                           const SkRect& subregion,
+                                           SkSVGColorspace resultColorspace) {
+    fPreviousResult = {result, subregion, resultColorspace};
+}
+
+bool SkSVGFilterContext::previousResultIsSourceGraphic() const {
+    return fPreviousResult.fImageFilter == nullptr;
+}
+
+// https://www.w3.org/TR/SVG11/filters.html#FilterPrimitiveInAttribute
+std::tuple<sk_sp<SkImageFilter>, SkSVGColorspace> SkSVGFilterContext::getInput(
+        const SkSVGRenderContext& ctx, const SkSVGFeInputType& inputType) const {
+    SkSVGColorspace inputCS = SkSVGColorspace::kSRGB;
+    sk_sp<SkImageFilter> result;
+    switch (inputType.type()) {
+        case SkSVGFeInputType::Type::kSourceAlpha: {
+            SkColorMatrix m;
+            m.setScale(0, 0, 0, 1.0f);
+            result = SkImageFilters::ColorFilter(SkColorFilters::Matrix(m), nullptr);
+            break;
+        }
+        case SkSVGFeInputType::Type::kSourceGraphic:
+            // Do nothing.
+            break;
+        case SkSVGFeInputType::Type::kFillPaint: {
+            const auto& fillPaint = ctx.fillPaint();
+            if (fillPaint.isValid()) {
+                auto dither = fillPaint->isDither() ? SkImageFilters::Dither::kYes
+                                                    : SkImageFilters::Dither::kNo;
+                result = SkImageFilters::Shader(paint_as_shader(*fillPaint), dither);
+            }
+            break;
+        }
+        case SkSVGFeInputType::Type::kStrokePaint: {
+            // The paint filter doesn't apply fill/stroke styling, but use the paint settings
+            // defined for strokes.
+            const auto& strokePaint = ctx.strokePaint();
+            if (strokePaint.isValid()) {
+                auto dither = strokePaint->isDither() ? SkImageFilters::Dither::kYes
+                                                      : SkImageFilters::Dither::kNo;
+                result = SkImageFilters::Shader(paint_as_shader(*strokePaint), dither);
+            }
+            break;
+        }
+        case SkSVGFeInputType::Type::kFilterPrimitiveReference: {
+            const Result* res = findResultById(inputType.id());
+            if (res) {
+                result = res->fImageFilter;
+                inputCS = res->fColorspace;
+            }
+            break;
+        }
+        case SkSVGFeInputType::Type::kUnspecified: {
+            result = fPreviousResult.fImageFilter;
+            inputCS = fPreviousResult.fColorspace;
+            break;
+        }
+        default:
+            SkDebugf("unhandled filter input type %d\n", (int)inputType.type());
+            break;
+    }
+
+    return {result, inputCS};
+}
+
+SkSVGColorspace SkSVGFilterContext::resolveInputColorspace(
+        const SkSVGRenderContext& ctx, const SkSVGFeInputType& inputType) const {
+    return std::get<1>(this->getInput(ctx, inputType));
+}
+
+sk_sp<SkImageFilter> SkSVGFilterContext::resolveInput(const SkSVGRenderContext& ctx,
+                                                      const SkSVGFeInputType& inputType) const {
+    return std::get<0>(this->getInput(ctx, inputType));
+}
+
+sk_sp<SkImageFilter> SkSVGFilterContext::resolveInput(const SkSVGRenderContext& ctx,
+                                                      const SkSVGFeInputType& inputType,
+                                                      SkSVGColorspace colorspace) const {
+    auto [result, inputCS] = this->getInput(ctx, inputType);
+    return ConvertFilterColorspace(std::move(result), inputCS, colorspace);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp
new file mode 100644
index 00000000..9f302a7c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGGradient.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+#include "modules/svg/include/SkSVGGradient.h"
+
+#include "include/core/SkTileMode.h"
+#include "include/private/base/SkTPin.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGStop.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+bool SkSVGGradient::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setGradientTransform(SkSVGAttributeParser::parse<SkSVGTransformType>(
+                   "gradientTransform", name, value)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", name, value)) ||
+           this->setSpreadMethod(
+                   SkSVGAttributeParser::parse<SkSVGSpreadMethod>("spreadMethod", name, value)) ||
+           this->setGradientUnits(SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>(
+                   "gradientUnits", name, value));
+}
+
+// https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementHrefAttribute
+void SkSVGGradient::collectColorStops(const SkSVGRenderContext& ctx,
+                                      StopPositionArray* pos,
+                                      StopColorArray* colors) const {
+    // Used to resolve percentage offsets.
+    const SkSVGLengthContext ltx(SkSize::Make(1, 1));
+
+    this->forEachChild<SkSVGStop>([&](const SkSVGStop* stop) {
+        colors->push_back(this->resolveStopColor(ctx, *stop));
+        pos->push_back(
+            SkTPin(ltx.resolve(stop->getOffset(), SkSVGLengthContext::LengthType::kOther),
+                   0.f, 1.f));
+    });
+
+    SkASSERT(colors->size() == pos->size());
+
+    if (pos->empty() && !fHref.iri().isEmpty()) {
+        const auto ref = ctx.findNodeById(fHref);
+        if (ref && (ref->tag() == SkSVGTag::kLinearGradient ||
+                    ref->tag() == SkSVGTag::kRadialGradient)) {
+            static_cast<const SkSVGGradient*>(ref.get())->collectColorStops(ctx, pos, colors);
+        }
+    }
+}
+
+SkColor4f SkSVGGradient::resolveStopColor(const SkSVGRenderContext& ctx,
+                                          const SkSVGStop& stop) const {
+    const auto& stopColor = stop.getStopColor();
+    const auto& stopOpacity = stop.getStopOpacity();
+    // Uninherited presentation attrs should have a concrete value at this point.
+    if (!stopColor.isValue() || !stopOpacity.isValue()) {
+        SkDebugf("unhandled: stop-color or stop-opacity has no value\n");
+        return SkColors::kBlack;
+    }
+
+    const auto color = SkColor4f::FromColor(ctx.resolveSvgColor(*stopColor));
+
+    return { color.fR, color.fG, color.fB, *stopOpacity * color.fA };
+}
+
+bool SkSVGGradient::onAsPaint(const SkSVGRenderContext& ctx, SkPaint* paint) const {
+    StopColorArray colors;
+    StopPositionArray pos;
+
+    this->collectColorStops(ctx, &pos, &colors);
+
+    // TODO:
+    //       * stop (lazy?) sorting
+    //       * href loop detection
+    //       * href attribute inheritance (not just color stops)
+    //       * objectBoundingBox units support
+
+    static_assert(static_cast<SkTileMode>(SkSVGSpreadMethod::Type::kPad) ==
+                  SkTileMode::kClamp, "SkSVGSpreadMethod::Type is out of sync");
+    static_assert(static_cast<SkTileMode>(SkSVGSpreadMethod::Type::kRepeat) ==
+                  SkTileMode::kRepeat, "SkSVGSpreadMethod::Type is out of sync");
+    static_assert(static_cast<SkTileMode>(SkSVGSpreadMethod::Type::kReflect) ==
+                  SkTileMode::kMirror, "SkSVGSpreadMethod::Type is out of sync");
+    const auto tileMode = static_cast<SkTileMode>(fSpreadMethod.type());
+
+    const auto obbt = ctx.transformForCurrentOBB(fGradientUnits);
+    const auto localMatrix = SkMatrix::Translate(obbt.offset.x, obbt.offset.y)
+                           * SkMatrix::Scale(obbt.scale.x, obbt.scale.y)
+                           * fGradientTransform;
+
+    paint->setShader(this->onMakeShader(ctx, colors.begin(), pos.begin(), colors.size(), tileMode,
+                                        localMatrix));
+    return true;
+}
+
+// https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementSpreadMethodAttribute
+template <>
+bool SkSVGAttributeParser::parse(SkSVGSpreadMethod* spread) {
+    static const struct {
+        SkSVGSpreadMethod::Type fType;
+        const char*             fName;
+    } gSpreadInfo[] = {
+        { SkSVGSpreadMethod::Type::kPad    , "pad"     },
+        { SkSVGSpreadMethod::Type::kReflect, "reflect" },
+        { SkSVGSpreadMethod::Type::kRepeat , "repeat"  },
+    };
+
+    bool parsedValue = false;
+    for (size_t i = 0; i < std::size(gSpreadInfo); ++i) {
+        if (this->parseExpectedStringToken(gSpreadInfo[i].fName)) {
+            *spread = SkSVGSpreadMethod(gSpreadInfo[i].fType);
+            parsedValue = true;
+            break;
+        }
+    }
+
+    return parsedValue && this->parseEOSToken();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp
new file mode 100644
index 00000000..083d3820
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGImage.cpp
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkImage.h"
+#include "modules/svg/include/SkSVGAttributeParser.h"
+#include "modules/svg/include/SkSVGImage.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/utils/SkOSPath.h"
+
+bool SkSVGImage::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", n, v)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", n, v)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", n, v)) ||
+           this->setPreserveAspectRatio(SkSVGAttributeParser::parse<SkSVGPreserveAspectRatio>(
+                   "preserveAspectRatio", n, v));
+}
+
+bool SkSVGImage::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    // Width or height of 0 disables rendering per spec:
+    // https://www.w3.org/TR/SVG11/struct.html#ImageElement
+    return !fHref.iri().isEmpty() && fWidth.value() > 0 && fHeight.value() > 0 &&
+           INHERITED::onPrepareToRender(ctx);
+}
+
+static sk_sp<SkImage> LoadImage(const sk_sp<skresources::ResourceProvider>& rp,
+                                const SkSVGIRI& href) {
+    // TODO: It may be better to use the SVG 'id' attribute as the asset id, to allow
+    // clients to perform asset substitution based on element id.
+    sk_sp<skresources::ImageAsset> imageAsset;
+    switch (href.type()) {
+        case SkSVGIRI::Type::kDataURI:
+            imageAsset = rp->loadImageAsset("", href.iri().c_str(), "");
+            break;
+        case SkSVGIRI::Type::kNonlocal: {
+            const auto path = SkOSPath::Dirname(href.iri().c_str());
+            const auto name = SkOSPath::Basename(href.iri().c_str());
+            imageAsset = rp->loadImageAsset(path.c_str(), name.c_str(), /* id */ name.c_str());
+            break;
+        }
+        default:
+            SkDebugf("error loading image: unhandled iri type %d\n", (int)href.type());
+            return nullptr;
+    }
+
+    return imageAsset ? imageAsset->getFrameData(0).image : nullptr;
+}
+
+SkSVGImage::ImageInfo SkSVGImage::LoadImage(const sk_sp<skresources::ResourceProvider>& rp,
+                                            const SkSVGIRI& iri,
+                                            const SkRect& viewPort,
+                                            SkSVGPreserveAspectRatio par) {
+    SkASSERT(rp);
+
+    // TODO: svg sources
+    sk_sp<SkImage> image = ::LoadImage(rp, iri);
+    if (!image) {
+        return {};
+    }
+
+    // Per spec: raster content has implicit viewbox of '0 0 width height'.
+    const SkRect viewBox = SkRect::Make(image->bounds());
+
+    // Map and place at x, y specified by viewport
+    const SkMatrix m = ComputeViewboxMatrix(viewBox, viewPort, par);
+    const SkRect dst = m.mapRect(viewBox).makeOffset(viewPort.fLeft, viewPort.fTop);
+
+    return {std::move(image), dst};
+}
+
+void SkSVGImage::onRender(const SkSVGRenderContext& ctx) const {
+    // Per spec: x, w, width, height attributes establish the new viewport.
+    const SkSVGLengthContext& lctx = ctx.lengthContext();
+    const SkRect viewPort = lctx.resolveRect(fX, fY, fWidth, fHeight);
+
+    const auto imgInfo = LoadImage(ctx.resourceProvider(), fHref, viewPort, fPreserveAspectRatio);
+    if (!imgInfo.fImage) {
+        SkDebugf("can't render image: load image failed\n");
+        return;
+    }
+
+    // TODO: image-rendering property
+    ctx.canvas()->drawImageRect(
+            imgInfo.fImage, imgInfo.fDst, SkSamplingOptions(SkFilterMode::kLinear));
+}
+
+SkPath SkSVGImage::onAsPath(const SkSVGRenderContext&) const { return {}; }
+
+SkRect SkSVGImage::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    const SkSVGLengthContext& lctx = ctx.lengthContext();
+    return lctx.resolveRect(fX, fY, fWidth, fHeight);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp
new file mode 100644
index 00000000..3166d018
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGLine.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGLine.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGLine::SkSVGLine() : INHERITED(SkSVGTag::kLine) {}
+
+bool SkSVGLine::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX1(SkSVGAttributeParser::parse<SkSVGLength>("x1", n, v)) ||
+           this->setY1(SkSVGAttributeParser::parse<SkSVGLength>("y1", n, v)) ||
+           this->setX2(SkSVGAttributeParser::parse<SkSVGLength>("x2", n, v)) ||
+           this->setY2(SkSVGAttributeParser::parse<SkSVGLength>("y2", n, v));
+}
+
+std::tuple<SkPoint, SkPoint> SkSVGLine::resolve(const SkSVGLengthContext& lctx) const {
+    return std::make_tuple(
+        SkPoint::Make(lctx.resolve(fX1, SkSVGLengthContext::LengthType::kHorizontal),
+                      lctx.resolve(fY1, SkSVGLengthContext::LengthType::kVertical)),
+        SkPoint::Make(lctx.resolve(fX2, SkSVGLengthContext::LengthType::kHorizontal),
+                      lctx.resolve(fY2, SkSVGLengthContext::LengthType::kVertical)));
+}
+
+void SkSVGLine::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                       const SkPaint& paint, SkPathFillType) const {
+    SkPoint p0, p1;
+    std::tie(p0, p1) = this->resolve(lctx);
+
+    canvas->drawLine(p0, p1, paint);
+}
+
+SkPath SkSVGLine::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPoint p0, p1;
+    std::tie(p0, p1) = this->resolve(ctx.lengthContext());
+
+    SkPath path = SkPath::Line(p0, p1);
+    this->mapToParent(&path);
+
+    return path;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp
new file mode 100644
index 00000000..f7833b1d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGLinearGradient.cpp
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorSpace.h"
+#include "include/effects/SkGradientShader.h"
+#include "modules/svg/include/SkSVGLinearGradient.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGLinearGradient::SkSVGLinearGradient() : INHERITED(SkSVGTag::kLinearGradient) {}
+
+bool SkSVGLinearGradient::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX1(SkSVGAttributeParser::parse<SkSVGLength>("x1", name, value)) ||
+           this->setY1(SkSVGAttributeParser::parse<SkSVGLength>("y1", name, value)) ||
+           this->setX2(SkSVGAttributeParser::parse<SkSVGLength>("x2", name, value)) ||
+           this->setY2(SkSVGAttributeParser::parse<SkSVGLength>("y2", name, value));
+}
+
+sk_sp<SkShader> SkSVGLinearGradient::onMakeShader(const SkSVGRenderContext& ctx,
+                                                  const SkColor4f* colors, const SkScalar* pos,
+                                                  int count, SkTileMode tm,
+                                                  const SkMatrix& localMatrix) const {
+    const SkSVGLengthContext lctx =
+            this->getGradientUnits().type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox
+                    ? SkSVGLengthContext({1, 1})
+                    : ctx.lengthContext();
+
+    const auto x1 = lctx.resolve(fX1, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto y1 = lctx.resolve(fY1, SkSVGLengthContext::LengthType::kVertical);
+    const auto x2 = lctx.resolve(fX2, SkSVGLengthContext::LengthType::kHorizontal);
+    const auto y2 = lctx.resolve(fY2, SkSVGLengthContext::LengthType::kVertical);
+
+    const SkPoint pts[2] = { {x1, y1}, {x2, y2}};
+
+    return SkGradientShader::MakeLinear(pts, colors, nullptr, pos, count, tm, 0, &localMatrix);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp
new file mode 100644
index 00000000..849ecc3f
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGMask.cpp
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGMask.h"
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkColorFilter.h"
+#include "include/effects/SkLumaColorFilter.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+bool SkSVGMask::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", n, v)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", n, v)) ||
+           this->setMaskUnits(
+                SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>("maskUnits", n, v)) ||
+           this->setMaskContentUnits(
+                SkSVGAttributeParser::parse<SkSVGObjectBoundingBoxUnits>("maskContentUnits", n, v));
+}
+
+SkRect SkSVGMask::bounds(const SkSVGRenderContext& ctx) const {
+    return ctx.resolveOBBRect(fX, fY, fWidth, fHeight, fMaskUnits);
+}
+
+void SkSVGMask::renderMask(const SkSVGRenderContext& ctx) const {
+    // https://www.w3.org/TR/SVG11/masking.html#Masking
+
+    // Propagate any inherited properties that may impact mask effect behavior (e.g.
+    // color-interpolation). We call this explicitly here because the SkSVGMask
+    // nodes do not participate in the normal onRender path, which is when property
+    // propagation currently occurs.
+    // The local context also restores the filter layer created below on scope exit.
+    SkSVGRenderContext lctx(ctx);
+    this->onPrepareToRender(&lctx);
+
+    const auto ci = *lctx.presentationContext().fInherited.fColorInterpolation;
+    auto ci_filter = (ci == SkSVGColorspace::kLinearRGB)
+            ? SkColorFilters::SRGBToLinearGamma()
+            : nullptr;
+
+    SkPaint mask_filter;
+    mask_filter.setColorFilter(
+                SkColorFilters::Compose(SkLumaColorFilter::Make(), std::move(ci_filter)));
+
+    // Mask color filter layer.
+    // Note: We could avoid this extra layer if we invert the stacking order
+    // (mask/content -> content/mask, kSrcIn -> kDstIn) and apply the filter
+    // via the top (mask) layer paint.  That requires deferring mask rendering
+    // until after node content, which introduces extra state/complexity.
+    // Something to consider if masking performance ever becomes an issue.
+    lctx.canvas()->saveLayer(nullptr, &mask_filter);
+
+    const auto obbt = ctx.transformForCurrentOBB(fMaskContentUnits);
+    lctx.canvas()->translate(obbt.offset.x, obbt.offset.y);
+    lctx.canvas()->scale(obbt.scale.x, obbt.scale.y);
+
+    for (const auto& child : fChildren) {
+        child->render(lctx);
+    }
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp
new file mode 100644
index 00000000..596b22ea
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGNode.cpp
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkMatrix.h"
+#include "include/pathops/SkPathOps.h"
+#include "include/private/base/SkTPin.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/base/SkTLazy.h"
+
+SkSVGNode::SkSVGNode(SkSVGTag t) : fTag(t) {
+    // Uninherited presentation attributes need a non-null default value.
+    fPresentationAttributes.fStopColor.set(SkSVGColor(SK_ColorBLACK));
+    fPresentationAttributes.fStopOpacity.set(SkSVGNumberType(1.0f));
+    fPresentationAttributes.fFloodColor.set(SkSVGColor(SK_ColorBLACK));
+    fPresentationAttributes.fFloodOpacity.set(SkSVGNumberType(1.0f));
+    fPresentationAttributes.fLightingColor.set(SkSVGColor(SK_ColorWHITE));
+}
+
+SkSVGNode::~SkSVGNode() { }
+
+void SkSVGNode::render(const SkSVGRenderContext& ctx) const {
+    SkSVGRenderContext localContext(ctx, this);
+
+    if (this->onPrepareToRender(&localContext)) {
+        this->onRender(localContext);
+    }
+}
+
+bool SkSVGNode::asPaint(const SkSVGRenderContext& ctx, SkPaint* paint) const {
+    SkSVGRenderContext localContext(ctx);
+
+    return this->onPrepareToRender(&localContext) && this->onAsPaint(localContext, paint);
+}
+
+SkPath SkSVGNode::asPath(const SkSVGRenderContext& ctx) const {
+    SkSVGRenderContext localContext(ctx);
+    if (!this->onPrepareToRender(&localContext)) {
+        return SkPath();
+    }
+
+    SkPath path = this->onAsPath(localContext);
+
+    if (const auto* clipPath = localContext.clipPath()) {
+        // There is a clip-path present on the current node.
+        Op(path, *clipPath, kIntersect_SkPathOp, &path);
+    }
+
+    return path;
+}
+
+SkRect SkSVGNode::objectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return this->onObjectBoundingBox(ctx);
+}
+
+bool SkSVGNode::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    ctx->applyPresentationAttributes(fPresentationAttributes,
+                                     this->hasChildren() ? 0 : SkSVGRenderContext::kLeaf);
+
+    // visibility:hidden and display:none disable rendering.
+    // TODO: if display is not a value (true when display="inherit"), we currently
+    //   ignore it. Eventually we should be able to add SkASSERT(display.isValue()).
+    const auto visibility = ctx->presentationContext().fInherited.fVisibility->type();
+    const auto display = fPresentationAttributes.fDisplay;  // display is uninherited
+    return visibility != SkSVGVisibility::Type::kHidden &&
+           (!display.isValue() || *display != SkSVGDisplay::kNone);
+}
+
+void SkSVGNode::setAttribute(SkSVGAttribute attr, const SkSVGValue& v) {
+    this->onSetAttribute(attr, v);
+}
+
+template <typename T>
+void SetInheritedByDefault(SkTLazy<T>& presentation_attribute, const T& value) {
+    if (value.type() != T::Type::kInherit) {
+        presentation_attribute.set(value);
+    } else {
+        // kInherited values are semantically equivalent to
+        // the absence of a local presentation attribute.
+        presentation_attribute.reset();
+    }
+}
+
+bool SkSVGNode::parseAndSetAttribute(const char* n, const char* v) {
+#define PARSE_AND_SET(svgName, attrName)                                                        \
+    this->set##attrName(                                                                        \
+            SkSVGAttributeParser::parseProperty<decltype(fPresentationAttributes.f##attrName)>( \
+                    svgName, n, v))
+
+    return PARSE_AND_SET(   "clip-path"                  , ClipPath)
+           || PARSE_AND_SET("clip-rule"                  , ClipRule)
+           || PARSE_AND_SET("color"                      , Color)
+           || PARSE_AND_SET("color-interpolation"        , ColorInterpolation)
+           || PARSE_AND_SET("color-interpolation-filters", ColorInterpolationFilters)
+           || PARSE_AND_SET("display"                    , Display)
+           || PARSE_AND_SET("fill"                       , Fill)
+           || PARSE_AND_SET("fill-opacity"               , FillOpacity)
+           || PARSE_AND_SET("fill-rule"                  , FillRule)
+           || PARSE_AND_SET("filter"                     , Filter)
+           || PARSE_AND_SET("flood-color"                , FloodColor)
+           || PARSE_AND_SET("flood-opacity"              , FloodOpacity)
+           || PARSE_AND_SET("font-family"                , FontFamily)
+           || PARSE_AND_SET("font-size"                  , FontSize)
+           || PARSE_AND_SET("font-style"                 , FontStyle)
+           || PARSE_AND_SET("font-weight"                , FontWeight)
+           || PARSE_AND_SET("lighting-color"             , LightingColor)
+           || PARSE_AND_SET("mask"                       , Mask)
+           || PARSE_AND_SET("opacity"                    , Opacity)
+           || PARSE_AND_SET("stop-color"                 , StopColor)
+           || PARSE_AND_SET("stop-opacity"               , StopOpacity)
+           || PARSE_AND_SET("stroke"                     , Stroke)
+           || PARSE_AND_SET("stroke-dasharray"           , StrokeDashArray)
+           || PARSE_AND_SET("stroke-dashoffset"          , StrokeDashOffset)
+           || PARSE_AND_SET("stroke-linecap"             , StrokeLineCap)
+           || PARSE_AND_SET("stroke-linejoin"            , StrokeLineJoin)
+           || PARSE_AND_SET("stroke-miterlimit"          , StrokeMiterLimit)
+           || PARSE_AND_SET("stroke-opacity"             , StrokeOpacity)
+           || PARSE_AND_SET("stroke-width"               , StrokeWidth)
+           || PARSE_AND_SET("text-anchor"                , TextAnchor)
+           || PARSE_AND_SET("visibility"                 , Visibility);
+
+#undef PARSE_AND_SET
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#PreserveAspectRatioAttribute
+SkMatrix SkSVGNode::ComputeViewboxMatrix(const SkRect& viewBox,
+                                         const SkRect& viewPort,
+                                         SkSVGPreserveAspectRatio par) {
+    if (viewBox.isEmpty() || viewPort.isEmpty()) {
+        return SkMatrix::Scale(0, 0);
+    }
+
+    auto compute_scale = [&]() -> SkV2 {
+        const auto sx = viewPort.width()  / viewBox.width(),
+                   sy = viewPort.height() / viewBox.height();
+
+        if (par.fAlign == SkSVGPreserveAspectRatio::kNone) {
+            // none -> anisotropic scaling, regardless of fScale
+            return {sx, sy};
+        }
+
+        // isotropic scaling
+        const auto s = par.fScale == SkSVGPreserveAspectRatio::kMeet
+                            ? std::min(sx, sy)
+                            : std::max(sx, sy);
+        return {s, s};
+    };
+
+    auto compute_trans = [&](const SkV2& scale) -> SkV2 {
+        static constexpr float gAlignCoeffs[] = {
+                0.0f, // Min
+                0.5f, // Mid
+                1.0f  // Max
+        };
+
+        const size_t x_coeff = par.fAlign >> 0 & 0x03,
+                     y_coeff = par.fAlign >> 2 & 0x03;
+
+        SkASSERT(x_coeff < std::size(gAlignCoeffs) &&
+                 y_coeff < std::size(gAlignCoeffs));
+
+        const auto tx = -viewBox.x() * scale.x,
+                   ty = -viewBox.y() * scale.y,
+                   dx = viewPort.width()  - viewBox.width() * scale.x,
+                   dy = viewPort.height() - viewBox.height() * scale.y;
+
+        return {
+            tx + dx * gAlignCoeffs[x_coeff],
+            ty + dy * gAlignCoeffs[y_coeff]
+        };
+    };
+
+    const auto s = compute_scale(),
+               t = compute_trans(s);
+
+    return SkMatrix::Translate(t.x, t.y) *
+           SkMatrix::Scale(s.x, s.y);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp
new file mode 100644
index 00000000..69ad97d3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2022 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/codec/SkCodec.h"
+#include "include/codec/SkJpegDecoder.h"
+#include "include/codec/SkPngDecoder.h"
+#include "include/core/SkColor.h"
+#include "include/core/SkOpenTypeSVGDecoder.h"
+#include "include/core/SkSpan.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkTypes.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/svg/include/SkSVGDOM.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGOpenTypeSVGDecoder.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGSVG.h"
+#include "modules/svg/include/SkSVGUse.h"
+#include "src/base/SkBase64.h"
+#include "src/core/SkEnumerate.h"
+
+#include <memory>
+
+using namespace skia_private;
+
+namespace {
+class DataResourceProvider final : public skresources::ResourceProvider {
+public:
+    static sk_sp<skresources::ResourceProvider> Make() {
+        return sk_sp<skresources::ResourceProvider>(new DataResourceProvider());
+    }
+
+    sk_sp<skresources::ImageAsset> loadImageAsset(const char rpath[],
+                                                  const char rname[],
+                                                  const char rid[]) const override {
+        if (auto data = decode_datauri("data:image/", rname)) {
+            std::unique_ptr<SkCodec> codec = nullptr;
+            if (SkPngDecoder::IsPng(data->bytes(), data->size())) {
+                codec = SkPngDecoder::Decode(data, nullptr);
+            } else if (SkJpegDecoder::IsJpeg(data->bytes(), data->size())) {
+                codec = SkJpegDecoder::Decode(data, nullptr);
+            } else {
+                // The spec says only JPEG or PNG should be used to encode the embedded data.
+                // https://learn.microsoft.com/en-us/typography/opentype/spec/svg#svg-capability-requirements-and-restrictions
+                SkDEBUGFAIL("Unsupported codec");
+                return nullptr;
+            }
+            if (!codec) {
+                return nullptr;
+            }
+            return skresources::MultiFrameImageAsset::Make(std::move(codec));
+        }
+        return nullptr;
+    }
+
+private:
+    DataResourceProvider() = default;
+
+    static sk_sp<SkData> decode_datauri(const char prefix[], const char uri[]) {
+        // We only handle B64 encoded image dataURIs: data:image/<type>;base64,<data>
+        // (https://en.wikipedia.org/wiki/Data_URI_scheme)
+        static constexpr char kDataURIEncodingStr[] = ";base64,";
+
+        const size_t prefixLen = strlen(prefix);
+        if (strncmp(uri, prefix, prefixLen) != 0) {
+            return nullptr;
+        }
+
+        const char* encoding = strstr(uri + prefixLen, kDataURIEncodingStr);
+        if (!encoding) {
+            return nullptr;
+        }
+
+        const char* b64Data = encoding + std::size(kDataURIEncodingStr) - 1;
+        size_t b64DataLen = strlen(b64Data);
+        size_t dataLen;
+        if (SkBase64::Decode(b64Data, b64DataLen, nullptr, &dataLen) != SkBase64::kNoError) {
+            return nullptr;
+        }
+
+        sk_sp<SkData> data = SkData::MakeUninitialized(dataLen);
+        void* rawData = data->writable_data();
+        if (SkBase64::Decode(b64Data, b64DataLen, rawData, &dataLen) != SkBase64::kNoError) {
+            return nullptr;
+        }
+
+        return data;
+    }
+
+    using INHERITED = ResourceProvider;
+};
+}  // namespace
+
+SkSVGOpenTypeSVGDecoder::SkSVGOpenTypeSVGDecoder(sk_sp<SkSVGDOM> skSvg, size_t approximateSize)
+    : fSkSvg(std::move(skSvg))
+    , fApproximateSize(approximateSize)
+{}
+
+SkSVGOpenTypeSVGDecoder::~SkSVGOpenTypeSVGDecoder() = default;
+
+std::unique_ptr<SkOpenTypeSVGDecoder> SkSVGOpenTypeSVGDecoder::Make(const uint8_t* svg,
+                                                                    size_t svgLength) {
+    std::unique_ptr<SkStreamAsset> stream = SkMemoryStream::MakeDirect(svg, svgLength);
+    if (!stream) {
+        return nullptr;
+    }
+    SkSVGDOM::Builder builder;
+    builder.setResourceProvider(DataResourceProvider::Make());
+    // We shouldn't need to set this builder's font manager or shaping utils because hopefully
+    // the SVG we are decoding doesn't itself have <text> tags.
+    sk_sp<SkSVGDOM> skSvg = builder.make(*stream);
+    if (!skSvg) {
+        return nullptr;
+    }
+    return std::unique_ptr<SkOpenTypeSVGDecoder>(
+        new SkSVGOpenTypeSVGDecoder(std::move(skSvg), svgLength));
+}
+
+size_t SkSVGOpenTypeSVGDecoder::approximateSize() {
+    // TODO
+    return fApproximateSize;
+}
+
+bool SkSVGOpenTypeSVGDecoder::render(SkCanvas& canvas, int upem, SkGlyphID glyphId,
+                                     SkColor foregroundColor, SkSpan<SkColor> palette) {
+    SkSize emSize = SkSize::Make(SkScalar(upem), SkScalar(upem));
+    fSkSvg->setContainerSize(emSize);
+
+    SkSVGPresentationContext pctx;
+    pctx.fInherited.fColor.set(foregroundColor);
+
+    THashMap<SkString, SkSVGColorType> namedColors;
+    if (!palette.empty()) {
+        for (auto&& [i, color] : SkMakeEnumerate(palette)) {
+            constexpr const size_t colorStringLen = sizeof("color") - 1;
+            char colorIdString[colorStringLen + kSkStrAppendU32_MaxSize + 1] = "color";
+            *SkStrAppendU32(colorIdString + colorStringLen, i) = 0;
+
+            namedColors.set(SkString(colorIdString), color);
+        }
+        pctx.fNamedColors = &namedColors;
+    }
+
+    constexpr const size_t glyphStringLen = sizeof("glyph") - 1;
+    char glyphIdString[glyphStringLen + kSkStrAppendU32_MaxSize + 1] = "glyph";
+    *SkStrAppendU32(glyphIdString + glyphStringLen, glyphId) = 0;
+
+    fSkSvg->renderNode(&canvas, pctx, glyphIdString);
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp
new file mode 100644
index 00000000..a250ceaf
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGPath.cpp
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkPaint.h"
+#include "include/utils/SkParsePath.h"
+#include "modules/svg/include/SkSVGPath.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGPath::SkSVGPath() : INHERITED(SkSVGTag::kPath) { }
+
+bool SkSVGPath::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setPath(SkSVGAttributeParser::parse<SkPath>("d", n, v));
+}
+
+template <>
+bool SkSVGAttributeParser::parse<SkPath>(SkPath* path) {
+    return SkParsePath::FromSVGString(fCurPos, path);
+}
+
+void SkSVGPath::onDraw(SkCanvas* canvas, const SkSVGLengthContext&, const SkPaint& paint,
+                       SkPathFillType fillType) const {
+    // the passed fillType follows inheritance rules and needs to be applied at draw time.
+    SkPath path = fPath;  // Note: point and verb data are CoW
+    path.setFillType(fillType);
+    canvas->drawPath(path, paint);
+}
+
+SkPath SkSVGPath::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = fPath;
+    // clip-rule can be inherited and needs to be applied at clip time.
+    path.setFillType(ctx.presentationContext().fInherited.fClipRule->asFillType());
+    this->mapToParent(&path);
+    return path;
+}
+
+SkRect SkSVGPath::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return fPath.computeTightBounds();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp
new file mode 100644
index 00000000..d2fc2685
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGPattern.cpp
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGPattern.h"
+
+#include "include/core/SkPicture.h"
+#include "include/core/SkPictureRecorder.h"
+#include "include/core/SkShader.h"
+#include "include/core/SkTileMode.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGPattern::SkSVGPattern() : INHERITED(SkSVGTag::kPattern) {}
+
+bool SkSVGPattern::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", name, value)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", name, value)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", name, value)) ||
+           this->setPatternTransform(SkSVGAttributeParser::parse<SkSVGTransformType>(
+                   "patternTransform", name, value)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", name, value));
+}
+
+const SkSVGPattern* SkSVGPattern::hrefTarget(const SkSVGRenderContext& ctx) const {
+    if (fHref.iri().isEmpty()) {
+        return nullptr;
+    }
+
+    const auto href = ctx.findNodeById(fHref);
+    if (!href || href->tag() != SkSVGTag::kPattern) {
+        return nullptr;
+    }
+
+    return static_cast<const SkSVGPattern*>(href.get());
+}
+
+template <typename T>
+int inherit_if_needed(const SkTLazy<T>& src, SkTLazy<T>& dst) {
+    if (!dst.isValid()) {
+        dst = src;
+        return 1;
+    }
+
+    return 0;
+}
+
+/* https://www.w3.org/TR/SVG11/pservers.html#PatternElementHrefAttribute
+ *
+ * Any attributes which are defined on the referenced element which are not defined on this element
+ * are inherited by this element. If this element has no children, and the referenced element does
+ * (possibly due to its own xlink:href attribute), then this element inherits the children from
+ * the referenced element. Inheritance can be indirect to an arbitrary level; thus, if the
+ * referenced element inherits attributes or children due to its own xlink:href attribute, then
+ * the current element can inherit those attributes or children.
+ */
+const SkSVGPattern* SkSVGPattern::resolveHref(const SkSVGRenderContext& ctx,
+                                              PatternAttributes* attrs) const {
+    const SkSVGPattern *currentNode = this,
+                       *contentNode = this;
+    do {
+        // Bitwise OR to avoid short-circuiting.
+        const bool didInherit =
+            inherit_if_needed(currentNode->fX               , attrs->fX)      |
+            inherit_if_needed(currentNode->fY               , attrs->fY)      |
+            inherit_if_needed(currentNode->fWidth           , attrs->fWidth)  |
+            inherit_if_needed(currentNode->fHeight          , attrs->fHeight) |
+            inherit_if_needed(currentNode->fPatternTransform, attrs->fPatternTransform);
+
+        if (!contentNode->hasChildren()) {
+            contentNode = currentNode;
+        }
+
+        if (contentNode->hasChildren() && !didInherit) {
+            // All attributes have been resolved, and a valid content node has been found.
+            // We can terminate the href chain early.
+            break;
+        }
+
+        // TODO: reference loop mitigation.
+        currentNode = currentNode->hrefTarget(ctx);
+    } while (currentNode);
+
+    return contentNode;
+}
+
+bool SkSVGPattern::onAsPaint(const SkSVGRenderContext& ctx, SkPaint* paint) const {
+    PatternAttributes attrs;
+    const auto* contentNode = this->resolveHref(ctx, &attrs);
+
+    const auto tile = ctx.lengthContext().resolveRect(
+            attrs.fX.isValid()      ? *attrs.fX      : SkSVGLength(0),
+            attrs.fY.isValid()      ? *attrs.fY      : SkSVGLength(0),
+            attrs.fWidth.isValid()  ? *attrs.fWidth  : SkSVGLength(0),
+            attrs.fHeight.isValid() ? *attrs.fHeight : SkSVGLength(0));
+
+    if (tile.isEmpty()) {
+        return false;
+    }
+
+    const SkMatrix* patternTransform = attrs.fPatternTransform.isValid()
+            ? attrs.fPatternTransform.get()
+            : nullptr;
+
+    SkPictureRecorder recorder;
+    SkSVGRenderContext recordingContext(ctx, recorder.beginRecording(tile));
+
+    // Cannot call into INHERITED:: because SkSVGHiddenContainer skips rendering.
+    contentNode->SkSVGContainer::onRender(recordingContext);
+
+    paint->setShader(recorder.finishRecordingAsPicture()->makeShader(
+                                                 SkTileMode::kRepeat,
+                                                 SkTileMode::kRepeat,
+                                                 SkFilterMode::kLinear,
+                                                 patternTransform,
+                                                 &tile));
+    return true;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp
new file mode 100644
index 00000000..0d63339a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGPoly.cpp
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGPoly.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "src/base/SkTLazy.h"
+
+SkSVGPoly::SkSVGPoly(SkSVGTag t) : INHERITED(t) {}
+
+bool SkSVGPoly::parseAndSetAttribute(const char* n, const char* v) {
+    if (INHERITED::parseAndSetAttribute(n, v)) {
+        return true;
+    }
+
+    if (this->setPoints(SkSVGAttributeParser::parse<SkSVGPointsType>("points", n, v))) {
+        // TODO: we can likely just keep the points array and create the SkPath when needed.
+        fPath = SkPath::Polygon(
+                fPoints.data(), fPoints.size(),
+                this->tag() == SkSVGTag::kPolygon);  // only polygons are auto-closed
+    }
+
+    // No other attributes on this node
+    return false;
+}
+
+void SkSVGPoly::onDraw(SkCanvas* canvas, const SkSVGLengthContext&, const SkPaint& paint,
+                       SkPathFillType fillType) const {
+    // the passed fillType follows inheritance rules and needs to be applied at draw time.
+    fPath.setFillType(fillType);
+    canvas->drawPath(fPath, paint);
+}
+
+SkPath SkSVGPoly::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = fPath;
+
+    // clip-rule can be inherited and needs to be applied at clip time.
+    path.setFillType(ctx.presentationContext().fInherited.fClipRule->asFillType());
+
+    this->mapToParent(&path);
+    return path;
+}
+
+SkRect SkSVGPoly::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return fPath.getBounds();
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp
new file mode 100644
index 00000000..9a341176
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRadialGradient.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkColorSpace.h"
+#include "include/effects/SkGradientShader.h"
+#include "modules/svg/include/SkSVGRadialGradient.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGRadialGradient::SkSVGRadialGradient() : INHERITED(SkSVGTag::kRadialGradient) {}
+
+bool SkSVGRadialGradient::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setCx(SkSVGAttributeParser::parse<SkSVGLength>("cx", name, value)) ||
+           this->setCy(SkSVGAttributeParser::parse<SkSVGLength>("cy", name, value)) ||
+           this->setR(SkSVGAttributeParser::parse<SkSVGLength>("r", name, value)) ||
+           this->setFx(SkSVGAttributeParser::parse<SkSVGLength>("fx", name, value)) ||
+           this->setFy(SkSVGAttributeParser::parse<SkSVGLength>("fy", name, value));
+}
+
+sk_sp<SkShader> SkSVGRadialGradient::onMakeShader(const SkSVGRenderContext& ctx,
+                                                  const SkColor4f* colors, const SkScalar* pos,
+                                                  int count, SkTileMode tm,
+                                                  const SkMatrix& m) const {
+    const SkSVGLengthContext lctx =
+            this->getGradientUnits().type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox
+                    ? SkSVGLengthContext({1, 1})
+                    : ctx.lengthContext();
+
+    const auto      r = lctx.resolve(fR , SkSVGLengthContext::LengthType::kOther);
+    const auto center = SkPoint::Make(
+            lctx.resolve(fCx, SkSVGLengthContext::LengthType::kHorizontal),
+            lctx.resolve(fCy, SkSVGLengthContext::LengthType::kVertical));
+    const auto  focal = SkPoint::Make(
+        fFx.isValid() ? lctx.resolve(*fFx, SkSVGLengthContext::LengthType::kHorizontal)
+                      : center.x(),
+        fFy.isValid() ? lctx.resolve(*fFy, SkSVGLengthContext::LengthType::kVertical)
+                      : center.y());
+
+    if (r == 0) {
+        const auto last_color = count > 0 ? colors[count - 1] : SkColors::kBlack;
+        return SkShaders::Color(last_color, nullptr);
+    }
+
+    return center == focal
+        ? SkGradientShader::MakeRadial(center, r, colors, nullptr, pos, count, tm, 0, &m)
+        : SkGradientShader::MakeTwoPointConical(focal, 0, center, r, colors, nullptr, pos,
+                                                count, tm, 0, &m);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp
new file mode 100644
index 00000000..46f3d9c3
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRect.cpp
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <tuple>
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkRRect.h"
+#include "include/core/SkRect.h"
+#include "modules/svg/include/SkSVGRect.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/src/SkSVGRectPriv.h"
+
+std::tuple<float, float> ResolveOptionalRadii(const SkTLazy<SkSVGLength>& opt_rx,
+                                              const SkTLazy<SkSVGLength>& opt_ry,
+                                              const SkSVGLengthContext& lctx) {
+    // https://www.w3.org/TR/SVG2/shapes.html#RectElement
+    //
+    // The used values for rx and ry are determined from the computed values by following these
+    // steps in order:
+    //
+    // 1. If both rx and ry have a computed value of auto (since auto is the initial value for both
+    //    properties, this will also occur if neither are specified by the author or if all
+    //    author-supplied values are invalid), then the used value of both rx and ry is 0.
+    //    (This will result in square corners.)
+    // 2. Otherwise, convert specified values to absolute values as follows:
+    //     1. If rx is set to a length value or a percentage, but ry is auto, calculate an absolute
+    //        length equivalent for rx, resolving percentages against the used width of the
+    //        rectangle; the absolute value for ry is the same.
+    //     2. If ry is set to a length value or a percentage, but rx is auto, calculate the absolute
+    //        length equivalent for ry, resolving percentages against the used height of the
+    //        rectangle; the absolute value for rx is the same.
+    //     3. If both rx and ry were set to lengths or percentages, absolute values are generated
+    //        individually, resolving rx percentages against the used width, and resolving ry
+    //        percentages against the used height.
+    const float rx = opt_rx.isValid()
+        ? lctx.resolve(*opt_rx, SkSVGLengthContext::LengthType::kHorizontal)
+        : 0;
+    const float ry = opt_ry.isValid()
+        ? lctx.resolve(*opt_ry, SkSVGLengthContext::LengthType::kVertical)
+        : 0;
+
+    return std::make_tuple(opt_rx.isValid() ? rx : ry,
+                           opt_ry.isValid() ? ry : rx);
+}
+
+SkSVGRect::SkSVGRect() : INHERITED(SkSVGTag::kRect) {}
+
+bool SkSVGRect::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setWidth(SkSVGAttributeParser::parse<SkSVGLength>("width", n, v)) ||
+           this->setHeight(SkSVGAttributeParser::parse<SkSVGLength>("height", n, v)) ||
+           this->setRx(SkSVGAttributeParser::parse<SkSVGLength>("rx", n, v)) ||
+           this->setRy(SkSVGAttributeParser::parse<SkSVGLength>("ry", n, v));
+}
+
+SkRRect SkSVGRect::resolve(const SkSVGLengthContext& lctx) const {
+    const auto rect = lctx.resolveRect(fX, fY, fWidth, fHeight);
+    const auto [ rx, ry ] = ResolveOptionalRadii(fRx, fRy, lctx);
+
+    // https://www.w3.org/TR/SVG2/shapes.html#RectElement
+    // ...
+    // 3. Finally, apply clamping to generate the used values:
+    //     1. If the absolute rx (after the above steps) is greater than half of the used width,
+    //        then the used value of rx is half of the used width.
+    //     2. If the absolute ry (after the above steps) is greater than half of the used height,
+    //        then the used value of ry is half of the used height.
+    //     3. Otherwise, the used values of rx and ry are the absolute values computed previously.
+
+    return SkRRect::MakeRectXY(rect,
+                               std::min(rx, rect.width() / 2),
+                               std::min(ry, rect.height() / 2));
+}
+
+void SkSVGRect::onDraw(SkCanvas* canvas, const SkSVGLengthContext& lctx,
+                       const SkPaint& paint, SkPathFillType) const {
+    canvas->drawRRect(this->resolve(lctx), paint);
+}
+
+SkPath SkSVGRect::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPath path = SkPath::RRect(this->resolve(ctx.lengthContext()));
+
+    this->mapToParent(&path);
+
+    return path;
+}
+
+SkRect SkSVGRect::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    return ctx.lengthContext().resolveRect(fX, fY, fWidth, fHeight);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h b/Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h
new file mode 100644
index 00000000..93263117
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRectPriv.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2024 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGRectPriv_DEFINED
+#define SkSVGRectPriv_DEFINED
+
+#include <tuple>
+
+#include "src/base/SkTLazy.h"
+
+class SkSVGLength;
+class SkSVGLengthContext;
+
+std::tuple<float, float> ResolveOptionalRadii(const SkTLazy<SkSVGLength>& rx,
+                                              const SkTLazy<SkSVGLength>& ry,
+                                              const SkSVGLengthContext&);
+
+#endif // SkSVGRectPriv_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp
new file mode 100644
index 00000000..be6d89c5
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGRenderContext.cpp
@@ -0,0 +1,519 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGRenderContext.h"
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkImageFilter.h"
+#include "include/core/SkPath.h"
+#include "include/core/SkPathEffect.h"
+#include "include/effects/SkDashPathEffect.h"
+#include "include/private/base/SkTo.h"
+#include "modules/svg/include/SkSVGAttribute.h"
+#include "modules/svg/include/SkSVGClipPath.h"
+#include "modules/svg/include/SkSVGFilter.h"
+#include "modules/svg/include/SkSVGMask.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "modules/svg/include/SkSVGTypes.h"
+
+using namespace skia_private;
+
+namespace {
+
+SkScalar length_size_for_type(const SkSize& viewport, SkSVGLengthContext::LengthType t) {
+    switch (t) {
+    case SkSVGLengthContext::LengthType::kHorizontal:
+        return viewport.width();
+    case SkSVGLengthContext::LengthType::kVertical:
+        return viewport.height();
+    case SkSVGLengthContext::LengthType::kOther: {
+        // https://www.w3.org/TR/SVG11/coords.html#Units_viewport_percentage
+        constexpr SkScalar rsqrt2 = 1.0f / SK_ScalarSqrt2;
+        const SkScalar w = viewport.width(), h = viewport.height();
+        return rsqrt2 * SkScalarSqrt(w * w + h * h);
+    }
+    }
+
+    SkASSERT(false);  // Not reached.
+    return 0;
+}
+
+// Multipliers for DPI-relative units.
+constexpr SkScalar kINMultiplier = 1.00f;
+constexpr SkScalar kPTMultiplier = kINMultiplier / 72.272f;
+constexpr SkScalar kPCMultiplier = kPTMultiplier * 12;
+constexpr SkScalar kMMMultiplier = kINMultiplier / 25.4f;
+constexpr SkScalar kCMMultiplier = kMMMultiplier * 10;
+
+}  // namespace
+
+SkScalar SkSVGLengthContext::resolve(const SkSVGLength& l, LengthType t) const {
+    switch (l.unit()) {
+    case SkSVGLength::Unit::kNumber:
+        // Fall through.
+    case SkSVGLength::Unit::kPX:
+        return l.value();
+    case SkSVGLength::Unit::kPercentage:
+        return l.value() * length_size_for_type(fViewport, t) / 100;
+    case SkSVGLength::Unit::kCM:
+        return l.value() * fDPI * kCMMultiplier;
+    case SkSVGLength::Unit::kMM:
+        return l.value() * fDPI * kMMMultiplier;
+    case SkSVGLength::Unit::kIN:
+        return l.value() * fDPI * kINMultiplier;
+    case SkSVGLength::Unit::kPT:
+        return l.value() * fDPI * kPTMultiplier;
+    case SkSVGLength::Unit::kPC:
+        return l.value() * fDPI * kPCMultiplier;
+    default:
+        SkDebugf("unsupported unit type: <%d>\n", (int)l.unit());
+        return 0;
+    }
+}
+
+SkRect SkSVGLengthContext::resolveRect(const SkSVGLength& x, const SkSVGLength& y,
+                                       const SkSVGLength& w, const SkSVGLength& h) const {
+    return SkRect::MakeXYWH(
+        this->resolve(x, SkSVGLengthContext::LengthType::kHorizontal),
+        this->resolve(y, SkSVGLengthContext::LengthType::kVertical),
+        this->resolve(w, SkSVGLengthContext::LengthType::kHorizontal),
+        this->resolve(h, SkSVGLengthContext::LengthType::kVertical));
+}
+
+namespace {
+
+SkPaint::Cap toSkCap(const SkSVGLineCap& cap) {
+    switch (cap) {
+    case SkSVGLineCap::kButt:
+        return SkPaint::kButt_Cap;
+    case SkSVGLineCap::kRound:
+        return SkPaint::kRound_Cap;
+    case SkSVGLineCap::kSquare:
+        return SkPaint::kSquare_Cap;
+    }
+    SkUNREACHABLE;
+}
+
+SkPaint::Join toSkJoin(const SkSVGLineJoin& join) {
+    switch (join.type()) {
+    case SkSVGLineJoin::Type::kMiter:
+        return SkPaint::kMiter_Join;
+    case SkSVGLineJoin::Type::kRound:
+        return SkPaint::kRound_Join;
+    case SkSVGLineJoin::Type::kBevel:
+        return SkPaint::kBevel_Join;
+    default:
+        SkASSERT(false);
+        return SkPaint::kMiter_Join;
+    }
+}
+
+static sk_sp<SkPathEffect> dash_effect(const SkSVGPresentationAttributes& props,
+                                       const SkSVGLengthContext& lctx) {
+    if (props.fStrokeDashArray->type() != SkSVGDashArray::Type::kDashArray) {
+        return nullptr;
+    }
+
+    const auto& da = *props.fStrokeDashArray;
+    const auto count = da.dashArray().size();
+    STArray<128, SkScalar, true> intervals(count);
+    for (const auto& dash : da.dashArray()) {
+        intervals.push_back(lctx.resolve(dash, SkSVGLengthContext::LengthType::kOther));
+    }
+
+    if (count & 1) {
+        // If an odd number of values is provided, then the list of values
+        // is repeated to yield an even number of values.
+        intervals.push_back_n(count);
+        memcpy(intervals.begin() + count, intervals.begin(), count * sizeof(SkScalar));
+    }
+
+    SkASSERT((intervals.size() & 1) == 0);
+
+    const auto phase = lctx.resolve(*props.fStrokeDashOffset,
+                                    SkSVGLengthContext::LengthType::kOther);
+
+    return SkDashPathEffect::Make(intervals.begin(), intervals.size(), phase);
+}
+
+}  // namespace
+
+SkSVGPresentationContext::SkSVGPresentationContext()
+    : fInherited(SkSVGPresentationAttributes::MakeInitial())
+{}
+
+SkSVGRenderContext::SkSVGRenderContext(SkCanvas* canvas,
+                                       const sk_sp<SkFontMgr>& fmgr,
+                                       const sk_sp<skresources::ResourceProvider>& rp,
+                                       const SkSVGIDMapper& mapper,
+                                       const SkSVGLengthContext& lctx,
+                                       const SkSVGPresentationContext& pctx,
+                                       const OBBScope& obbs,
+                                       const sk_sp<SkShapers::Factory>& fact)
+        : fFontMgr(fmgr)
+        , fTextShapingFactory(fact)
+        , fResourceProvider(rp)
+        , fIDMapper(mapper)
+        , fLengthContext(lctx)
+        , fPresentationContext(pctx)
+        , fCanvas(canvas)
+        , fCanvasSaveCount(canvas->getSaveCount())
+        , fOBBScope(obbs) {}
+
+SkSVGRenderContext::SkSVGRenderContext(const SkSVGRenderContext& other)
+        : SkSVGRenderContext(other.fCanvas,
+                             other.fFontMgr,
+                             other.fResourceProvider,
+                             other.fIDMapper,
+                             *other.fLengthContext,
+                             *other.fPresentationContext,
+                             other.fOBBScope,
+                             other.fTextShapingFactory) {}
+
+SkSVGRenderContext::SkSVGRenderContext(const SkSVGRenderContext& other, SkCanvas* canvas)
+        : SkSVGRenderContext(canvas,
+                             other.fFontMgr,
+                             other.fResourceProvider,
+                             other.fIDMapper,
+                             *other.fLengthContext,
+                             *other.fPresentationContext,
+                             other.fOBBScope,
+                             other.fTextShapingFactory) {}
+
+SkSVGRenderContext::SkSVGRenderContext(const SkSVGRenderContext& other, const SkSVGNode* node)
+        : SkSVGRenderContext(other.fCanvas,
+                             other.fFontMgr,
+                             other.fResourceProvider,
+                             other.fIDMapper,
+                             *other.fLengthContext,
+                             *other.fPresentationContext,
+                             OBBScope{node, this},
+                             other.fTextShapingFactory) {}
+
+SkSVGRenderContext::~SkSVGRenderContext() {
+    fCanvas->restoreToCount(fCanvasSaveCount);
+}
+
+SkSVGRenderContext::BorrowedNode SkSVGRenderContext::findNodeById(const SkSVGIRI& iri) const {
+    if (iri.type() != SkSVGIRI::Type::kLocal) {
+        SkDebugf("non-local iri references not currently supported");
+        return BorrowedNode(nullptr);
+    }
+    return BorrowedNode(fIDMapper.find(iri.iri()));
+}
+
+void SkSVGRenderContext::applyPresentationAttributes(const SkSVGPresentationAttributes& attrs,
+                                                     uint32_t flags) {
+
+#define ApplyLazyInheritedAttribute(ATTR)                                               \
+    do {                                                                                \
+        /* All attributes should be defined on the inherited context. */                \
+        SkASSERT(fPresentationContext->fInherited.f ## ATTR.isValue());                 \
+        const auto& attr = attrs.f ## ATTR;                                             \
+        if (attr.isValue() && *attr != *fPresentationContext->fInherited.f ## ATTR) {   \
+            /* Update the local attribute value */                                      \
+            fPresentationContext.writable()->fInherited.f ## ATTR.set(*attr);           \
+        }                                                                               \
+    } while (false)
+
+    ApplyLazyInheritedAttribute(Fill);
+    ApplyLazyInheritedAttribute(FillOpacity);
+    ApplyLazyInheritedAttribute(FillRule);
+    ApplyLazyInheritedAttribute(FontFamily);
+    ApplyLazyInheritedAttribute(FontSize);
+    ApplyLazyInheritedAttribute(FontStyle);
+    ApplyLazyInheritedAttribute(FontWeight);
+    ApplyLazyInheritedAttribute(ClipRule);
+    ApplyLazyInheritedAttribute(Stroke);
+    ApplyLazyInheritedAttribute(StrokeDashOffset);
+    ApplyLazyInheritedAttribute(StrokeDashArray);
+    ApplyLazyInheritedAttribute(StrokeLineCap);
+    ApplyLazyInheritedAttribute(StrokeLineJoin);
+    ApplyLazyInheritedAttribute(StrokeMiterLimit);
+    ApplyLazyInheritedAttribute(StrokeOpacity);
+    ApplyLazyInheritedAttribute(StrokeWidth);
+    ApplyLazyInheritedAttribute(TextAnchor);
+    ApplyLazyInheritedAttribute(Visibility);
+    ApplyLazyInheritedAttribute(Color);
+    ApplyLazyInheritedAttribute(ColorInterpolation);
+    ApplyLazyInheritedAttribute(ColorInterpolationFilters);
+
+#undef ApplyLazyInheritedAttribute
+
+    // Uninherited attributes.  Only apply to the current context.
+
+    const bool hasFilter = attrs.fFilter.isValue();
+    if (attrs.fOpacity.isValue()) {
+        this->applyOpacity(*attrs.fOpacity, flags, hasFilter);
+    }
+
+    if (attrs.fClipPath.isValue()) {
+        this->applyClip(*attrs.fClipPath);
+    }
+
+    if (attrs.fMask.isValue()) {
+        this->applyMask(*attrs.fMask);
+    }
+
+    // TODO: when both a filter and opacity are present, we can apply both with a single layer
+    if (hasFilter) {
+        this->applyFilter(*attrs.fFilter);
+    }
+
+    // Remaining uninherited presentation attributes are accessed as SkSVGNode fields, not via
+    // the render context.
+    // TODO: resolve these in a pre-render styling pass and assert here that they are values.
+    // - stop-color
+    // - stop-opacity
+    // - flood-color
+    // - flood-opacity
+    // - lighting-color
+}
+
+void SkSVGRenderContext::applyOpacity(SkScalar opacity, uint32_t flags, bool hasFilter) {
+    if (opacity >= 1) {
+        return;
+    }
+
+    const auto& props = fPresentationContext->fInherited;
+    const bool hasFill   = props.fFill  ->type() != SkSVGPaint::Type::kNone,
+               hasStroke = props.fStroke->type() != SkSVGPaint::Type::kNone;
+
+    // We can apply the opacity as paint alpha if it only affects one atomic draw.
+    // For now, this means all of the following must be true:
+    //   - the target node doesn't have any descendants;
+    //   - it only has a stroke or a fill (but not both);
+    //   - it does not have a filter.
+    // Going forward, we may needto refine this heuristic (e.g. to accommodate markers).
+    if ((flags & kLeaf) && (hasFill ^ hasStroke) && !hasFilter) {
+        fDeferredPaintOpacity *= opacity;
+    } else {
+        // Expensive, layer-based fall back.
+        SkPaint opacityPaint;
+        opacityPaint.setAlphaf(SkTPin(opacity, 0.0f, 1.0f));
+        // Balanced in the destructor, via restoreToCount().
+        fCanvas->saveLayer(nullptr, &opacityPaint);
+    }
+}
+
+void SkSVGRenderContext::applyFilter(const SkSVGFuncIRI& filter) {
+    if (filter.type() != SkSVGFuncIRI::Type::kIRI) {
+        return;
+    }
+
+    const auto node = this->findNodeById(filter.iri());
+    if (!node || node->tag() != SkSVGTag::kFilter) {
+        return;
+    }
+
+    const SkSVGFilter* filterNode = reinterpret_cast<const SkSVGFilter*>(node.get());
+    sk_sp<SkImageFilter> imageFilter = filterNode->buildFilterDAG(*this);
+    if (imageFilter) {
+        SkPaint filterPaint;
+        filterPaint.setImageFilter(imageFilter);
+        // Balanced in the destructor, via restoreToCount().
+        fCanvas->saveLayer(nullptr, &filterPaint);
+    }
+}
+
+void SkSVGRenderContext::saveOnce() {
+    // The canvas only needs to be saved once, per local SkSVGRenderContext.
+    if (fCanvas->getSaveCount() == fCanvasSaveCount) {
+        fCanvas->save();
+    }
+
+    SkASSERT(fCanvas->getSaveCount() > fCanvasSaveCount);
+}
+
+void SkSVGRenderContext::applyClip(const SkSVGFuncIRI& clip) {
+    if (clip.type() != SkSVGFuncIRI::Type::kIRI) {
+        return;
+    }
+
+    const auto clipNode = this->findNodeById(clip.iri());
+    if (!clipNode || clipNode->tag() != SkSVGTag::kClipPath) {
+        return;
+    }
+
+    const SkPath clipPath = static_cast<const SkSVGClipPath*>(clipNode.get())->resolveClip(*this);
+
+    // We use the computed clip path in two ways:
+    //
+    //   - apply to the current canvas, for drawing
+    //   - track in the presentation context, for asPath() composition
+    //
+    // TODO: the two uses are exclusive, avoid canvas churn when non needed.
+
+    this->saveOnce();
+
+    fCanvas->clipPath(clipPath, true);
+    fClipPath.set(clipPath);
+}
+
+void SkSVGRenderContext::applyMask(const SkSVGFuncIRI& mask) {
+    if (mask.type() != SkSVGFuncIRI::Type::kIRI) {
+        return;
+    }
+
+    const auto node = this->findNodeById(mask.iri());
+    if (!node || node->tag() != SkSVGTag::kMask) {
+        return;
+    }
+
+    const auto* mask_node = static_cast<const SkSVGMask*>(node.get());
+    const auto mask_bounds = mask_node->bounds(*this);
+
+    // Isolation/mask layer.
+    fCanvas->saveLayer(mask_bounds, nullptr);
+
+    // Render and filter mask content.
+    mask_node->renderMask(*this);
+
+    // Content layer
+    SkPaint masking_paint;
+    masking_paint.setBlendMode(SkBlendMode::kSrcIn);
+    fCanvas->saveLayer(mask_bounds, &masking_paint);
+
+    // Content is also clipped to the specified mask bounds.
+    fCanvas->clipRect(mask_bounds, true);
+
+    // At this point we're set up for content rendering.
+    // The pending layers are restored in the destructor (render context scope exit).
+    // Restoring triggers srcIn-compositing the content against the mask.
+}
+
+SkTLazy<SkPaint> SkSVGRenderContext::commonPaint(const SkSVGPaint& paint_selector,
+                                                 float paint_opacity) const {
+    if (paint_selector.type() == SkSVGPaint::Type::kNone) {
+        return SkTLazy<SkPaint>();
+    }
+
+    SkTLazy<SkPaint> p;
+    p.init();
+
+    switch (paint_selector.type()) {
+    case SkSVGPaint::Type::kColor:
+        p->setColor(this->resolveSvgColor(paint_selector.color()));
+        break;
+    case SkSVGPaint::Type::kIRI: {
+        // Our property inheritance is borked as it follows the render path and not the tree
+        // hierarchy.  To avoid gross transgressions like leaf node presentation attributes
+        // leaking into the paint server context, use a pristine presentation context when
+        // following hrefs.
+        //
+        // Preserve the OBB scope because some paints use object bounding box coords
+        // (e.g. gradient control points), which requires access to the render context
+        // and node being rendered.
+        SkSVGPresentationContext pctx;
+        pctx.fNamedColors = fPresentationContext->fNamedColors;
+        SkSVGRenderContext local_ctx(fCanvas,
+                                     fFontMgr,
+                                     fResourceProvider,
+                                     fIDMapper,
+                                     *fLengthContext,
+                                     pctx,
+                                     fOBBScope,
+                                     fTextShapingFactory);
+
+        const auto node = this->findNodeById(paint_selector.iri());
+        if (!node || !node->asPaint(local_ctx, p.get())) {
+            // Use the fallback color.
+            p->setColor(this->resolveSvgColor(paint_selector.color()));
+        }
+    } break;
+    default:
+        SkUNREACHABLE;
+    }
+
+    p->setAntiAlias(true); // TODO: shape-rendering support
+
+    // We observe 3 opacity components:
+    //   - initial paint server opacity (e.g. color stop opacity)
+    //   - paint-specific opacity (e.g. 'fill-opacity', 'stroke-opacity')
+    //   - deferred opacity override (optimization for leaf nodes 'opacity')
+    p->setAlphaf(SkTPin(p->getAlphaf() * paint_opacity * fDeferredPaintOpacity, 0.0f, 1.0f));
+
+    return p;
+}
+
+SkTLazy<SkPaint> SkSVGRenderContext::fillPaint() const {
+    const auto& props = fPresentationContext->fInherited;
+    auto p = this->commonPaint(*props.fFill, *props.fFillOpacity);
+
+    if (p.isValid()) {
+        p->setStyle(SkPaint::kFill_Style);
+    }
+
+    return p;
+}
+
+SkTLazy<SkPaint> SkSVGRenderContext::strokePaint() const {
+    const auto& props = fPresentationContext->fInherited;
+    auto p = this->commonPaint(*props.fStroke, *props.fStrokeOpacity);
+
+    if (p.isValid()) {
+        p->setStyle(SkPaint::kStroke_Style);
+        p->setStrokeWidth(fLengthContext->resolve(*props.fStrokeWidth,
+                                                  SkSVGLengthContext::LengthType::kOther));
+        p->setStrokeCap(toSkCap(*props.fStrokeLineCap));
+        p->setStrokeJoin(toSkJoin(*props.fStrokeLineJoin));
+        p->setStrokeMiter(*props.fStrokeMiterLimit);
+        p->setPathEffect(dash_effect(props, *fLengthContext));
+    }
+
+    return p;
+}
+
+SkSVGColorType SkSVGRenderContext::resolveSvgColor(const SkSVGColor& color) const {
+    if (fPresentationContext->fNamedColors) {
+        for (auto&& ident : color.vars()) {
+            SkSVGColorType* c = fPresentationContext->fNamedColors->find(ident);
+            if (c) {
+                return *c;
+            }
+        }
+    }
+    switch (color.type()) {
+        case SkSVGColor::Type::kColor:
+            return color.color();
+        case SkSVGColor::Type::kCurrentColor:
+            return *fPresentationContext->fInherited.fColor;
+        case SkSVGColor::Type::kICCColor:
+            SkDebugf("ICC color unimplemented");
+            return SK_ColorBLACK;
+    }
+    SkUNREACHABLE;
+}
+
+SkSVGRenderContext::OBBTransform
+SkSVGRenderContext::transformForCurrentOBB(SkSVGObjectBoundingBoxUnits u) const {
+    if (!fOBBScope.fNode || u.type() == SkSVGObjectBoundingBoxUnits::Type::kUserSpaceOnUse) {
+        return {{0,0},{1,1}};
+    }
+    SkASSERT(fOBBScope.fCtx);
+
+    const auto obb = fOBBScope.fNode->objectBoundingBox(*fOBBScope.fCtx);
+    return {{obb.x(), obb.y()}, {obb.width(), obb.height()}};
+}
+
+SkRect SkSVGRenderContext::resolveOBBRect(const SkSVGLength& x, const SkSVGLength& y,
+                                          const SkSVGLength& w, const SkSVGLength& h,
+                                          SkSVGObjectBoundingBoxUnits obbu) const {
+    SkTCopyOnFirstWrite<SkSVGLengthContext> lctx(fLengthContext);
+
+    if (obbu.type() == SkSVGObjectBoundingBoxUnits::Type::kObjectBoundingBox) {
+        *lctx.writable() = SkSVGLengthContext({1,1});
+    }
+
+    auto r = lctx->resolveRect(x, y, w, h);
+    const auto obbt = this->transformForCurrentOBB(obbu);
+
+    return SkRect::MakeXYWH(obbt.scale.x * r.x() + obbt.offset.x,
+                            obbt.scale.y * r.y() + obbt.offset.y,
+                            obbt.scale.x * r.width(),
+                            obbt.scale.y * r.height());
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp
new file mode 100644
index 00000000..389ac2a7
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGSVG.cpp
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGSVG.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+void SkSVGSVG::renderNode(const SkSVGRenderContext& ctx, const SkSVGIRI& iri) const {
+    SkSVGRenderContext localContext(ctx, this);
+    SkSVGRenderContext::BorrowedNode node = localContext.findNodeById(iri);
+    if (!node) {
+        return;
+    }
+
+    if (this->onPrepareToRender(&localContext)) {
+        if (this == node.get()) {
+            this->onRender(ctx);
+        } else {
+            node->render(localContext);
+        }
+    }
+}
+
+bool SkSVGSVG::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    // x/y are ignored for outermost svg elements
+    const auto x = fType == Type::kInner ? fX : SkSVGLength(0);
+    const auto y = fType == Type::kInner ? fY : SkSVGLength(0);
+
+    auto viewPortRect  = ctx->lengthContext().resolveRect(x, y, fWidth, fHeight);
+    auto contentMatrix = SkMatrix::Translate(viewPortRect.x(), viewPortRect.y());
+    auto viewPort      = SkSize::Make(viewPortRect.width(), viewPortRect.height());
+
+    if (fViewBox.isValid()) {
+        const SkRect& viewBox = *fViewBox;
+
+        // An empty viewbox disables rendering.
+        if (viewBox.isEmpty()) {
+            return false;
+        }
+
+        // A viewBox overrides the intrinsic viewport.
+        viewPort = SkSize::Make(viewBox.width(), viewBox.height());
+
+        contentMatrix.preConcat(ComputeViewboxMatrix(viewBox, viewPortRect, fPreserveAspectRatio));
+    }
+
+    if (!contentMatrix.isIdentity()) {
+        ctx->saveOnce();
+        ctx->canvas()->concat(contentMatrix);
+    }
+
+    if (viewPort != ctx->lengthContext().viewPort()) {
+        ctx->writableLengthContext()->setViewPort(viewPort);
+    }
+
+    return this->INHERITED::onPrepareToRender(ctx);
+}
+
+void SkSVGSVG::onSetAttribute(SkSVGAttribute attr, const SkSVGValue& v) {
+    switch (attr) {
+    case SkSVGAttribute::kX:
+        if (const auto* x = v.as<SkSVGLengthValue>()) {
+            this->setX(*x);
+        }
+        break;
+    case SkSVGAttribute::kY:
+        if (const auto* y = v.as<SkSVGLengthValue>()) {
+            this->setY(*y);
+        }
+        break;
+    case SkSVGAttribute::kWidth:
+        if (const auto* w = v.as<SkSVGLengthValue>()) {
+            this->setWidth(*w);
+        }
+        break;
+    case SkSVGAttribute::kHeight:
+        if (const auto* h = v.as<SkSVGLengthValue>()) {
+            this->setHeight(*h);
+        }
+        break;
+    case SkSVGAttribute::kViewBox:
+        if (const auto* vb = v.as<SkSVGViewBoxValue>()) {
+            this->setViewBox(*vb);
+        }
+        break;
+    case SkSVGAttribute::kPreserveAspectRatio:
+        if (const auto* par = v.as<SkSVGPreserveAspectRatioValue>()) {
+            this->setPreserveAspectRatio(*par);
+        }
+        break;
+    default:
+        this->INHERITED::onSetAttribute(attr, v);
+    }
+}
+
+// https://www.w3.org/TR/SVG11/coords.html#IntrinsicSizing
+SkSize SkSVGSVG::intrinsicSize(const SkSVGLengthContext& lctx) const {
+    // Percentage values do not provide an intrinsic size.
+    if (fWidth.unit() == SkSVGLength::Unit::kPercentage ||
+        fHeight.unit() == SkSVGLength::Unit::kPercentage) {
+        return SkSize::Make(0, 0);
+    }
+
+    return SkSize::Make(lctx.resolve(fWidth, SkSVGLengthContext::LengthType::kHorizontal),
+                        lctx.resolve(fHeight, SkSVGLengthContext::LengthType::kVertical));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp
new file mode 100644
index 00000000..617d8f7d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGShape.cpp
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGShape.h"
+
+SkSVGShape::SkSVGShape(SkSVGTag t) : INHERITED(t) {}
+
+void SkSVGShape::onRender(const SkSVGRenderContext& ctx) const {
+    const auto fillType = ctx.presentationContext().fInherited.fFillRule->asFillType();
+
+    const auto fillPaint = ctx.fillPaint(),
+             strokePaint = ctx.strokePaint();
+
+    // TODO: this approach forces duplicate geometry resolution in onDraw(); refactor to avoid.
+    if (fillPaint.isValid()) {
+        this->onDraw(ctx.canvas(), ctx.lengthContext(), *fillPaint, fillType);
+    }
+
+    if (strokePaint.isValid()) {
+        this->onDraw(ctx.canvas(), ctx.lengthContext(), *strokePaint, fillType);
+    }
+}
+
+void SkSVGShape::appendChild(sk_sp<SkSVGNode>) {
+    SkDebugf("cannot append child nodes to an SVG shape.\n");
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp
new file mode 100644
index 00000000..672ab253
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGStop.cpp
@@ -0,0 +1,18 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/private/base/SkTPin.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGStop.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGStop::SkSVGStop() : INHERITED(SkSVGTag::kStop) {}
+
+bool SkSVGStop::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setOffset(SkSVGAttributeParser::parse<SkSVGLength>("offset", n, v));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp
new file mode 100644
index 00000000..752c3e3d
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGText.cpp
@@ -0,0 +1,715 @@
+/*
+ * Copyright 2019 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGText.h"
+
+#include <limits>
+
+#include "include/core/SkCanvas.h"
+#include "include/core/SkContourMeasure.h"
+#include "include/core/SkFont.h"
+#include "include/core/SkFontMgr.h"
+#include "include/core/SkFontStyle.h"
+#include "include/core/SkPathBuilder.h"
+#include "include/core/SkRSXform.h"
+#include "include/core/SkString.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+#include "modules/svg/src/SkSVGTextPriv.h"
+#include "src/base/SkUTF.h"
+#include "src/core/SkTextBlobPriv.h"
+
+using namespace skia_private;
+
+namespace {
+
+static SkFont ResolveFont(const SkSVGRenderContext& ctx) {
+    auto weight = [](const SkSVGFontWeight& w) {
+        switch (w.type()) {
+            case SkSVGFontWeight::Type::k100:     return SkFontStyle::kThin_Weight;
+            case SkSVGFontWeight::Type::k200:     return SkFontStyle::kExtraLight_Weight;
+            case SkSVGFontWeight::Type::k300:     return SkFontStyle::kLight_Weight;
+            case SkSVGFontWeight::Type::k400:     return SkFontStyle::kNormal_Weight;
+            case SkSVGFontWeight::Type::k500:     return SkFontStyle::kMedium_Weight;
+            case SkSVGFontWeight::Type::k600:     return SkFontStyle::kSemiBold_Weight;
+            case SkSVGFontWeight::Type::k700:     return SkFontStyle::kBold_Weight;
+            case SkSVGFontWeight::Type::k800:     return SkFontStyle::kExtraBold_Weight;
+            case SkSVGFontWeight::Type::k900:     return SkFontStyle::kBlack_Weight;
+            case SkSVGFontWeight::Type::kNormal:  return SkFontStyle::kNormal_Weight;
+            case SkSVGFontWeight::Type::kBold:    return SkFontStyle::kBold_Weight;
+            case SkSVGFontWeight::Type::kBolder:  return SkFontStyle::kExtraBold_Weight;
+            case SkSVGFontWeight::Type::kLighter: return SkFontStyle::kLight_Weight;
+            case SkSVGFontWeight::Type::kInherit: {
+                SkASSERT(false);
+                return SkFontStyle::kNormal_Weight;
+            }
+        }
+        SkUNREACHABLE;
+    };
+
+    auto slant = [](const SkSVGFontStyle& s) {
+        switch (s.type()) {
+            case SkSVGFontStyle::Type::kNormal:  return SkFontStyle::kUpright_Slant;
+            case SkSVGFontStyle::Type::kItalic:  return SkFontStyle::kItalic_Slant;
+            case SkSVGFontStyle::Type::kOblique: return SkFontStyle::kOblique_Slant;
+            case SkSVGFontStyle::Type::kInherit: {
+                SkASSERT(false);
+                return SkFontStyle::kUpright_Slant;
+            }
+        }
+        SkUNREACHABLE;
+    };
+
+    const auto& family = ctx.presentationContext().fInherited.fFontFamily->family();
+    const SkFontStyle style(weight(*ctx.presentationContext().fInherited.fFontWeight),
+                            SkFontStyle::kNormal_Width,
+                            slant(*ctx.presentationContext().fInherited.fFontStyle));
+
+    const auto size =
+            ctx.lengthContext().resolve(ctx.presentationContext().fInherited.fFontSize->size(),
+                                        SkSVGLengthContext::LengthType::kVertical);
+
+    // TODO: we likely want matchFamilyStyle here, but switching away from legacyMakeTypeface
+    // changes all the results when using the default fontmgr.
+    auto tf = ctx.fontMgr()->legacyMakeTypeface(family.c_str(), style);
+    if (!tf) {
+        tf = ctx.fontMgr()->legacyMakeTypeface(nullptr, style);
+    }
+    SkASSERT(tf);
+    SkFont font(std::move(tf), size);
+    font.setHinting(SkFontHinting::kNone);
+    font.setSubpixel(true);
+    font.setLinearMetrics(true);
+    font.setBaselineSnap(false);
+    font.setEdging(SkFont::Edging::kAntiAlias);
+
+    return font;
+}
+
+static std::vector<float> ResolveLengths(const SkSVGLengthContext& lctx,
+                                         const std::vector<SkSVGLength>& lengths,
+                                         SkSVGLengthContext::LengthType lt) {
+    std::vector<float> resolved;
+    resolved.reserve(lengths.size());
+
+    for (const auto& l : lengths) {
+        resolved.push_back(lctx.resolve(l, lt));
+    }
+
+    return resolved;
+}
+
+static float ComputeAlignmentFactor(const SkSVGPresentationContext& pctx) {
+    switch (pctx.fInherited.fTextAnchor->type()) {
+    case SkSVGTextAnchor::Type::kStart : return  0.0f;
+    case SkSVGTextAnchor::Type::kMiddle: return -0.5f;
+    case SkSVGTextAnchor::Type::kEnd   : return -1.0f;
+    case SkSVGTextAnchor::Type::kInherit:
+        SkASSERT(false);
+        return 0.0f;
+    }
+    SkUNREACHABLE;
+}
+
+} // namespace
+
+SkSVGTextContext::ScopedPosResolver::ScopedPosResolver(const SkSVGTextContainer& txt,
+                                                       const SkSVGLengthContext& lctx,
+                                                       SkSVGTextContext* tctx,
+                                                       size_t charIndexOffset)
+    : fTextContext(tctx)
+    , fParent(tctx->fPosResolver)
+    , fCharIndexOffset(charIndexOffset)
+    , fX(ResolveLengths(lctx, txt.getX(), SkSVGLengthContext::LengthType::kHorizontal))
+    , fY(ResolveLengths(lctx, txt.getY(), SkSVGLengthContext::LengthType::kVertical))
+    , fDx(ResolveLengths(lctx, txt.getDx(), SkSVGLengthContext::LengthType::kHorizontal))
+    , fDy(ResolveLengths(lctx, txt.getDy(), SkSVGLengthContext::LengthType::kVertical))
+    , fRotate(txt.getRotate())
+{
+    fTextContext->fPosResolver = this;
+}
+
+SkSVGTextContext::ScopedPosResolver::ScopedPosResolver(const SkSVGTextContainer& txt,
+                                                       const SkSVGLengthContext& lctx,
+                                                       SkSVGTextContext* tctx)
+    : ScopedPosResolver(txt, lctx, tctx, tctx->fCurrentCharIndex) {}
+
+SkSVGTextContext::ScopedPosResolver::~ScopedPosResolver() {
+    fTextContext->fPosResolver = fParent;
+}
+
+SkSVGTextContext::PosAttrs SkSVGTextContext::ScopedPosResolver::resolve(size_t charIndex) const {
+    PosAttrs attrs;
+
+    if (charIndex < fLastPosIndex) {
+        SkASSERT(charIndex >= fCharIndexOffset);
+        const auto localCharIndex = charIndex - fCharIndexOffset;
+
+        const auto hasAllLocal = localCharIndex < fX.size() &&
+                                 localCharIndex < fY.size() &&
+                                 localCharIndex < fDx.size() &&
+                                 localCharIndex < fDy.size() &&
+                                 localCharIndex < fRotate.size();
+        if (!hasAllLocal && fParent) {
+            attrs = fParent->resolve(charIndex);
+        }
+
+        if (localCharIndex < fX.size()) {
+            attrs[PosAttrs::kX] = fX[localCharIndex];
+        }
+        if (localCharIndex < fY.size()) {
+            attrs[PosAttrs::kY] = fY[localCharIndex];
+        }
+        if (localCharIndex < fDx.size()) {
+            attrs[PosAttrs::kDx] = fDx[localCharIndex];
+        }
+        if (localCharIndex < fDy.size()) {
+            attrs[PosAttrs::kDy] = fDy[localCharIndex];
+        }
+
+        // Rotation semantics are interestingly different [1]:
+        //
+        //   - values are not cumulative
+        //   - if explicit values are present at any level in the ancestor chain, those take
+        //     precedence (closest ancestor)
+        //   - last specified value applies to all remaining chars (closest ancestor)
+        //   - these rules apply at node scope (not chunk scope)
+        //
+        // This means we need to discriminate between explicit rotation (rotate value provided for
+        // current char) and implicit rotation (ancestor has some values - but not for the requested
+        // char - we use the last specified value).
+        //
+        // [1] https://www.w3.org/TR/SVG11/text.html#TSpanElementRotateAttribute
+        if (!fRotate.empty()) {
+            if (localCharIndex < fRotate.size()) {
+                // Explicit rotation value overrides anything in the ancestor chain.
+                attrs[PosAttrs::kRotate] = fRotate[localCharIndex];
+                attrs.setImplicitRotate(false);
+            } else if (!attrs.has(PosAttrs::kRotate) || attrs.isImplicitRotate()){
+                // Local implicit rotation (last specified value) overrides ancestor implicit
+                // rotation.
+                attrs[PosAttrs::kRotate] = fRotate.back();
+                attrs.setImplicitRotate(true);
+            }
+        }
+
+        if (!attrs.hasAny()) {
+            // Once we stop producing explicit position data, there is no reason to
+            // continue trying for higher indices.  We can suppress future lookups.
+            fLastPosIndex = charIndex;
+        }
+    }
+
+    return attrs;
+}
+
+void SkSVGTextContext::ShapeBuffer::append(SkUnichar ch, PositionAdjustment pos) {
+    // relative pos adjustments are cumulative
+    if (!fUtf8PosAdjust.empty()) {
+        pos.offset += fUtf8PosAdjust.back().offset;
+    }
+
+    char utf8_buf[SkUTF::kMaxBytesInUTF8Sequence];
+    const auto utf8_len = SkToInt(SkUTF::ToUTF8(ch, utf8_buf));
+    fUtf8         .push_back_n(utf8_len, utf8_buf);
+    fUtf8PosAdjust.push_back_n(utf8_len, pos);
+}
+
+void SkSVGTextContext::shapePendingBuffer(const SkSVGRenderContext& ctx, const SkFont& font) {
+    const char* utf8 = fShapeBuffer.fUtf8.data();
+    size_t utf8Bytes = fShapeBuffer.fUtf8.size();
+
+    std::unique_ptr<SkShaper::FontRunIterator> font_runs =
+            SkShaper::MakeFontMgrRunIterator(utf8, utf8Bytes, font, ctx.fontMgr());
+    if (!font_runs) {
+        return;
+    }
+    if (!fForcePrimitiveShaping) {
+        // Try to use the passed in shaping callbacks to shape, for example, using harfbuzz and ICU.
+        const uint8_t defaultLTR = 0;
+        std::unique_ptr<SkShaper::BiDiRunIterator> bidi =
+                ctx.makeBidiRunIterator(utf8, utf8Bytes, defaultLTR);
+        std::unique_ptr<SkShaper::LanguageRunIterator> language =
+                SkShaper::MakeStdLanguageRunIterator(utf8, utf8Bytes);
+        std::unique_ptr<SkShaper::ScriptRunIterator> script = ctx.makeScriptRunIterator(utf8, utf8Bytes);
+
+        if (bidi && script && language) {
+            fShaper->shape(utf8,
+                           utf8Bytes,
+                           *font_runs,
+                           *bidi,
+                           *script,
+                           *language,
+                           nullptr,
+                           0,
+                           SK_ScalarMax,
+                           this);
+            fShapeBuffer.reset();
+            return;
+        }  // If any of the callbacks fail, we'll fallback to the primitive shaping.
+    }
+
+    // bidi, script, and lang are all unused so we can construct them with empty data.
+    SkShaper::TrivialBiDiRunIterator trivial_bidi{0, 0};
+    SkShaper::TrivialScriptRunIterator trivial_script{0, 0};
+    SkShaper::TrivialLanguageRunIterator trivial_lang{nullptr, 0};
+    fShaper->shape(utf8,
+                   utf8Bytes,
+                   *font_runs,
+                   trivial_bidi,
+                   trivial_script,
+                   trivial_lang,
+                   nullptr,
+                   0,
+                   SK_ScalarMax,
+                   this);
+    fShapeBuffer.reset();
+}
+
+SkSVGTextContext::SkSVGTextContext(const SkSVGRenderContext& ctx,
+                                   const ShapedTextCallback& cb,
+                                   const SkSVGTextPath* tpath)
+        : fRenderContext(ctx)
+        , fCallback(cb)
+        , fShaper(ctx.makeShaper())
+        , fChunkAlignmentFactor(ComputeAlignmentFactor(ctx.presentationContext())) {
+    // If the shaper callback returns null, fallback to the primitive shaper and
+    // signal that we should not use the other callbacks in shapePendingBuffer
+    if (!fShaper) {
+        fShaper = SkShapers::Primitive::PrimitiveText();
+        fForcePrimitiveShaping = true;
+    }
+    if (tpath) {
+        fPathData = std::make_unique<PathData>(ctx, *tpath);
+
+        // https://www.w3.org/TR/SVG11/text.html#TextPathElementStartOffsetAttribute
+        auto resolve_offset = [this](const SkSVGLength& offset) {
+            if (offset.unit() != SkSVGLength::Unit::kPercentage) {
+                // "If a <length> other than a percentage is given, then the startOffset
+                // represents a distance along the path measured in the current user coordinate
+                // system."
+                return fRenderContext.lengthContext()
+                                     .resolve(offset, SkSVGLengthContext::LengthType::kHorizontal);
+            }
+
+            // "If a percentage is given, then the startOffset represents a percentage distance
+            // along the entire path."
+            return offset.value() * fPathData->length() / 100;
+        };
+
+        // startOffset acts as an initial absolute position
+        fChunkPos.fX = resolve_offset(tpath->getStartOffset());
+    }
+}
+
+SkSVGTextContext::~SkSVGTextContext() {
+    this->flushChunk(fRenderContext);
+}
+
+void SkSVGTextContext::shapeFragment(const SkString& txt, const SkSVGRenderContext& ctx,
+                                     SkSVGXmlSpace xs) {
+    // https://www.w3.org/TR/SVG11/text.html#WhiteSpace
+    // https://www.w3.org/TR/2008/REC-xml-20081126/#NT-S
+    auto filterWSDefault = [this](SkUnichar ch) -> SkUnichar {
+        // Remove all newline chars.
+        if (ch == '\n') {
+            return -1;
+        }
+
+        // Convert tab chars to space.
+        if (ch == '\t') {
+            ch = ' ';
+        }
+
+        // Consolidate contiguous space chars and strip leading spaces (fPrevCharSpace
+        // starts off as true).
+        if (fPrevCharSpace && ch == ' ') {
+            return -1;
+        }
+
+        // TODO: Strip trailing WS?  Doing this across chunks would require another buffering
+        //   layer.  In general, trailing WS should have no rendering side effects. Skipping
+        //   for now.
+        return ch;
+    };
+    auto filterWSPreserve = [](SkUnichar ch) -> SkUnichar {
+        // Convert newline and tab chars to space.
+        if (ch == '\n' || ch == '\t') {
+            ch = ' ';
+        }
+        return ch;
+    };
+
+    // Stash paints for access from SkShaper callbacks.
+    fCurrentFill   = ctx.fillPaint();
+    fCurrentStroke = ctx.strokePaint();
+
+    const auto font = ResolveFont(ctx);
+    fShapeBuffer.reserve(txt.size());
+
+    const char* ch_ptr = txt.c_str();
+    const char* ch_end = ch_ptr + txt.size();
+
+    while (ch_ptr < ch_end) {
+        auto ch = SkUTF::NextUTF8(&ch_ptr, ch_end);
+        ch = (xs == SkSVGXmlSpace::kDefault)
+                ? filterWSDefault(ch)
+                : filterWSPreserve(ch);
+
+        if (ch < 0) {
+            // invalid utf or char filtered out
+            continue;
+        }
+
+        SkASSERT(fPosResolver);
+        const auto pos = fPosResolver->resolve(fCurrentCharIndex++);
+
+        // Absolute position adjustments define a new chunk.
+        // (https://www.w3.org/TR/SVG11/text.html#TextLayoutIntroduction)
+        if (pos.has(PosAttrs::kX) || pos.has(PosAttrs::kY)) {
+            this->shapePendingBuffer(ctx, font);
+            this->flushChunk(ctx);
+
+            // New chunk position.
+            if (pos.has(PosAttrs::kX)) {
+                fChunkPos.fX = pos[PosAttrs::kX];
+            }
+            if (pos.has(PosAttrs::kY)) {
+                fChunkPos.fY = pos[PosAttrs::kY];
+            }
+        }
+
+        fShapeBuffer.append(ch, {
+            {
+                pos.has(PosAttrs::kDx) ? pos[PosAttrs::kDx] : 0,
+                pos.has(PosAttrs::kDy) ? pos[PosAttrs::kDy] : 0,
+            },
+            pos.has(PosAttrs::kRotate) ? SkDegreesToRadians(pos[PosAttrs::kRotate]) : 0,
+        });
+
+        fPrevCharSpace = (ch == ' ');
+    }
+
+    this->shapePendingBuffer(ctx, font);
+
+    // Note: at this point we have shaped and buffered RunRecs for the current fragment.
+    // The active text chunk continues until an explicit or implicit flush.
+}
+
+SkSVGTextContext::PathData::PathData(const SkSVGRenderContext& ctx, const SkSVGTextPath& tpath)
+{
+    const auto ref = ctx.findNodeById(tpath.getHref());
+    if (!ref) {
+        return;
+    }
+
+    SkContourMeasureIter cmi(ref->asPath(ctx), false);
+    while (sk_sp<SkContourMeasure> contour = cmi.next()) {
+        fLength += contour->length();
+        fContours.push_back(std::move(contour));
+    }
+}
+
+SkMatrix SkSVGTextContext::PathData::getMatrixAt(float offset) const {
+    if (offset >= 0) {
+        for (const auto& contour : fContours) {
+            const auto contour_len = contour->length();
+            if (offset < contour_len) {
+                SkMatrix m;
+                return contour->getMatrix(offset, &m) ? m : SkMatrix::I();
+            }
+            offset -= contour_len;
+        }
+    }
+
+    // Quick & dirty way to "skip" rendering of glyphs off path.
+    return SkMatrix::Translate(std::numeric_limits<float>::infinity(),
+                               std::numeric_limits<float>::infinity());
+}
+
+SkRSXform SkSVGTextContext::computeGlyphXform(SkGlyphID glyph, const SkFont& font,
+                                              const SkPoint& glyph_pos,
+                                              const PositionAdjustment& pos_adjust) const {
+    SkPoint pos = fChunkPos + glyph_pos + pos_adjust.offset + fChunkAdvance * fChunkAlignmentFactor;
+    if (!fPathData) {
+        return SkRSXform::MakeFromRadians(/*scale=*/ 1, pos_adjust.rotation, pos.fX, pos.fY, 0, 0);
+    }
+
+    // We're in a textPath scope, reposition the glyph on path.
+    // (https://www.w3.org/TR/SVG11/text.html#TextpathLayoutRules)
+
+    // Path positioning is based on the glyph center (horizontal component).
+    float glyph_width;
+    font.getWidths(&glyph, 1, &glyph_width);
+    auto path_offset = pos.fX + glyph_width * .5f;
+
+    // In addition to the path matrix, the final glyph matrix also includes:
+    //
+    //   -- vertical position adjustment "dy" ("dx" is factored into path_offset)
+    //   -- glyph origin adjustment (undoing the glyph center offset above)
+    //   -- explicit rotation adjustment (composing with the path glyph rotation)
+    const auto m = fPathData->getMatrixAt(path_offset) *
+            SkMatrix::Translate(-glyph_width * .5f, pos_adjust.offset.fY) *
+            SkMatrix::RotateRad(pos_adjust.rotation);
+
+    return SkRSXform::Make(m.getScaleX(), m.getSkewY(), m.getTranslateX(), m.getTranslateY());
+}
+
+void SkSVGTextContext::flushChunk(const SkSVGRenderContext& ctx) {
+    SkTextBlobBuilder blobBuilder;
+
+    for (const auto& run : fRuns) {
+        const auto& buf = blobBuilder.allocRunRSXform(run.font, SkToInt(run.glyphCount));
+        std::copy(run.glyphs.get(), run.glyphs.get() + run.glyphCount, buf.glyphs);
+        for (size_t i = 0; i < run.glyphCount; ++i) {
+            buf.xforms()[i] = this->computeGlyphXform(run.glyphs[i],
+                                                      run.font,
+                                                      run.glyphPos[i],
+                                                      run.glyhPosAdjust[i]);
+        }
+
+        fCallback(ctx, blobBuilder.make(), run.fillPaint.get(), run.strokePaint.get());
+    }
+
+    fChunkPos += fChunkAdvance;
+    fChunkAdvance = {0,0};
+    fChunkAlignmentFactor = ComputeAlignmentFactor(ctx.presentationContext());
+
+    fRuns.clear();
+}
+
+SkShaper::RunHandler::Buffer SkSVGTextContext::runBuffer(const RunInfo& ri) {
+    SkASSERT(ri.glyphCount);
+
+    fRuns.push_back({
+        ri.fFont,
+        fCurrentFill.isValid()   ? std::make_unique<SkPaint>(*fCurrentFill)   : nullptr,
+        fCurrentStroke.isValid() ? std::make_unique<SkPaint>(*fCurrentStroke) : nullptr,
+        std::make_unique<SkGlyphID[]         >(ri.glyphCount),
+        std::make_unique<SkPoint[]           >(ri.glyphCount),
+        std::make_unique<PositionAdjustment[]>(ri.glyphCount),
+        ri.glyphCount,
+        ri.fAdvance,
+    });
+
+    // Ensure sufficient space to temporarily fetch cluster information.
+    fShapeClusterBuffer.resize(std::max(fShapeClusterBuffer.size(), ri.glyphCount));
+
+    return {
+        fRuns.back().glyphs.get(),
+        fRuns.back().glyphPos.get(),
+        nullptr,
+        fShapeClusterBuffer.data(),
+        fChunkAdvance,
+    };
+}
+
+void SkSVGTextContext::commitRunBuffer(const RunInfo& ri) {
+    const auto& current_run = fRuns.back();
+
+    // stash position adjustments
+    for (size_t i = 0; i < ri.glyphCount; ++i) {
+        const auto utf8_index = fShapeClusterBuffer[i];
+        current_run.glyhPosAdjust[i] = fShapeBuffer.fUtf8PosAdjust[SkToInt(utf8_index)];
+    }
+
+    fChunkAdvance += ri.fAdvance;
+}
+
+void SkSVGTextContext::commitLine() {
+    if (!fShapeBuffer.fUtf8PosAdjust.empty()) {
+        // Offset adjustments are cumulative - only advance the current chunk with the last value.
+        fChunkAdvance += fShapeBuffer.fUtf8PosAdjust.back().offset;
+    }
+}
+
+void SkSVGTextFragment::renderText(const SkSVGRenderContext& ctx, SkSVGTextContext* tctx,
+                                   SkSVGXmlSpace xs) const {
+    // N.B.: unlike regular elements, text fragments do not establish a new OBB scope -- they
+    // always defer to the root <text> element for OBB resolution.
+    SkSVGRenderContext localContext(ctx);
+
+    if (this->onPrepareToRender(&localContext)) {
+        this->onShapeText(localContext, tctx, xs);
+    }
+}
+
+SkPath SkSVGTextFragment::onAsPath(const SkSVGRenderContext&) const {
+    // TODO
+    return SkPath();
+}
+
+void SkSVGTextContainer::appendChild(sk_sp<SkSVGNode> child) {
+    // Only allow text content child nodes.
+    switch (child->tag()) {
+    case SkSVGTag::kTextLiteral:
+    case SkSVGTag::kTextPath:
+    case SkSVGTag::kTSpan:
+        fChildren.push_back(
+            sk_sp<SkSVGTextFragment>(static_cast<SkSVGTextFragment*>(child.release())));
+        break;
+    default:
+        break;
+    }
+}
+
+void SkSVGTextContainer::onShapeText(const SkSVGRenderContext& ctx, SkSVGTextContext* tctx,
+                                     SkSVGXmlSpace) const {
+    SkASSERT(tctx);
+
+    const SkSVGTextContext::ScopedPosResolver resolver(*this, ctx.lengthContext(), tctx);
+
+    for (const auto& frag : fChildren) {
+        // Containers always override xml:space with the local value.
+        frag->renderText(ctx, tctx, this->getXmlSpace());
+    }
+}
+
+// https://www.w3.org/TR/SVG11/text.html#WhiteSpace
+template <>
+bool SkSVGAttributeParser::parse(SkSVGXmlSpace* xs) {
+    static constexpr std::tuple<const char*, SkSVGXmlSpace> gXmlSpaceMap[] = {
+            {"default" , SkSVGXmlSpace::kDefault },
+            {"preserve", SkSVGXmlSpace::kPreserve},
+    };
+
+    return this->parseEnumMap(gXmlSpaceMap, xs) && this->parseEOSToken();
+}
+
+bool SkSVGTextContainer::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+           this->setX(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("x", name, value)) ||
+           this->setY(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("y", name, value)) ||
+           this->setDx(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("dx", name, value)) ||
+           this->setDy(SkSVGAttributeParser::parse<std::vector<SkSVGLength>>("dy", name, value)) ||
+           this->setRotate(SkSVGAttributeParser::parse<std::vector<SkSVGNumberType>>("rotate",
+                                                                                     name,
+                                                                                     value)) ||
+           this->setXmlSpace(SkSVGAttributeParser::parse<SkSVGXmlSpace>("xml:space", name, value));
+}
+
+void SkSVGTextLiteral::onShapeText(const SkSVGRenderContext& ctx, SkSVGTextContext* tctx,
+                                   SkSVGXmlSpace xs) const {
+    SkASSERT(tctx);
+
+    tctx->shapeFragment(this->getText(), ctx, xs);
+}
+
+void SkSVGText::onRender(const SkSVGRenderContext& ctx) const {
+    const SkSVGTextContext::ShapedTextCallback render_text = [](const SkSVGRenderContext& ctx,
+                                                                const sk_sp<SkTextBlob>& blob,
+                                                                const SkPaint* fill,
+                                                                const SkPaint* stroke) {
+        if (fill) {
+            ctx.canvas()->drawTextBlob(blob, 0, 0, *fill);
+        }
+        if (stroke) {
+            ctx.canvas()->drawTextBlob(blob, 0, 0, *stroke);
+        }
+    };
+
+    // Root <text> nodes establish a text layout context.
+    SkSVGTextContext tctx(ctx, render_text);
+
+    this->onShapeText(ctx, &tctx, this->getXmlSpace());
+}
+
+SkRect SkSVGText::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    SkRect bounds = SkRect::MakeEmpty();
+
+    const SkSVGTextContext::ShapedTextCallback compute_bounds =
+        [&bounds](const SkSVGRenderContext& ctx, const sk_sp<SkTextBlob>& blob, const SkPaint*,
+                  const SkPaint*) {
+            if (!blob) {
+                return;
+            }
+
+            AutoSTArray<64, SkRect> glyphBounds;
+
+            for (SkTextBlobRunIterator it(blob.get()); !it.done(); it.next()) {
+                glyphBounds.reset(SkToInt(it.glyphCount()));
+                it.font().getBounds(it.glyphs(), it.glyphCount(), glyphBounds.get(), nullptr);
+
+                SkASSERT(it.positioning() == SkTextBlobRunIterator::kRSXform_Positioning);
+                SkMatrix m;
+                for (uint32_t i = 0; i < it.glyphCount(); ++i) {
+                    m.setRSXform(it.xforms()[i]);
+                    bounds.join(m.mapRect(glyphBounds[i]));
+                }
+            }
+        };
+
+    {
+        SkSVGTextContext tctx(ctx, compute_bounds);
+        this->onShapeText(ctx, &tctx, this->getXmlSpace());
+    }
+
+    return bounds;
+}
+
+SkPath SkSVGText::onAsPath(const SkSVGRenderContext& ctx) const {
+    SkPathBuilder builder;
+
+    const SkSVGTextContext::ShapedTextCallback as_path =
+        [&builder](const SkSVGRenderContext& ctx, const sk_sp<SkTextBlob>& blob, const SkPaint*,
+                   const SkPaint*) {
+            if (!blob) {
+                return;
+            }
+
+            for (SkTextBlobRunIterator it(blob.get()); !it.done(); it.next()) {
+                struct GetPathsCtx {
+                    SkPathBuilder&   builder;
+                    const SkRSXform* xform;
+                } get_paths_ctx {builder, it.xforms()};
+
+                it.font().getPaths(it.glyphs(), it.glyphCount(), [](const SkPath* path,
+                                                                    const SkMatrix& matrix,
+                                                                    void* raw_ctx) {
+                    auto* get_paths_ctx = static_cast<GetPathsCtx*>(raw_ctx);
+                    const auto& glyph_rsx = *get_paths_ctx->xform++;
+
+                    if (!path) {
+                        return;
+                    }
+
+                    SkMatrix glyph_matrix;
+                    glyph_matrix.setRSXform(glyph_rsx);
+                    glyph_matrix.preConcat(matrix);
+
+                    get_paths_ctx->builder.addPath(path->makeTransform(glyph_matrix));
+                }, &get_paths_ctx);
+            }
+        };
+
+    {
+        SkSVGTextContext tctx(ctx, as_path);
+        this->onShapeText(ctx, &tctx, this->getXmlSpace());
+    }
+
+    auto path = builder.detach();
+    this->mapToParent(&path);
+
+    return path;
+}
+
+void SkSVGTextPath::onShapeText(const SkSVGRenderContext& ctx, SkSVGTextContext* parent_tctx,
+                                 SkSVGXmlSpace xs) const {
+    SkASSERT(parent_tctx);
+
+    // textPath nodes establish a new text layout context.
+    SkSVGTextContext tctx(ctx, parent_tctx->getCallback(), this);
+
+    this->INHERITED::onShapeText(ctx, &tctx, xs);
+}
+
+bool SkSVGTextPath::parseAndSetAttribute(const char* name, const char* value) {
+    return INHERITED::parseAndSetAttribute(name, value) ||
+        this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", name, value)) ||
+        this->setStartOffset(SkSVGAttributeParser::parse<SkSVGLength>("startOffset", name, value));
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h b/Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h
new file mode 100644
index 00000000..a7d614b2
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGTextPriv.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#ifndef SkSVGTextPriv_DEFINED
+#define SkSVGTextPriv_DEFINED
+
+#include "include/private/base/SkTArray.h"
+#include "modules/skshaper/include/SkShaper.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGText.h"
+#include "src/base/SkTLazy.h"
+
+#include <functional>
+#include <tuple>
+
+class SkContourMeasure;
+struct SkRSXform;
+
+// SkSVGTextContext is responsible for sequencing input text chars into "chunks".
+// A single text chunk can span multiple structural elements (<text>, <tspan>, etc),
+// and per [1] new chunks are emitted
+//
+//   a) for each top level text element (<text>, <textPath>)
+//   b) whenever a character with an explicit absolute position is encountered
+//
+// The implementation queues shaped run data until a full text chunk is resolved, at which
+// point we have enough information to perform final alignment and rendering.
+//
+// [1] https://www.w3.org/TR/SVG11/text.html#TextLayoutIntroduction
+class SkSVGTextContext final : SkShaper::RunHandler {
+public:
+    using ShapedTextCallback = std::function<void(const SkSVGRenderContext&,
+                                                  const sk_sp<SkTextBlob>&,
+                                                  const SkPaint*,
+                                                  const SkPaint*)>;
+
+    // Helper for encoding optional positional attributes.
+    class PosAttrs {
+    public:
+        // TODO: rotate
+        enum Attr : size_t {
+            kX      = 0,
+            kY      = 1,
+            kDx     = 2,
+            kDy     = 3,
+            kRotate = 4,
+        };
+
+        float  operator[](Attr a) const { return fStorage[a]; }
+        float& operator[](Attr a)       { return fStorage[a]; }
+
+        bool has(Attr a) const { return fStorage[a] != kNone; }
+        bool hasAny()    const {
+            return this->has(kX)
+                || this->has(kY)
+                || this->has(kDx)
+                || this->has(kDy)
+                || this->has(kRotate);
+        }
+
+        void setImplicitRotate(bool imp) { fImplicitRotate = imp; }
+        bool isImplicitRotate() const { return fImplicitRotate; }
+
+    private:
+        inline static constexpr auto kNone = std::numeric_limits<float>::infinity();
+
+        float fStorage[5]     = { kNone, kNone, kNone, kNone, kNone };
+        bool  fImplicitRotate = false;
+    };
+
+    // Helper for cascading position attribute resolution (x, y, dx, dy, rotate) [1]:
+    //   - each text position element can specify an arbitrary-length attribute array
+    //   - for each character, we look up a given attribute first in its local attribute array,
+    //     then in the ancestor chain (cascading/fallback) - and return the first value encountered.
+    //   - the lookup is based on character index relative to the text content subtree
+    //     (i.e. the index crosses chunk boundaries)
+    //
+    // [1] https://www.w3.org/TR/SVG11/text.html#TSpanElementXAttribute
+    class ScopedPosResolver {
+    public:
+        ScopedPosResolver(const SkSVGTextContainer&, const SkSVGLengthContext&, SkSVGTextContext*,
+                          size_t);
+
+        ScopedPosResolver(const SkSVGTextContainer&, const SkSVGLengthContext&, SkSVGTextContext*);
+
+        ~ScopedPosResolver();
+
+        PosAttrs resolve(size_t charIndex) const;
+
+    private:
+        SkSVGTextContext*         fTextContext;
+        const ScopedPosResolver*  fParent;          // parent resolver (fallback)
+        const size_t              fCharIndexOffset; // start index for the current resolver
+        const std::vector<float>  fX,
+                                  fY,
+                                  fDx,
+                                  fDy;
+        const std::vector<float>& fRotate;
+
+        // cache for the last known index with explicit positioning
+        mutable size_t           fLastPosIndex = std::numeric_limits<size_t>::max();
+
+    };
+
+    SkSVGTextContext(const SkSVGRenderContext&,
+                     const ShapedTextCallback&,
+                     const SkSVGTextPath* = nullptr);
+    ~SkSVGTextContext() override;
+
+    // Shape and queue codepoints for final alignment.
+    void shapeFragment(const SkString&, const SkSVGRenderContext&, SkSVGXmlSpace);
+
+    // Perform final adjustments and push shaped blobs to the callback.
+    void flushChunk(const SkSVGRenderContext& ctx);
+
+    const ShapedTextCallback& getCallback() const { return fCallback; }
+
+private:
+    struct PositionAdjustment {
+        SkVector offset;
+        float    rotation;
+    };
+
+    struct ShapeBuffer {
+        skia_private::STArray<128, char              , true> fUtf8;
+        // per-utf8-char cumulative pos adjustments
+        skia_private::STArray<128, PositionAdjustment, true> fUtf8PosAdjust;
+
+        void reserve(size_t size) {
+            fUtf8.reserve_exact(fUtf8.size() + SkToInt(size));
+            fUtf8PosAdjust.reserve_exact(fUtf8PosAdjust.size() + SkToInt(size));
+        }
+
+        void reset() {
+            fUtf8.clear();
+            fUtf8PosAdjust.clear();
+        }
+
+        void append(SkUnichar, PositionAdjustment);
+    };
+
+    struct RunRec {
+        SkFont                                font;
+        std::unique_ptr<SkPaint>              fillPaint,
+                                              strokePaint;
+        std::unique_ptr<SkGlyphID[]>          glyphs;        // filled by SkShaper
+        std::unique_ptr<SkPoint[]>            glyphPos;      // filled by SkShaper
+        std::unique_ptr<PositionAdjustment[]> glyhPosAdjust; // deferred positioning adjustments
+        size_t                                glyphCount;
+        SkVector                              advance;
+    };
+
+    // Caches path information to accelerate position lookups.
+    class PathData {
+    public:
+        PathData(const SkSVGRenderContext&, const SkSVGTextPath&);
+
+        SkMatrix getMatrixAt(float offset) const;
+
+        float length() const { return fLength; }
+
+    private:
+        std::vector<sk_sp<SkContourMeasure>> fContours;
+        float                                fLength = 0; // total path length
+    };
+
+    void shapePendingBuffer(const SkSVGRenderContext&, const SkFont&);
+
+    SkRSXform computeGlyphXform(SkGlyphID, const SkFont&, const SkPoint& glyph_pos,
+                                const PositionAdjustment&) const;
+
+    // SkShaper callbacks
+    void beginLine() override {}
+    void runInfo(const RunInfo&) override {}
+    void commitRunInfo() override {}
+    Buffer runBuffer(const RunInfo& ri) override;
+    void commitRunBuffer(const RunInfo& ri) override;
+    void commitLine() override;
+
+    // http://www.w3.org/TR/SVG11/text.html#TextLayout
+    const SkSVGRenderContext&       fRenderContext; // original render context
+    const ShapedTextCallback&       fCallback;
+    std::unique_ptr<SkShaper>       fShaper;
+    std::vector<RunRec>             fRuns;
+    const ScopedPosResolver*        fPosResolver = nullptr;
+    std::unique_ptr<PathData>       fPathData;
+
+    // shaper state
+    ShapeBuffer                     fShapeBuffer;
+    std::vector<uint32_t>           fShapeClusterBuffer;
+
+    // chunk state
+    SkPoint                         fChunkPos     = {0,0}; // current text chunk position
+    SkVector                        fChunkAdvance = {0,0}; // cumulative advance
+    float                           fChunkAlignmentFactor; // current chunk alignment
+
+    // tracks the global text subtree char index (cross chunks).  Used for position resolution.
+    size_t                          fCurrentCharIndex = 0;
+
+    // cached for access from SkShaper callbacks.
+    SkTLazy<SkPaint>                fCurrentFill;
+    SkTLazy<SkPaint>                fCurrentStroke;
+
+    bool                            fPrevCharSpace = true; // WS filter state
+    bool                            fForcePrimitiveShaping = false;
+};
+
+#endif // SkSVGTextPriv_DEFINED
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp
new file mode 100644
index 00000000..55f7550c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGTransformableNode.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGTransformableNode.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGTransformableNode::SkSVGTransformableNode(SkSVGTag tag)
+    : INHERITED(tag)
+    , fTransform(SkMatrix::I()) { }
+
+
+bool SkSVGTransformableNode::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    if (!fTransform.isIdentity()) {
+        ctx->saveOnce();
+        ctx->canvas()->concat(fTransform);
+    }
+
+    return this->INHERITED::onPrepareToRender(ctx);
+}
+
+void SkSVGTransformableNode::onSetAttribute(SkSVGAttribute attr, const SkSVGValue& v) {
+    switch (attr) {
+    case SkSVGAttribute::kTransform:
+        if (const auto* transform = v.as<SkSVGTransformValue>()) {
+            this->setTransform(*transform);
+        }
+        break;
+    default:
+        this->INHERITED::onSetAttribute(attr, v);
+        break;
+    }
+}
+
+void SkSVGTransformableNode::mapToParent(SkPath* path) const {
+    // transforms the path to parent node coordinates.
+    path->transform(fTransform);
+}
+
+void SkSVGTransformableNode::mapToParent(SkRect* rect) const {
+    *rect = fTransform.mapRect(*rect);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp
new file mode 100644
index 00000000..851cb640
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGUse.cpp
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2017 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "modules/svg/include/SkSVGUse.h"
+
+#include "include/core/SkCanvas.h"
+#include "modules/svg/include/SkSVGRenderContext.h"
+#include "modules/svg/include/SkSVGValue.h"
+
+SkSVGUse::SkSVGUse() : INHERITED(SkSVGTag::kUse) {}
+
+void SkSVGUse::appendChild(sk_sp<SkSVGNode>) {
+    SkDebugf("cannot append child nodes to this element.\n");
+}
+
+bool SkSVGUse::parseAndSetAttribute(const char* n, const char* v) {
+    return INHERITED::parseAndSetAttribute(n, v) ||
+           this->setX(SkSVGAttributeParser::parse<SkSVGLength>("x", n, v)) ||
+           this->setY(SkSVGAttributeParser::parse<SkSVGLength>("y", n, v)) ||
+           this->setHref(SkSVGAttributeParser::parse<SkSVGIRI>("xlink:href", n, v));
+}
+
+bool SkSVGUse::onPrepareToRender(SkSVGRenderContext* ctx) const {
+    if (fHref.iri().isEmpty() || !INHERITED::onPrepareToRender(ctx)) {
+        return false;
+    }
+
+    if (fX.value() || fY.value()) {
+        // Restored when the local SkSVGRenderContext leaves scope.
+        ctx->saveOnce();
+        ctx->canvas()->translate(fX.value(), fY.value());
+    }
+
+    // TODO: width/height override for <svg> targets.
+
+    return true;
+}
+
+void SkSVGUse::onRender(const SkSVGRenderContext& ctx) const {
+    const auto ref = ctx.findNodeById(fHref);
+    if (!ref) {
+        return;
+    }
+
+    ref->render(ctx);
+}
+
+SkPath SkSVGUse::onAsPath(const SkSVGRenderContext& ctx) const {
+    const auto ref = ctx.findNodeById(fHref);
+    if (!ref) {
+        return SkPath();
+    }
+
+    return ref->asPath(ctx);
+}
+
+SkRect SkSVGUse::onObjectBoundingBox(const SkSVGRenderContext& ctx) const {
+    const auto ref = ctx.findNodeById(fHref);
+    if (!ref) {
+        return SkRect::MakeEmpty();
+    }
+
+    const SkSVGLengthContext& lctx = ctx.lengthContext();
+    const SkScalar x = lctx.resolve(fX, SkSVGLengthContext::LengthType::kHorizontal);
+    const SkScalar y = lctx.resolve(fY, SkSVGLengthContext::LengthType::kVertical);
+
+    SkRect bounds = ref->objectBoundingBox(ctx);
+    bounds.offset(x, y);
+
+    return bounds;
+}
diff --git a/Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp b/Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp
new file mode 100644
index 00000000..0b9d9c1c
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/src/SkSVGValue.cpp
@@ -0,0 +1,7 @@
+/*
+ * Copyright 2016 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
diff --git a/Source/ThirdParty/skia/modules/svg/svg.gni b/Source/ThirdParty/skia/modules/svg/svg.gni
new file mode 100644
index 00000000..6d36446b
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/svg.gni
@@ -0,0 +1,115 @@
+# DO NOT EDIT: This is a generated file.
+# See //bazel/exporter_tool/README.md for more information.
+#
+# The sources of truth are:
+#   //modules/svg/include/BUILD.bazel
+#   //modules/svg/src/BUILD.bazel
+
+# To update this file, run make -C bazel generate_gni
+
+_modules = get_path_info("../../modules", "abspath")
+
+# Generated by Bazel rule //modules/svg/include:public_hdrs
+skia_svg_public = [
+  "$_modules/svg/include/SkSVGAttribute.h",
+  "$_modules/svg/include/SkSVGAttributeParser.h",
+  "$_modules/svg/include/SkSVGCircle.h",
+  "$_modules/svg/include/SkSVGClipPath.h",
+  "$_modules/svg/include/SkSVGContainer.h",
+  "$_modules/svg/include/SkSVGDOM.h",
+  "$_modules/svg/include/SkSVGDefs.h",
+  "$_modules/svg/include/SkSVGEllipse.h",
+  "$_modules/svg/include/SkSVGFe.h",
+  "$_modules/svg/include/SkSVGFeBlend.h",
+  "$_modules/svg/include/SkSVGFeColorMatrix.h",
+  "$_modules/svg/include/SkSVGFeComponentTransfer.h",
+  "$_modules/svg/include/SkSVGFeComposite.h",
+  "$_modules/svg/include/SkSVGFeDisplacementMap.h",
+  "$_modules/svg/include/SkSVGFeFlood.h",
+  "$_modules/svg/include/SkSVGFeGaussianBlur.h",
+  "$_modules/svg/include/SkSVGFeImage.h",
+  "$_modules/svg/include/SkSVGFeLightSource.h",
+  "$_modules/svg/include/SkSVGFeLighting.h",
+  "$_modules/svg/include/SkSVGFeMerge.h",
+  "$_modules/svg/include/SkSVGFeMorphology.h",
+  "$_modules/svg/include/SkSVGFeOffset.h",
+  "$_modules/svg/include/SkSVGFeTurbulence.h",
+  "$_modules/svg/include/SkSVGFilter.h",
+  "$_modules/svg/include/SkSVGFilterContext.h",
+  "$_modules/svg/include/SkSVGG.h",
+  "$_modules/svg/include/SkSVGGradient.h",
+  "$_modules/svg/include/SkSVGHiddenContainer.h",
+  "$_modules/svg/include/SkSVGIDMapper.h",
+  "$_modules/svg/include/SkSVGImage.h",
+  "$_modules/svg/include/SkSVGLine.h",
+  "$_modules/svg/include/SkSVGLinearGradient.h",
+  "$_modules/svg/include/SkSVGMask.h",
+  "$_modules/svg/include/SkSVGNode.h",
+  "$_modules/svg/include/SkSVGOpenTypeSVGDecoder.h",
+  "$_modules/svg/include/SkSVGPath.h",
+  "$_modules/svg/include/SkSVGPattern.h",
+  "$_modules/svg/include/SkSVGPoly.h",
+  "$_modules/svg/include/SkSVGRadialGradient.h",
+  "$_modules/svg/include/SkSVGRect.h",
+  "$_modules/svg/include/SkSVGRenderContext.h",
+  "$_modules/svg/include/SkSVGSVG.h",
+  "$_modules/svg/include/SkSVGShape.h",
+  "$_modules/svg/include/SkSVGStop.h",
+  "$_modules/svg/include/SkSVGText.h",
+  "$_modules/svg/include/SkSVGTransformableNode.h",
+  "$_modules/svg/include/SkSVGTypes.h",
+  "$_modules/svg/include/SkSVGUse.h",
+  "$_modules/svg/include/SkSVGValue.h",
+]
+
+# List generated by Bazel rules:
+#  //modules/svg/src:private_hdrs
+#  //modules/svg/src:srcs
+skia_svg_sources = [
+  "$_modules/svg/src/SkSVGAttribute.cpp",
+  "$_modules/svg/src/SkSVGAttributeParser.cpp",
+  "$_modules/svg/src/SkSVGCircle.cpp",
+  "$_modules/svg/src/SkSVGClipPath.cpp",
+  "$_modules/svg/src/SkSVGContainer.cpp",
+  "$_modules/svg/src/SkSVGDOM.cpp",
+  "$_modules/svg/src/SkSVGEllipse.cpp",
+  "$_modules/svg/src/SkSVGFe.cpp",
+  "$_modules/svg/src/SkSVGFeBlend.cpp",
+  "$_modules/svg/src/SkSVGFeColorMatrix.cpp",
+  "$_modules/svg/src/SkSVGFeComponentTransfer.cpp",
+  "$_modules/svg/src/SkSVGFeComposite.cpp",
+  "$_modules/svg/src/SkSVGFeDisplacementMap.cpp",
+  "$_modules/svg/src/SkSVGFeFlood.cpp",
+  "$_modules/svg/src/SkSVGFeGaussianBlur.cpp",
+  "$_modules/svg/src/SkSVGFeImage.cpp",
+  "$_modules/svg/src/SkSVGFeLightSource.cpp",
+  "$_modules/svg/src/SkSVGFeLighting.cpp",
+  "$_modules/svg/src/SkSVGFeMerge.cpp",
+  "$_modules/svg/src/SkSVGFeMorphology.cpp",
+  "$_modules/svg/src/SkSVGFeOffset.cpp",
+  "$_modules/svg/src/SkSVGFeTurbulence.cpp",
+  "$_modules/svg/src/SkSVGFilter.cpp",
+  "$_modules/svg/src/SkSVGFilterContext.cpp",
+  "$_modules/svg/src/SkSVGGradient.cpp",
+  "$_modules/svg/src/SkSVGImage.cpp",
+  "$_modules/svg/src/SkSVGLine.cpp",
+  "$_modules/svg/src/SkSVGLinearGradient.cpp",
+  "$_modules/svg/src/SkSVGMask.cpp",
+  "$_modules/svg/src/SkSVGNode.cpp",
+  "$_modules/svg/src/SkSVGOpenTypeSVGDecoder.cpp",
+  "$_modules/svg/src/SkSVGPath.cpp",
+  "$_modules/svg/src/SkSVGPattern.cpp",
+  "$_modules/svg/src/SkSVGPoly.cpp",
+  "$_modules/svg/src/SkSVGRadialGradient.cpp",
+  "$_modules/svg/src/SkSVGRect.cpp",
+  "$_modules/svg/src/SkSVGRectPriv.h",
+  "$_modules/svg/src/SkSVGRenderContext.cpp",
+  "$_modules/svg/src/SkSVGSVG.cpp",
+  "$_modules/svg/src/SkSVGShape.cpp",
+  "$_modules/svg/src/SkSVGStop.cpp",
+  "$_modules/svg/src/SkSVGText.cpp",
+  "$_modules/svg/src/SkSVGTextPriv.h",
+  "$_modules/svg/src/SkSVGTransformableNode.cpp",
+  "$_modules/svg/src/SkSVGUse.cpp",
+  "$_modules/svg/src/SkSVGValue.cpp",
+]
diff --git a/Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel
new file mode 100644
index 00000000..800b999a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/tests/BUILD.bazel
@@ -0,0 +1,5 @@
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
diff --git a/Source/ThirdParty/skia/modules/svg/tests/Filters.cpp b/Source/ThirdParty/skia/modules/svg/tests/Filters.cpp
new file mode 100644
index 00000000..b7ee21d4
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/tests/Filters.cpp
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2021 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <string>
+
+#include "include/core/SkStream.h"
+#include "include/utils/SkNoDrawCanvas.h"
+#include "modules/svg/include/SkSVGDOM.h"
+#include "modules/svg/include/SkSVGNode.h"
+#include "tests/Test.h"
+
+DEF_TEST(Svg_Filters_NonePaintInputs, r) {
+    const std::string svgText = R"EOF(
+    <svg width="500" height="500" xmlns="http://www.w3.org/2000/svg"
+         xmlns:xlink="http://www.w3.org/1999/xlink">
+        <defs>
+            <filter id="f" x="0" y="0" width="1" height="1">
+                <feComposite operator="arithmetic" in="FillPaint" in2="StrokePaint"
+                             k1="0" k2="10" k3="20" k4="0"/>
+            </filter>
+        </defs>
+        <rect fill="none" stroke="none" filter="url(#f)" x="10" y="10" width="100" height="1,0"/>
+    </svg>
+    )EOF";
+
+    auto str = SkMemoryStream::MakeDirect(svgText.c_str(), svgText.size());
+    auto svg_dom = SkSVGDOM::Builder().make(*str);
+    SkNoDrawCanvas canvas(500, 500);
+    svg_dom->render(&canvas);
+}
diff --git a/Source/ThirdParty/skia/modules/svg/tests/Text.cpp b/Source/ThirdParty/skia/modules/svg/tests/Text.cpp
new file mode 100644
index 00000000..0831101e
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/tests/Text.cpp
@@ -0,0 +1,194 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <vector>
+
+#include "include/utils/SkNoDrawCanvas.h"
+#include "modules/skshaper/utils/FactoryHelpers.h"
+#include "modules/svg/src/SkSVGTextPriv.h"
+#include "tests/Test.h"
+#include "tools/fonts/FontToolUtils.h"
+
+DEF_TEST(Svg_Text_PosProvider, r) {
+    const auto L = [](float x) { return SkSVGLength(x); };
+    const float N = SkSVGTextContext::PosAttrs()[SkSVGTextContext::PosAttrs::kX];
+
+    static const struct PosTestDesc {
+        size_t                   offseta;
+        std::vector<SkSVGLength> xa, ya;
+
+        size_t                   offsetb;
+        std::vector<SkSVGLength> xb, yb;
+
+        std::vector<SkPoint>     expected;
+    } gTests[] = {
+        {
+            0, {}, {},
+            0, {}, {},
+
+            { {N,N} }
+        },
+
+        {
+            0, { L(1) }, {},
+            0, {      }, {},
+
+            { {1,N}, {N,N} }
+        },
+        {
+            0, {       }, {},
+            0, { L(10) }, {},
+
+            { {10,N}, {N,N} }
+        },
+        {
+            0, { L( 1) }, {},
+            0, { L(10) }, {},
+
+            { {10,N}, {N,N} }
+        },
+        {
+            0, { L( 1), L(2) }, {},
+            0, { L(10)       }, {},
+
+            { {10,N}, {2,N}, {N,N} }
+        },
+        {
+            0, { L(1), L( 2) }, {},
+            1, {       L(20) }, {},
+
+            { {1,N}, {20,N}, {N,N} }
+        },
+        {
+            0, { L(1), L( 2), L(3) }, {},
+            1, {       L(20)       }, {},
+
+            { {1,N}, {20,N}, {3,N}, {N,N} }
+        },
+        {
+            0, { L(1), L(2), L( 3) }, {},
+            2, {             L(30) }, {},
+
+            { {1,N}, {2,N}, {30,N}, {N,N} }
+        },
+        {
+            0, { L(1)              }, {},
+            2, {             L(30) }, {},
+
+            { {1,N}, {N,N}, {30,N}, {N,N} }
+        },
+
+
+        {
+            0, {}, { L(4) },
+            0, {}, {      },
+
+            { {N,4}, {N,N} }
+        },
+        {
+            0, {}, {       },
+            0, {}, { L(40) },
+
+            { {N,40}, {N,N} }
+        },
+        {
+            0, {}, { L( 4) },
+            0, {}, { L(40) },
+
+            { {N,40}, {N,N} }
+        },
+        {
+            0, {}, { L( 4), L(5) },
+            0, {}, { L(40)       },
+
+            { {N,40}, {N,5}, {N,N} }
+        },
+        {
+            0, {}, { L(4), L( 5) },
+            1, {}, {       L(50) },
+
+            { {N,4}, {N,50}, {N,N} }
+        },
+        {
+            0, {}, { L(4), L( 5), L(6) },
+            1, {}, {       L(50)       },
+
+            { {N,4}, {N,50}, {N,6}, {N,N} }
+        },
+        {
+            0, {}, { L(4), L(5), L( 6) },
+            2, {}, {             L(60) },
+
+            { {N,4}, {N,5}, {N,60}, {N,N} }
+        },
+        {
+            0, {}, { L(4)              },
+            2, {}, {             L(60) },
+
+            { {N,4}, {N,N}, {N,60}, {N,N} }
+        },
+
+        {
+            0, { L( 1), L(2)}, { L( 4)        },
+            0, { L(10)      }, { L(40), L(50) },
+
+            { {10,40}, {2,50}, {N,N} }
+        },
+        {
+            0, { L(1), L( 2), L(3) }, { L(4), L( 5)        },
+            1, {       L(20)       }, {       L(50), L(60) },
+
+            { {1,4}, {20,50}, {3,60}, {N,N} }
+        },
+    };
+
+    const SkSVGTextContext::ShapedTextCallback mock_cb =
+        [](const SkSVGRenderContext&, const sk_sp<SkTextBlob>&, const SkPaint*, const SkPaint*) {};
+
+    auto test = [&](const PosTestDesc& tst) {
+        auto a = SkSVGText::Make();
+        auto b = SkSVGTSpan::Make();
+        a->appendChild(b);
+
+        a->setX(tst.xa);
+        a->setY(tst.ya);
+        b->setX(tst.xb);
+        b->setY(tst.yb);
+
+        const SkSVGIDMapper mapper;
+        const SkSVGLengthContext lctx({0,0});
+        const SkSVGPresentationContext pctx;
+        SkNoDrawCanvas canvas(0, 0);
+        sk_sp<SkFontMgr> fmgr = ToolUtils::TestFontMgr();
+        sk_sp<skresources::ResourceProvider> rp;
+        sk_sp<SkShapers::Factory> shaping = SkShapers::BestAvailable();
+        const SkSVGRenderContext ctx(&canvas,
+                                     fmgr,
+                                     rp,
+                                     mapper,
+                                     lctx,
+                                     pctx,
+                                     {nullptr, nullptr},
+                                     shaping);
+
+        SkSVGTextContext tctx(ctx, mock_cb);
+        SkSVGTextContext::ScopedPosResolver pa(*a, lctx, &tctx, tst.offseta);
+        SkSVGTextContext::ScopedPosResolver pb(*b, lctx, &tctx, tst.offsetb);
+
+        for (size_t i = 0; i < tst.expected.size(); ++i) {
+            const auto& exp = tst.expected[i];
+            auto pos = i >= tst.offsetb ? pb.resolve(i) : pa.resolve(i);
+
+            REPORTER_ASSERT(r, pos[SkSVGTextContext::PosAttrs::kX] == exp.fX);
+            REPORTER_ASSERT(r, pos[SkSVGTextContext::PosAttrs::kY] == exp.fY);
+        }
+    };
+
+    for (const auto& tst : gTests) {
+        test(tst);
+    }
+}
diff --git a/Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel b/Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel
new file mode 100644
index 00000000..800b999a
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/utils/BUILD.bazel
@@ -0,0 +1,5 @@
+package(
+    default_applicable_licenses = ["//:license"],
+)
+
+licenses(["notice"])
diff --git a/Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp b/Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp
new file mode 100644
index 00000000..11b28173
--- /dev/null
+++ b/Source/ThirdParty/skia/modules/svg/utils/SvgTool.cpp
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include <iostream>
+
+#include "include/core/SkMatrix.h"
+#include "include/core/SkStream.h"
+#include "include/core/SkSurface.h"
+#include "include/encode/SkPngEncoder.h"
+#include "modules/skresources/include/SkResources.h"
+#include "modules/skshaper/utils/FactoryHelpers.h"
+#include "modules/svg/include/SkSVGDOM.h"
+#include "src/utils/SkOSPath.h"
+#include "tools/CodecUtils.h"
+#include "tools/flags/CommandLineFlags.h"
+#include "tools/fonts/FontToolUtils.h"
+
+#if defined(SK_BUILD_FOR_MAC)
+#include "include/ports/SkFontMgr_mac_ct.h"
+#else
+#include "include/ports/SkFontMgr_empty.h"
+#endif
+
+static DEFINE_string2(input , i, nullptr, "Input SVG file.");
+static DEFINE_string2(output, o, nullptr, "Output PNG file.");
+
+static DEFINE_int(width , 1024, "Output width.");
+static DEFINE_int(height, 1024, "Output height.");
+
+int main(int argc, char** argv) {
+    CommandLineFlags::Parse(argc, argv);
+
+    if (FLAGS_input.isEmpty() || FLAGS_output.isEmpty()) {
+        std::cerr << "Missing required 'input' and 'output' args.\n";
+        return 1;
+    }
+
+    if (FLAGS_width <= 0 || FLAGS_height <= 0) {
+        std::cerr << "Invalid width/height.\n";
+        return 1;
+    }
+
+    SkFILEStream in(FLAGS_input[0]);
+    if (!in.isValid()) {
+        std::cerr << "Could not open " << FLAGS_input[0] << "\n";
+        return 1;
+    }
+
+    // If necessary, clients should use a font manager that would load fonts from the system.
+#if defined(SK_BUILD_FOR_MAC)
+    sk_sp<SkFontMgr> fontMgr = SkFontMgr_New_CoreText(nullptr);
+#else
+    sk_sp<SkFontMgr> fontMgr = SkFontMgr_New_Custom_Empty();
+#endif
+
+    CodecUtils::RegisterAllAvailable();
+
+    auto predecode = skresources::ImageDecodeStrategy::kPreDecode;
+    auto rp = skresources::DataURIResourceProviderProxy::Make(
+            skresources::FileResourceProvider::Make(SkOSPath::Dirname(FLAGS_input[0]), predecode),
+            predecode,
+            fontMgr);
+
+    auto svg_dom = SkSVGDOM::Builder()
+                           .setFontManager(fontMgr)
+                           .setResourceProvider(std::move(rp))
+                           .setTextShapingFactory(SkShapers::BestAvailable())
+                           .make(in);
+
+    if (!svg_dom) {
+        std::cerr << "Could not parse " << FLAGS_input[0] << "\n";
+        return 1;
+    }
+
+    auto surface = SkSurfaces::Raster(SkImageInfo::MakeN32Premul(FLAGS_width, FLAGS_height));
+
+    svg_dom->setContainerSize(SkSize::Make(FLAGS_width, FLAGS_height));
+    svg_dom->render(surface->getCanvas());
+
+    SkPixmap pixmap;
+    surface->peekPixels(&pixmap);
+
+    SkFILEWStream out(FLAGS_output[0]);
+    if (!out.isValid()) {
+        std::cerr << "Could not open " << FLAGS_output[0] << " for writing.\n";
+        return 1;
+    }
+
+    // Use default encoding options.
+    SkPngEncoder::Options png_options;
+
+    if (!SkPngEncoder::Encode(&out, pixmap, png_options)) {
+        std::cerr << "PNG encoding failed.\n";
+        return 1;
+    }
+
+    return 0;
+}
-- 
2.47.0

